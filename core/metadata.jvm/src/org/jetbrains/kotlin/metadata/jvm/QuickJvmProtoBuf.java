// Code generated by protocol buffer compiler. Do not edit!
package org.jetbrains.kotlin.metadata.jvm;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoEnum;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedInt;
import us.hebi.quickbuf.RepeatedMessage;
import us.hebi.quickbuf.Utf8String;

public final class QuickJvmProtoBuf {
  /**
   * Protobuf type {@code StringTableTypes}
   */
  public static final class StringTableTypes extends ProtoMessage<StringTableTypes> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <pre>
     *  Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5 [packed = true];</code>
     */
    private RepeatedInt localName = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    private RepeatedMessage<Record> record = null;

    private StringTableTypes() {
    }

    /**
     * @return a new empty instance of {@code StringTableTypes}
     */
    public static StringTableTypes newInstance() {
      return new StringTableTypes();
    }

    private void initLocalName() {
      if (localName == null) {
        localName = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <pre>
     *  Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5 [packed = true];</code>
     * @return whether the localName field is set
     */
    public boolean hasLocalName() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <pre>
     *  Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5 [packed = true];</code>
     * @return this
     */
    public StringTableTypes clearLocalName() {
      bitField0_ &= ~0x00000001;
      if (localName != null) {
        localName.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5 [packed = true];</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLocalName()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getLocalName() {
      initLocalName();
      return localName;
    }

    /**
     * <pre>
     *  Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5 [packed = true];</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableLocalName() {
      initLocalName();
      bitField0_ |= 0x00000001;
      return localName;
    }

    /**
     * <pre>
     *  Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5 [packed = true];</code>
     * @param value the localName to add
     * @return this
     */
    public StringTableTypes addLocalName(final int value) {
      initLocalName();
      bitField0_ |= 0x00000001;
      localName.add(value);
      return this;
    }

    /**
     * <pre>
     *  Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5 [packed = true];</code>
     * @param values the localName to add
     * @return this
     */
    public StringTableTypes addAllLocalName(final int... values) {
      initLocalName();
      bitField0_ |= 0x00000001;
      localName.addAll(values);
      return this;
    }

    private void initRecord() {
      if (record == null) {
        record = RepeatedMessage.newEmptyInstance(Record.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     * @return whether the record field is set
     */
    public boolean hasRecord() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     * @return this
     */
    public StringTableTypes clearRecord() {
      bitField0_ &= ~0x00000002;
      if (record != null) {
        record.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRecord()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Record> getRecord() {
      initRecord();
      return record;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Record> getMutableRecord() {
      initRecord();
      bitField0_ |= 0x00000002;
      return record;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     * @param value the record to add
     * @return this
     */
    public StringTableTypes addRecord(final Record value) {
      initRecord();
      bitField0_ |= 0x00000002;
      record.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     * @param values the record to add
     * @return this
     */
    public StringTableTypes addAllRecord(final Record... values) {
      initRecord();
      bitField0_ |= 0x00000002;
      record.addAll(values);
      return this;
    }

    @Override
    public StringTableTypes copyFrom(final StringTableTypes other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasLocalName()) {
          initLocalName();
          localName.copyFrom(other.localName);
        } else {
          clearLocalName();
        }
        if (other.hasRecord()) {
          initRecord();
          record.copyFrom(other.record);
        } else {
          clearRecord();
        }
      }
      return this;
    }

    @Override
    public StringTableTypes mergeFrom(final StringTableTypes other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLocalName()) {
        getMutableLocalName().addAll(other.localName);
      }
      if (other.hasRecord()) {
        getMutableRecord().addAll(other.record);
      }
      return this;
    }

    @Override
    public StringTableTypes clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (localName != null) {
        localName.clear();
      }
      if (record != null) {
        record.clear();
      }
      return this;
    }

    @Override
    public StringTableTypes clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (localName != null) {
        localName.clear();
      }
      if (record != null) {
        record.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StringTableTypes)) {
        return false;
      }
      StringTableTypes other = (StringTableTypes) o;
      return bitField0_ == other.bitField0_
        && (!hasLocalName() || localName.equals(other.localName))
        && (!hasRecord() || record.equals(other.record));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 42);
        output.writePackedInt32NoTag(localName);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < record.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(record.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(localName);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * record.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(record);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StringTableTypes mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 42: {
            // localName [packed=true]
            initLocalName();
            input.readPackedInt32(localName, tag);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // record
            initRecord();
            tag = input.readRepeatedMessage(record, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 40: {
            // localName [packed=false]
            initLocalName();
            tag = input.readRepeatedInt32(localName, tag);
            bitField0_ |= 0x00000001;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRepeatedInt32(FieldNames.localName, localName);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.record, record);
      }
      output.endObject();
    }

    @Override
    public StringTableTypes mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1205395306:
          case 1303527135: {
            if (input.isAtField(FieldNames.localName)) {
              if (!input.trySkipNullValue()) {
                initLocalName();
                input.readRepeatedInt32(localName);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -934908847: {
            if (input.isAtField(FieldNames.record)) {
              if (!input.trySkipNullValue()) {
                initRecord();
                input.readRepeatedMessage(record);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StringTableTypes clone() {
      return new StringTableTypes().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StringTableTypes parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StringTableTypes(), data).checkInitialized();
    }

    public static StringTableTypes parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StringTableTypes(), input).checkInitialized();
    }

    public static StringTableTypes parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StringTableTypes(), input).checkInitialized();
    }

    /**
     * @return factory for creating StringTableTypes messages
     */
    public static MessageFactory<StringTableTypes> getFactory() {
      return StringTableTypesFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code Record}
     */
    public static final class Record extends ProtoMessage<Record> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <pre>
       *  The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>optional int32 range = 1 [default = 1];</code>
       */
      private int range = 1;

      /**
       * <pre>
       *  Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>optional int32 predefined_index = 2;</code>
       */
      private int predefinedIndex;

      /**
       * <pre>
       *  Perform a described operation on the string
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       */
      private int operation = org.jetbrains.kotlin.metadata.jvm.QuickJvmProtoBuf.StringTableTypes.Record.Operation.NONE_VALUE;

      /**
       * <pre>
       *  A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>optional string string = 6;</code>
       */
      private Utf8String string = null;

      /**
       * <pre>
       *  If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       *  and the second element as the end index.
       *  If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4 [packed = true];</code>
       */
      private RepeatedInt substringIndex = null;

      /**
       * <pre>
       *  If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       *  of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5 [packed = true];</code>
       */
      private RepeatedInt replaceChar = null;

      private Record() {
      }

      /**
       * @return a new empty instance of {@code Record}
       */
      public static Record newInstance() {
        return new Record();
      }

      /**
       * <pre>
       *  The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>optional int32 range = 1 [default = 1];</code>
       * @return whether the range field is set
       */
      public boolean hasRange() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <pre>
       *  The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>optional int32 range = 1 [default = 1];</code>
       * @return this
       */
      public Record clearRange() {
        bitField0_ &= ~0x00000001;
        range = 1;
        return this;
      }

      /**
       * <pre>
       *  The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>optional int32 range = 1 [default = 1];</code>
       * @return the range
       */
      public int getRange() {
        return range;
      }

      /**
       * <pre>
       *  The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>optional int32 range = 1 [default = 1];</code>
       * @param value the range to set
       * @return this
       */
      public Record setRange(final int value) {
        bitField0_ |= 0x00000001;
        range = value;
        return this;
      }

      /**
       * <pre>
       *  Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>optional int32 predefined_index = 2;</code>
       * @return whether the predefinedIndex field is set
       */
      public boolean hasPredefinedIndex() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <pre>
       *  Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>optional int32 predefined_index = 2;</code>
       * @return this
       */
      public Record clearPredefinedIndex() {
        bitField0_ &= ~0x00000002;
        predefinedIndex = 0;
        return this;
      }

      /**
       * <pre>
       *  Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>optional int32 predefined_index = 2;</code>
       * @return the predefinedIndex
       */
      public int getPredefinedIndex() {
        return predefinedIndex;
      }

      /**
       * <pre>
       *  Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>optional int32 predefined_index = 2;</code>
       * @param value the predefinedIndex to set
       * @return this
       */
      public Record setPredefinedIndex(final int value) {
        bitField0_ |= 0x00000002;
        predefinedIndex = value;
        return this;
      }

      /**
       * <pre>
       *  Perform a described operation on the string
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       * @return whether the operation field is set
       */
      public boolean hasOperation() {
        return (bitField0_ & 0x00000004) != 0;
      }

      /**
       * <pre>
       *  Perform a described operation on the string
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       * @return this
       */
      public Record clearOperation() {
        bitField0_ &= ~0x00000004;
        operation = org.jetbrains.kotlin.metadata.jvm.QuickJvmProtoBuf.StringTableTypes.Record.Operation.NONE_VALUE;
        return this;
      }

      /**
       * <pre>
       *  Perform a described operation on the string
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       * @return the operation
       */
      public Operation getOperation() {
        return Operation.forNumberOr(operation, org.jetbrains.kotlin.metadata.jvm.QuickJvmProtoBuf.StringTableTypes.Record.Operation.NONE);
      }

      /**
       * Gets the value of the internal enum store. The result is
       * equivalent to {@link Record#getOperation()}.getNumber().
       *
       * @return numeric wire representation
       */
      public int getOperationValue() {
        return operation;
      }

      /**
       * Sets the value of the internal enum store. This does not
       * do any validity checks, so be sure to use appropriate value
       * constants from {@link Operation}. Setting an invalid value
       * can cause {@link Record#getOperation()} to return null
       *
       * @param value the numeric wire value to set
       * @return this
       */
      public Record setOperationValue(final int value) {
        bitField0_ |= 0x00000004;
        operation = value;
        return this;
      }

      /**
       * <pre>
       *  Perform a described operation on the string
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       * @param value the operation to set
       * @return this
       */
      public Record setOperation(final Operation value) {
        bitField0_ |= 0x00000004;
        operation = value.getNumber();
        return this;
      }

      private void initString() {
        if (string == null) {
          string = Utf8String.newEmptyInstance();
        }
      }

      /**
       * <pre>
       *  A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>optional string string = 6;</code>
       * @return whether the string field is set
       */
      public boolean hasString() {
        return (bitField0_ & 0x00000008) != 0;
      }

      /**
       * <pre>
       *  A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>optional string string = 6;</code>
       * @return this
       */
      public Record clearString() {
        bitField0_ &= ~0x00000008;
        if (string != null) {
          string.clear();
        }
        return this;
      }

      /**
       * <pre>
       *  A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>optional string string = 6;</code>
       * @return the string
       */
      public String getString() {
        initString();
        return string.getString();
      }

      /**
       * <pre>
       *  A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>optional string string = 6;</code>
       * @return internal {@code Utf8String} representation of string for reading
       */
      public Utf8String getStringBytes() {
        initString();
        return this.string;
      }

      /**
       * <pre>
       *  A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>optional string string = 6;</code>
       * @return internal {@code Utf8String} representation of string for modifications
       */
      public Utf8String getMutableStringBytes() {
        initString();
        bitField0_ |= 0x00000008;
        return this.string;
      }

      /**
       * <pre>
       *  A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>optional string string = 6;</code>
       * @param value the string to set
       * @return this
       */
      public Record setString(final CharSequence value) {
        initString();
        bitField0_ |= 0x00000008;
        string.copyFrom(value);
        return this;
      }

      /**
       * <pre>
       *  A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>optional string string = 6;</code>
       * @param value the string to set
       * @return this
       */
      public Record setString(final Utf8String value) {
        initString();
        bitField0_ |= 0x00000008;
        string.copyFrom(value);
        return this;
      }

      private void initSubstringIndex() {
        if (substringIndex == null) {
          substringIndex = RepeatedInt.newEmptyInstance();
        }
      }

      /**
       * <pre>
       *  If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       *  and the second element as the end index.
       *  If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4 [packed = true];</code>
       * @return whether the substringIndex field is set
       */
      public boolean hasSubstringIndex() {
        return (bitField0_ & 0x00000010) != 0;
      }

      /**
       * <pre>
       *  If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       *  and the second element as the end index.
       *  If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4 [packed = true];</code>
       * @return this
       */
      public Record clearSubstringIndex() {
        bitField0_ &= ~0x00000010;
        if (substringIndex != null) {
          substringIndex.clear();
        }
        return this;
      }

      /**
       * <pre>
       *  If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       *  and the second element as the end index.
       *  If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4 [packed = true];</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableSubstringIndex()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedInt getSubstringIndex() {
        initSubstringIndex();
        return substringIndex;
      }

      /**
       * <pre>
       *  If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       *  and the second element as the end index.
       *  If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4 [packed = true];</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedInt getMutableSubstringIndex() {
        initSubstringIndex();
        bitField0_ |= 0x00000010;
        return substringIndex;
      }

      /**
       * <pre>
       *  If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       *  and the second element as the end index.
       *  If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4 [packed = true];</code>
       * @param value the substringIndex to add
       * @return this
       */
      public Record addSubstringIndex(final int value) {
        initSubstringIndex();
        bitField0_ |= 0x00000010;
        substringIndex.add(value);
        return this;
      }

      /**
       * <pre>
       *  If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       *  and the second element as the end index.
       *  If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4 [packed = true];</code>
       * @param values the substringIndex to add
       * @return this
       */
      public Record addAllSubstringIndex(final int... values) {
        initSubstringIndex();
        bitField0_ |= 0x00000010;
        substringIndex.addAll(values);
        return this;
      }

      private void initReplaceChar() {
        if (replaceChar == null) {
          replaceChar = RepeatedInt.newEmptyInstance();
        }
      }

      /**
       * <pre>
       *  If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       *  of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5 [packed = true];</code>
       * @return whether the replaceChar field is set
       */
      public boolean hasReplaceChar() {
        return (bitField0_ & 0x00000020) != 0;
      }

      /**
       * <pre>
       *  If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       *  of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5 [packed = true];</code>
       * @return this
       */
      public Record clearReplaceChar() {
        bitField0_ &= ~0x00000020;
        if (replaceChar != null) {
          replaceChar.clear();
        }
        return this;
      }

      /**
       * <pre>
       *  If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       *  of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5 [packed = true];</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableReplaceChar()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedInt getReplaceChar() {
        initReplaceChar();
        return replaceChar;
      }

      /**
       * <pre>
       *  If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       *  of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5 [packed = true];</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedInt getMutableReplaceChar() {
        initReplaceChar();
        bitField0_ |= 0x00000020;
        return replaceChar;
      }

      /**
       * <pre>
       *  If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       *  of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5 [packed = true];</code>
       * @param value the replaceChar to add
       * @return this
       */
      public Record addReplaceChar(final int value) {
        initReplaceChar();
        bitField0_ |= 0x00000020;
        replaceChar.add(value);
        return this;
      }

      /**
       * <pre>
       *  If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       *  of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5 [packed = true];</code>
       * @param values the replaceChar to add
       * @return this
       */
      public Record addAllReplaceChar(final int... values) {
        initReplaceChar();
        bitField0_ |= 0x00000020;
        replaceChar.addAll(values);
        return this;
      }

      @Override
      public Record copyFrom(final Record other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          range = other.range;
          predefinedIndex = other.predefinedIndex;
          operation = other.operation;
          if (other.hasString()) {
            initString();
            string.copyFrom(other.string);
          } else {
            clearString();
          }
          if (other.hasSubstringIndex()) {
            initSubstringIndex();
            substringIndex.copyFrom(other.substringIndex);
          } else {
            clearSubstringIndex();
          }
          if (other.hasReplaceChar()) {
            initReplaceChar();
            replaceChar.copyFrom(other.replaceChar);
          } else {
            clearReplaceChar();
          }
        }
        return this;
      }

      @Override
      public Record mergeFrom(final Record other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasRange()) {
          setRange(other.range);
        }
        if (other.hasPredefinedIndex()) {
          setPredefinedIndex(other.predefinedIndex);
        }
        if (other.hasOperation()) {
          setOperationValue(other.operation);
        }
        if (other.hasString()) {
          getMutableStringBytes().copyFrom(other.string);
        }
        if (other.hasSubstringIndex()) {
          getMutableSubstringIndex().addAll(other.substringIndex);
        }
        if (other.hasReplaceChar()) {
          getMutableReplaceChar().addAll(other.replaceChar);
        }
        return this;
      }

      @Override
      public Record clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        range = 1;
        predefinedIndex = 0;
        operation = org.jetbrains.kotlin.metadata.jvm.QuickJvmProtoBuf.StringTableTypes.Record.Operation.NONE_VALUE;
        if (string != null) {
          string.clear();
        }
        if (substringIndex != null) {
          substringIndex.clear();
        }
        if (replaceChar != null) {
          replaceChar.clear();
        }
        return this;
      }

      @Override
      public Record clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        if (string != null) {
          string.clear();
        }
        if (substringIndex != null) {
          substringIndex.clear();
        }
        if (replaceChar != null) {
          replaceChar.clear();
        }
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof Record)) {
          return false;
        }
        Record other = (Record) o;
        return bitField0_ == other.bitField0_
          && (!hasRange() || range == other.range)
          && (!hasPredefinedIndex() || predefinedIndex == other.predefinedIndex)
          && (!hasOperation() || operation == other.operation)
          && (!hasString() || string.equals(other.string))
          && (!hasSubstringIndex() || substringIndex.equals(other.substringIndex))
          && (!hasReplaceChar() || replaceChar.equals(other.replaceChar));
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 8);
          output.writeInt32NoTag(range);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 16);
          output.writeInt32NoTag(predefinedIndex);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 24);
          output.writeEnumNoTag(operation);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRawByte((byte) 50);
          output.writeStringNoTag(string);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRawByte((byte) 34);
          output.writePackedInt32NoTag(substringIndex);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRawByte((byte) 42);
          output.writePackedInt32NoTag(replaceChar);
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(range);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(predefinedIndex);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeEnumSizeNoTag(operation);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += 1 + ProtoSink.computeStringSizeNoTag(string);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(substringIndex);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(replaceChar);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public Record mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 8: {
              // range
              range = input.readInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 16) {
                break;
              }
            }
            case 16: {
              // predefinedIndex
              predefinedIndex = input.readInt32();
              bitField0_ |= 0x00000002;
              tag = input.readTag();
              if (tag != 24) {
                break;
              }
            }
            case 24: {
              // operation
              final int value = input.readInt32();
              if (Operation.forNumber(value) != null) {
                operation = value;
                bitField0_ |= 0x00000004;
              }
              tag = input.readTag();
              if (tag != 50) {
                break;
              }
            }
            case 50: {
              // string
              initString();
              input.readString(string);
              bitField0_ |= 0x00000008;
              tag = input.readTag();
              if (tag != 34) {
                break;
              }
            }
            case 34: {
              // substringIndex [packed=true]
              initSubstringIndex();
              input.readPackedInt32(substringIndex, tag);
              bitField0_ |= 0x00000010;
              tag = input.readTag();
              if (tag != 42) {
                break;
              }
            }
            case 42: {
              // replaceChar [packed=true]
              initReplaceChar();
              input.readPackedInt32(replaceChar, tag);
              bitField0_ |= 0x00000020;
              tag = input.readTag();
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
            case 32: {
              // substringIndex [packed=false]
              initSubstringIndex();
              tag = input.readRepeatedInt32(substringIndex, tag);
              bitField0_ |= 0x00000010;
              break;
            }
            case 40: {
              // replaceChar [packed=false]
              initReplaceChar();
              tag = input.readRepeatedInt32(replaceChar, tag);
              bitField0_ |= 0x00000020;
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt32(FieldNames.range, range);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeInt32(FieldNames.predefinedIndex, predefinedIndex);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeEnum(FieldNames.operation, operation, Operation.converter());
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeString(FieldNames.string, string);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRepeatedInt32(FieldNames.substringIndex, substringIndex);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRepeatedInt32(FieldNames.replaceChar, replaceChar);
        }
        output.endObject();
      }

      @Override
      public Record mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case 108280125: {
              if (input.isAtField(FieldNames.range)) {
                if (!input.trySkipNullValue()) {
                  range = input.readInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 333123180:
            case -1932563111: {
              if (input.isAtField(FieldNames.predefinedIndex)) {
                if (!input.trySkipNullValue()) {
                  predefinedIndex = input.readInt32();
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 1662702951: {
              if (input.isAtField(FieldNames.operation)) {
                if (!input.trySkipNullValue()) {
                  final Operation value = input.readEnum(Operation.converter());
                  if (value != null) {
                    operation = value.getNumber();
                    bitField0_ |= 0x00000004;
                  } else {
                    input.skipUnknownEnumValue();
                  }
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -891985903: {
              if (input.isAtField(FieldNames.string)) {
                if (!input.trySkipNullValue()) {
                  initString();
                  input.readString(string);
                  bitField0_ |= 0x00000008;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 256251137:
            case -20629148: {
              if (input.isAtField(FieldNames.substringIndex)) {
                if (!input.trySkipNullValue()) {
                  initSubstringIndex();
                  input.readRepeatedInt32(substringIndex);
                  bitField0_ |= 0x00000010;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 429670442:
            case 460597761: {
              if (input.isAtField(FieldNames.replaceChar)) {
                if (!input.trySkipNullValue()) {
                  initReplaceChar();
                  input.readRepeatedInt32(replaceChar);
                  bitField0_ |= 0x00000020;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public Record clone() {
        return new Record().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static Record parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new Record(), data).checkInitialized();
      }

      public static Record parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Record(), input).checkInitialized();
      }

      public static Record parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Record(), input).checkInitialized();
      }

      /**
       * @return factory for creating Record messages
       */
      public static MessageFactory<Record> getFactory() {
        return RecordFactory.INSTANCE;
      }

      /**
       * Protobuf enum {@code Operation}
       */
      public enum Operation implements ProtoEnum<Operation> {
        /**
         * <code>NONE = 0;</code>
         */
        NONE("NONE", 0),

        /**
         * <pre>
         *  replaceAll('$', '.')
         *  java/util/Map$Entry -> java/util/Map.Entry;
         * </pre>
         *
         * <code>INTERNAL_TO_CLASS_ID = 1;</code>
         */
        INTERNAL_TO_CLASS_ID("INTERNAL_TO_CLASS_ID", 1),

        /**
         * <pre>
         *  substring(1, length - 1) and then replaceAll('$', '.')
         *  Ljava/util/Map$Entry; -> java/util/Map.Entry
         * </pre>
         *
         * <code>DESC_TO_CLASS_ID = 2;</code>
         */
        DESC_TO_CLASS_ID("DESC_TO_CLASS_ID", 2);

        /**
         * <code>NONE = 0;</code>
         */
        public static final int NONE_VALUE = 0;

        /**
         * <pre>
         *  replaceAll('$', '.')
         *  java/util/Map$Entry -> java/util/Map.Entry;
         * </pre>
         *
         * <code>INTERNAL_TO_CLASS_ID = 1;</code>
         */
        public static final int INTERNAL_TO_CLASS_ID_VALUE = 1;

        /**
         * <pre>
         *  substring(1, length - 1) and then replaceAll('$', '.')
         *  Ljava/util/Map$Entry; -> java/util/Map.Entry
         * </pre>
         *
         * <code>DESC_TO_CLASS_ID = 2;</code>
         */
        public static final int DESC_TO_CLASS_ID_VALUE = 2;

        private final String name;

        private final int number;

        private Operation(String name, int number) {
          this.name = name;
          this.number = number;
        }

        /**
         * @return the string representation of enum entry
         */
        @Override
        public String getName() {
          return name;
        }

        /**
         * @return the numeric wire value of this enum entry
         */
        @Override
        public int getNumber() {
          return number;
        }

        /**
         * @return a converter that maps between this enum's numeric and text representations
         */
        public static ProtoEnum.EnumConverter<Operation> converter() {
          return OperationConverter.INSTANCE;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value, or null if unknown.
         */
        public static Operation forNumber(int value) {
          return OperationConverter.INSTANCE.forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @param other Fallback value in case the value is not known.
         * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
         */
        public static Operation forNumberOr(int number, Operation other) {
          Operation value = forNumber(number);
          return value == null ? other : value;
        }

        enum OperationConverter implements ProtoEnum.EnumConverter<Operation> {
          INSTANCE;

          private static final Operation[] lookup = new Operation[3];

          static {
            lookup[0] = NONE;
            lookup[1] = INTERNAL_TO_CLASS_ID;
            lookup[2] = DESC_TO_CLASS_ID;
          }

          @Override
          public final Operation forNumber(final int value) {
            if (value >= 0 && value < lookup.length) {
              return lookup[value];
            }
            return null;
          }

          @Override
          public final Operation forName(final CharSequence value) {
            if (value.length() == 4) {
              if (ProtoUtil.isEqual("NONE", value)) {
                return NONE;
              }
            }
            if (value.length() == 16) {
              if (ProtoUtil.isEqual("DESC_TO_CLASS_ID", value)) {
                return DESC_TO_CLASS_ID;
              }
            }
            if (value.length() == 20) {
              if (ProtoUtil.isEqual("INTERNAL_TO_CLASS_ID", value)) {
                return INTERNAL_TO_CLASS_ID;
              }
            }
            return null;
          }
        }
      }

      private enum RecordFactory implements MessageFactory<Record> {
        INSTANCE;

        @Override
        public Record create() {
          return Record.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName range = FieldName.forField("range");

        static final FieldName predefinedIndex = FieldName.forField("predefinedIndex", "predefined_index");

        static final FieldName operation = FieldName.forField("operation");

        static final FieldName string = FieldName.forField("string");

        static final FieldName substringIndex = FieldName.forField("substringIndex", "substring_index");

        static final FieldName replaceChar = FieldName.forField("replaceChar", "replace_char");
      }
    }

    private enum StringTableTypesFactory implements MessageFactory<StringTableTypes> {
      INSTANCE;

      @Override
      public StringTableTypes create() {
        return StringTableTypes.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName localName = FieldName.forField("localName", "local_name");

      static final FieldName record = FieldName.forField("record");
    }
  }

  /**
   * Protobuf type {@code JvmMethodSignature}
   */
  public static final class JvmMethodSignature extends ProtoMessage<JvmMethodSignature> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 name = 1;</code>
     */
    private int name;

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     */
    private int desc;

    private JvmMethodSignature() {
    }

    /**
     * @return a new empty instance of {@code JvmMethodSignature}
     */
    public static JvmMethodSignature newInstance() {
      return new JvmMethodSignature();
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @return this
     */
    public JvmMethodSignature clearName() {
      bitField0_ &= ~0x00000001;
      name = 0;
      return this;
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @return the name
     */
    public int getName() {
      return name;
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @param value the name to set
     * @return this
     */
    public JvmMethodSignature setName(final int value) {
      bitField0_ |= 0x00000001;
      name = value;
      return this;
    }

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     * @return whether the desc field is set
     */
    public boolean hasDesc() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     * @return this
     */
    public JvmMethodSignature clearDesc() {
      bitField0_ &= ~0x00000002;
      desc = 0;
      return this;
    }

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     * @return the desc
     */
    public int getDesc() {
      return desc;
    }

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     * @param value the desc to set
     * @return this
     */
    public JvmMethodSignature setDesc(final int value) {
      bitField0_ |= 0x00000002;
      desc = value;
      return this;
    }

    @Override
    public JvmMethodSignature copyFrom(final JvmMethodSignature other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        name = other.name;
        desc = other.desc;
      }
      return this;
    }

    @Override
    public JvmMethodSignature mergeFrom(final JvmMethodSignature other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasName()) {
        setName(other.name);
      }
      if (other.hasDesc()) {
        setDesc(other.desc);
      }
      return this;
    }

    @Override
    public JvmMethodSignature clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      name = 0;
      desc = 0;
      return this;
    }

    @Override
    public JvmMethodSignature clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof JvmMethodSignature)) {
        return false;
      }
      JvmMethodSignature other = (JvmMethodSignature) o;
      return bitField0_ == other.bitField0_
        && (!hasName() || name == other.name)
        && (!hasDesc() || desc == other.desc);
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(name);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(desc);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(name);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(desc);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public JvmMethodSignature mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // name
            name = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // desc
            desc = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.name, name);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt32(FieldNames.desc, desc);
      }
      output.endObject();
    }

    @Override
    public JvmMethodSignature mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3373707: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                name = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3079825: {
            if (input.isAtField(FieldNames.desc)) {
              if (!input.trySkipNullValue()) {
                desc = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public JvmMethodSignature clone() {
      return new JvmMethodSignature().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static JvmMethodSignature parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new JvmMethodSignature(), data).checkInitialized();
    }

    public static JvmMethodSignature parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new JvmMethodSignature(), input).checkInitialized();
    }

    public static JvmMethodSignature parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new JvmMethodSignature(), input).checkInitialized();
    }

    /**
     * @return factory for creating JvmMethodSignature messages
     */
    public static MessageFactory<JvmMethodSignature> getFactory() {
      return JvmMethodSignatureFactory.INSTANCE;
    }

    private enum JvmMethodSignatureFactory implements MessageFactory<JvmMethodSignature> {
      INSTANCE;

      @Override
      public JvmMethodSignature create() {
        return JvmMethodSignature.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName name = FieldName.forField("name");

      static final FieldName desc = FieldName.forField("desc");
    }
  }

  /**
   * Protobuf type {@code JvmFieldSignature}
   */
  public static final class JvmFieldSignature extends ProtoMessage<JvmFieldSignature> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 name = 1;</code>
     */
    private int name;

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     */
    private int desc;

    private JvmFieldSignature() {
    }

    /**
     * @return a new empty instance of {@code JvmFieldSignature}
     */
    public static JvmFieldSignature newInstance() {
      return new JvmFieldSignature();
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @return this
     */
    public JvmFieldSignature clearName() {
      bitField0_ &= ~0x00000001;
      name = 0;
      return this;
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @return the name
     */
    public int getName() {
      return name;
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @param value the name to set
     * @return this
     */
    public JvmFieldSignature setName(final int value) {
      bitField0_ |= 0x00000001;
      name = value;
      return this;
    }

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     * @return whether the desc field is set
     */
    public boolean hasDesc() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     * @return this
     */
    public JvmFieldSignature clearDesc() {
      bitField0_ &= ~0x00000002;
      desc = 0;
      return this;
    }

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     * @return the desc
     */
    public int getDesc() {
      return desc;
    }

    /**
     * <pre>
     *  JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>optional int32 desc = 2;</code>
     * @param value the desc to set
     * @return this
     */
    public JvmFieldSignature setDesc(final int value) {
      bitField0_ |= 0x00000002;
      desc = value;
      return this;
    }

    @Override
    public JvmFieldSignature copyFrom(final JvmFieldSignature other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        name = other.name;
        desc = other.desc;
      }
      return this;
    }

    @Override
    public JvmFieldSignature mergeFrom(final JvmFieldSignature other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasName()) {
        setName(other.name);
      }
      if (other.hasDesc()) {
        setDesc(other.desc);
      }
      return this;
    }

    @Override
    public JvmFieldSignature clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      name = 0;
      desc = 0;
      return this;
    }

    @Override
    public JvmFieldSignature clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof JvmFieldSignature)) {
        return false;
      }
      JvmFieldSignature other = (JvmFieldSignature) o;
      return bitField0_ == other.bitField0_
        && (!hasName() || name == other.name)
        && (!hasDesc() || desc == other.desc);
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(name);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(desc);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(name);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(desc);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public JvmFieldSignature mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // name
            name = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // desc
            desc = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.name, name);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt32(FieldNames.desc, desc);
      }
      output.endObject();
    }

    @Override
    public JvmFieldSignature mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3373707: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                name = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3079825: {
            if (input.isAtField(FieldNames.desc)) {
              if (!input.trySkipNullValue()) {
                desc = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public JvmFieldSignature clone() {
      return new JvmFieldSignature().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static JvmFieldSignature parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new JvmFieldSignature(), data).checkInitialized();
    }

    public static JvmFieldSignature parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new JvmFieldSignature(), input).checkInitialized();
    }

    public static JvmFieldSignature parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new JvmFieldSignature(), input).checkInitialized();
    }

    /**
     * @return factory for creating JvmFieldSignature messages
     */
    public static MessageFactory<JvmFieldSignature> getFactory() {
      return JvmFieldSignatureFactory.INSTANCE;
    }

    private enum JvmFieldSignatureFactory implements MessageFactory<JvmFieldSignature> {
      INSTANCE;

      @Override
      public JvmFieldSignature create() {
        return JvmFieldSignature.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName name = FieldName.forField("name");

      static final FieldName desc = FieldName.forField("desc");
    }
  }

  /**
   * Protobuf type {@code JvmPropertySignature}
   */
  public static final class JvmPropertySignature extends ProtoMessage<JvmPropertySignature> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     */
    private JvmFieldSignature field = null;

    /**
     * <pre>
     *  Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     */
    private JvmMethodSignature syntheticMethod = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     */
    private JvmMethodSignature getter = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     */
    private JvmMethodSignature setter = null;

    /**
     * <pre>
     *  The delegate field of delegated properties may be optimized out; `getDelegate` should
     *  then call this method instead
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     */
    private JvmMethodSignature delegateMethod = null;

    private JvmPropertySignature() {
    }

    /**
     * @return a new empty instance of {@code JvmPropertySignature}
     */
    public static JvmPropertySignature newInstance() {
      return new JvmPropertySignature();
    }

    private void initField() {
      if (field == null) {
        field = JvmFieldSignature.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     * @return whether the field field is set
     */
    public boolean hasField() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     * @return this
     */
    public JvmPropertySignature clearField() {
      bitField0_ &= ~0x00000001;
      if (field != null) {
        field.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableField()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public JvmFieldSignature getField() {
      initField();
      return field;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public JvmFieldSignature getMutableField() {
      initField();
      bitField0_ |= 0x00000001;
      return field;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     * @param value the field to set
     * @return this
     */
    public JvmPropertySignature setField(final JvmFieldSignature value) {
      initField();
      bitField0_ |= 0x00000001;
      field.copyFrom(value);
      return this;
    }

    private void initSyntheticMethod() {
      if (syntheticMethod == null) {
        syntheticMethod = JvmMethodSignature.newInstance();
      }
    }

    /**
     * <pre>
     *  Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     * @return whether the syntheticMethod field is set
     */
    public boolean hasSyntheticMethod() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <pre>
     *  Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     * @return this
     */
    public JvmPropertySignature clearSyntheticMethod() {
      bitField0_ &= ~0x00000002;
      if (syntheticMethod != null) {
        syntheticMethod.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSyntheticMethod()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public JvmMethodSignature getSyntheticMethod() {
      initSyntheticMethod();
      return syntheticMethod;
    }

    /**
     * <pre>
     *  Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public JvmMethodSignature getMutableSyntheticMethod() {
      initSyntheticMethod();
      bitField0_ |= 0x00000002;
      return syntheticMethod;
    }

    /**
     * <pre>
     *  Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     * @param value the syntheticMethod to set
     * @return this
     */
    public JvmPropertySignature setSyntheticMethod(final JvmMethodSignature value) {
      initSyntheticMethod();
      bitField0_ |= 0x00000002;
      syntheticMethod.copyFrom(value);
      return this;
    }

    private void initGetter() {
      if (getter == null) {
        getter = JvmMethodSignature.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     * @return whether the getter field is set
     */
    public boolean hasGetter() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     * @return this
     */
    public JvmPropertySignature clearGetter() {
      bitField0_ &= ~0x00000004;
      if (getter != null) {
        getter.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGetter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public JvmMethodSignature getGetter() {
      initGetter();
      return getter;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public JvmMethodSignature getMutableGetter() {
      initGetter();
      bitField0_ |= 0x00000004;
      return getter;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     * @param value the getter to set
     * @return this
     */
    public JvmPropertySignature setGetter(final JvmMethodSignature value) {
      initGetter();
      bitField0_ |= 0x00000004;
      getter.copyFrom(value);
      return this;
    }

    private void initSetter() {
      if (setter == null) {
        setter = JvmMethodSignature.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     * @return whether the setter field is set
     */
    public boolean hasSetter() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     * @return this
     */
    public JvmPropertySignature clearSetter() {
      bitField0_ &= ~0x00000008;
      if (setter != null) {
        setter.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSetter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public JvmMethodSignature getSetter() {
      initSetter();
      return setter;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public JvmMethodSignature getMutableSetter() {
      initSetter();
      bitField0_ |= 0x00000008;
      return setter;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     * @param value the setter to set
     * @return this
     */
    public JvmPropertySignature setSetter(final JvmMethodSignature value) {
      initSetter();
      bitField0_ |= 0x00000008;
      setter.copyFrom(value);
      return this;
    }

    private void initDelegateMethod() {
      if (delegateMethod == null) {
        delegateMethod = JvmMethodSignature.newInstance();
      }
    }

    /**
     * <pre>
     *  The delegate field of delegated properties may be optimized out; `getDelegate` should
     *  then call this method instead
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     * @return whether the delegateMethod field is set
     */
    public boolean hasDelegateMethod() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <pre>
     *  The delegate field of delegated properties may be optimized out; `getDelegate` should
     *  then call this method instead
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     * @return this
     */
    public JvmPropertySignature clearDelegateMethod() {
      bitField0_ &= ~0x00000010;
      if (delegateMethod != null) {
        delegateMethod.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  The delegate field of delegated properties may be optimized out; `getDelegate` should
     *  then call this method instead
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDelegateMethod()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public JvmMethodSignature getDelegateMethod() {
      initDelegateMethod();
      return delegateMethod;
    }

    /**
     * <pre>
     *  The delegate field of delegated properties may be optimized out; `getDelegate` should
     *  then call this method instead
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public JvmMethodSignature getMutableDelegateMethod() {
      initDelegateMethod();
      bitField0_ |= 0x00000010;
      return delegateMethod;
    }

    /**
     * <pre>
     *  The delegate field of delegated properties may be optimized out; `getDelegate` should
     *  then call this method instead
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     * @param value the delegateMethod to set
     * @return this
     */
    public JvmPropertySignature setDelegateMethod(final JvmMethodSignature value) {
      initDelegateMethod();
      bitField0_ |= 0x00000010;
      delegateMethod.copyFrom(value);
      return this;
    }

    @Override
    public JvmPropertySignature copyFrom(final JvmPropertySignature other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasField()) {
          initField();
          field.copyFrom(other.field);
        } else {
          clearField();
        }
        if (other.hasSyntheticMethod()) {
          initSyntheticMethod();
          syntheticMethod.copyFrom(other.syntheticMethod);
        } else {
          clearSyntheticMethod();
        }
        if (other.hasGetter()) {
          initGetter();
          getter.copyFrom(other.getter);
        } else {
          clearGetter();
        }
        if (other.hasSetter()) {
          initSetter();
          setter.copyFrom(other.setter);
        } else {
          clearSetter();
        }
        if (other.hasDelegateMethod()) {
          initDelegateMethod();
          delegateMethod.copyFrom(other.delegateMethod);
        } else {
          clearDelegateMethod();
        }
      }
      return this;
    }

    @Override
    public JvmPropertySignature mergeFrom(final JvmPropertySignature other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasField()) {
        getMutableField().mergeFrom(other.field);
      }
      if (other.hasSyntheticMethod()) {
        getMutableSyntheticMethod().mergeFrom(other.syntheticMethod);
      }
      if (other.hasGetter()) {
        getMutableGetter().mergeFrom(other.getter);
      }
      if (other.hasSetter()) {
        getMutableSetter().mergeFrom(other.setter);
      }
      if (other.hasDelegateMethod()) {
        getMutableDelegateMethod().mergeFrom(other.delegateMethod);
      }
      return this;
    }

    @Override
    public JvmPropertySignature clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (field != null) {
        field.clear();
      }
      if (syntheticMethod != null) {
        syntheticMethod.clear();
      }
      if (getter != null) {
        getter.clear();
      }
      if (setter != null) {
        setter.clear();
      }
      if (delegateMethod != null) {
        delegateMethod.clear();
      }
      return this;
    }

    @Override
    public JvmPropertySignature clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (field != null) {
        field.clearQuick();
      }
      if (syntheticMethod != null) {
        syntheticMethod.clearQuick();
      }
      if (getter != null) {
        getter.clearQuick();
      }
      if (setter != null) {
        setter.clearQuick();
      }
      if (delegateMethod != null) {
        delegateMethod.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof JvmPropertySignature)) {
        return false;
      }
      JvmPropertySignature other = (JvmPropertySignature) o;
      return bitField0_ == other.bitField0_
        && (!hasField() || field.equals(other.field))
        && (!hasSyntheticMethod() || syntheticMethod.equals(other.syntheticMethod))
        && (!hasGetter() || getter.equals(other.getter))
        && (!hasSetter() || setter.equals(other.setter))
        && (!hasDelegateMethod() || delegateMethod.equals(other.delegateMethod));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(field);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(syntheticMethod);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 26);
        output.writeMessageNoTag(getter);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 34);
        output.writeMessageNoTag(setter);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 42);
        output.writeMessageNoTag(delegateMethod);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(field);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(syntheticMethod);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(getter);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(setter);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(delegateMethod);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public JvmPropertySignature mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // field
            initField();
            input.readMessage(field);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // syntheticMethod
            initSyntheticMethod();
            input.readMessage(syntheticMethod);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // getter
            initGetter();
            input.readMessage(getter);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // setter
            initSetter();
            input.readMessage(setter);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // delegateMethod
            initDelegateMethod();
            input.readMessage(delegateMethod);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.field, field);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.syntheticMethod, syntheticMethod);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeMessage(FieldNames.getter, getter);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeMessage(FieldNames.setter, setter);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeMessage(FieldNames.delegateMethod, delegateMethod);
      }
      output.endObject();
    }

    @Override
    public JvmPropertySignature mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 97427706: {
            if (input.isAtField(FieldNames.field)) {
              if (!input.trySkipNullValue()) {
                initField();
                input.readMessage(field);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1096524666:
          case -621797605: {
            if (input.isAtField(FieldNames.syntheticMethod)) {
              if (!input.trySkipNullValue()) {
                initSyntheticMethod();
                input.readMessage(syntheticMethod);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1249318645: {
            if (input.isAtField(FieldNames.getter)) {
              if (!input.trySkipNullValue()) {
                initGetter();
                input.readMessage(getter);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -905768833: {
            if (input.isAtField(FieldNames.setter)) {
              if (!input.trySkipNullValue()) {
                initSetter();
                input.readMessage(setter);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1124311750:
          case -495345445: {
            if (input.isAtField(FieldNames.delegateMethod)) {
              if (!input.trySkipNullValue()) {
                initDelegateMethod();
                input.readMessage(delegateMethod);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public JvmPropertySignature clone() {
      return new JvmPropertySignature().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static JvmPropertySignature parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new JvmPropertySignature(), data).checkInitialized();
    }

    public static JvmPropertySignature parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new JvmPropertySignature(), input).checkInitialized();
    }

    public static JvmPropertySignature parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new JvmPropertySignature(), input).checkInitialized();
    }

    /**
     * @return factory for creating JvmPropertySignature messages
     */
    public static MessageFactory<JvmPropertySignature> getFactory() {
      return JvmPropertySignatureFactory.INSTANCE;
    }

    private enum JvmPropertySignatureFactory implements MessageFactory<JvmPropertySignature> {
      INSTANCE;

      @Override
      public JvmPropertySignature create() {
        return JvmPropertySignature.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName field = FieldName.forField("field");

      static final FieldName syntheticMethod = FieldName.forField("syntheticMethod", "synthetic_method");

      static final FieldName getter = FieldName.forField("getter");

      static final FieldName setter = FieldName.forField("setter");

      static final FieldName delegateMethod = FieldName.forField("delegateMethod", "delegate_method");
    }
  }
}
