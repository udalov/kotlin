// Code generated by protocol buffer compiler. Do not edit!
package org.jetbrains.kotlin.metadata;

import java.io.IOException;
import java.util.List;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoEnum;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.RepeatedInt;
import us.hebi.quickbuf.RepeatedMessage;
import us.hebi.quickbuf.RepeatedString;
import us.hebi.quickbuf.UninitializedMessageException;

public final class QuickProtoBuf {
  /**
   * Protobuf enum {@code Modality}
   */
  public enum Modality implements ProtoEnum<Modality> {
    /**
     * <pre>
     *  2 bits
     * </pre>
     *
     * <code>FINAL = 0;</code>
     */
    FINAL("FINAL", 0),

    /**
     * <code>OPEN = 1;</code>
     */
    OPEN("OPEN", 1),

    /**
     * <code>ABSTRACT = 2;</code>
     */
    ABSTRACT("ABSTRACT", 2),

    /**
     * <code>SEALED = 3;</code>
     */
    SEALED("SEALED", 3);

    /**
     * <pre>
     *  2 bits
     * </pre>
     *
     * <code>FINAL = 0;</code>
     */
    public static final int FINAL_VALUE = 0;

    /**
     * <code>OPEN = 1;</code>
     */
    public static final int OPEN_VALUE = 1;

    /**
     * <code>ABSTRACT = 2;</code>
     */
    public static final int ABSTRACT_VALUE = 2;

    /**
     * <code>SEALED = 3;</code>
     */
    public static final int SEALED_VALUE = 3;

    private final String name;

    private final int number;

    private Modality(String name, int number) {
      this.name = name;
      this.number = number;
    }

    /**
     * @return the string representation of enum entry
     */
    @Override
    public String getName() {
      return name;
    }

    /**
     * @return the numeric wire value of this enum entry
     */
    @Override
    public int getNumber() {
      return number;
    }

    /**
     * @return a converter that maps between this enum's numeric and text representations
     */
    public static ProtoEnum.EnumConverter<Modality> converter() {
      return ModalityConverter.INSTANCE;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value, or null if unknown.
     */
    public static Modality forNumber(int value) {
      return ModalityConverter.INSTANCE.forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @param other Fallback value in case the value is not known.
     * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
     */
    public static Modality forNumberOr(int number, Modality other) {
      Modality value = forNumber(number);
      return value == null ? other : value;
    }

    enum ModalityConverter implements ProtoEnum.EnumConverter<Modality> {
      INSTANCE;

      private static final Modality[] lookup = new Modality[4];

      static {
        lookup[0] = FINAL;
        lookup[1] = OPEN;
        lookup[2] = ABSTRACT;
        lookup[3] = SEALED;
      }

      @Override
      public final Modality forNumber(final int value) {
        if (value >= 0 && value < lookup.length) {
          return lookup[value];
        }
        return null;
      }

      @Override
      public final Modality forName(final CharSequence value) {
        switch (value.length()) {
          case 4: {
            if (ProtoUtil.isEqual("OPEN", value)) {
              return OPEN;
            }
            break;
          }
          case 5: {
            if (ProtoUtil.isEqual("FINAL", value)) {
              return FINAL;
            }
            break;
          }
          case 6: {
            if (ProtoUtil.isEqual("SEALED", value)) {
              return SEALED;
            }
            break;
          }
          case 8: {
            if (ProtoUtil.isEqual("ABSTRACT", value)) {
              return ABSTRACT;
            }
            break;
          }
        }
        return null;
      }
    }
  }

  /**
   * Protobuf enum {@code Visibility}
   */
  public enum Visibility implements ProtoEnum<Visibility> {
    /**
     * <pre>
     *  3 bits
     * </pre>
     *
     * <code>INTERNAL = 0;</code>
     */
    INTERNAL("INTERNAL", 0),

    /**
     * <code>PRIVATE = 1;</code>
     */
    PRIVATE("PRIVATE", 1),

    /**
     * <code>PROTECTED = 2;</code>
     */
    PROTECTED("PROTECTED", 2),

    /**
     * <code>PUBLIC = 3;</code>
     */
    PUBLIC("PUBLIC", 3),

    /**
     * <code>PRIVATE_TO_THIS = 4;</code>
     */
    PRIVATE_TO_THIS("PRIVATE_TO_THIS", 4),

    /**
     * <code>LOCAL = 5;</code>
     */
    LOCAL("LOCAL", 5);

    /**
     * <pre>
     *  3 bits
     * </pre>
     *
     * <code>INTERNAL = 0;</code>
     */
    public static final int INTERNAL_VALUE = 0;

    /**
     * <code>PRIVATE = 1;</code>
     */
    public static final int PRIVATE_VALUE = 1;

    /**
     * <code>PROTECTED = 2;</code>
     */
    public static final int PROTECTED_VALUE = 2;

    /**
     * <code>PUBLIC = 3;</code>
     */
    public static final int PUBLIC_VALUE = 3;

    /**
     * <code>PRIVATE_TO_THIS = 4;</code>
     */
    public static final int PRIVATE_TO_THIS_VALUE = 4;

    /**
     * <code>LOCAL = 5;</code>
     */
    public static final int LOCAL_VALUE = 5;

    private final String name;

    private final int number;

    private Visibility(String name, int number) {
      this.name = name;
      this.number = number;
    }

    /**
     * @return the string representation of enum entry
     */
    @Override
    public String getName() {
      return name;
    }

    /**
     * @return the numeric wire value of this enum entry
     */
    @Override
    public int getNumber() {
      return number;
    }

    /**
     * @return a converter that maps between this enum's numeric and text representations
     */
    public static ProtoEnum.EnumConverter<Visibility> converter() {
      return VisibilityConverter.INSTANCE;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value, or null if unknown.
     */
    public static Visibility forNumber(int value) {
      return VisibilityConverter.INSTANCE.forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @param other Fallback value in case the value is not known.
     * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
     */
    public static Visibility forNumberOr(int number, Visibility other) {
      Visibility value = forNumber(number);
      return value == null ? other : value;
    }

    enum VisibilityConverter implements ProtoEnum.EnumConverter<Visibility> {
      INSTANCE;

      private static final Visibility[] lookup = new Visibility[6];

      static {
        lookup[0] = INTERNAL;
        lookup[1] = PRIVATE;
        lookup[2] = PROTECTED;
        lookup[3] = PUBLIC;
        lookup[4] = PRIVATE_TO_THIS;
        lookup[5] = LOCAL;
      }

      @Override
      public final Visibility forNumber(final int value) {
        if (value >= 0 && value < lookup.length) {
          return lookup[value];
        }
        return null;
      }

      @Override
      public final Visibility forName(final CharSequence value) {
        switch (value.length()) {
          case 5: {
            if (ProtoUtil.isEqual("LOCAL", value)) {
              return LOCAL;
            }
            break;
          }
          case 6: {
            if (ProtoUtil.isEqual("PUBLIC", value)) {
              return PUBLIC;
            }
            break;
          }
          case 7: {
            if (ProtoUtil.isEqual("PRIVATE", value)) {
              return PRIVATE;
            }
            break;
          }
          case 8: {
            if (ProtoUtil.isEqual("INTERNAL", value)) {
              return INTERNAL;
            }
            break;
          }
          case 9: {
            if (ProtoUtil.isEqual("PROTECTED", value)) {
              return PROTECTED;
            }
            break;
          }
          case 15: {
            if (ProtoUtil.isEqual("PRIVATE_TO_THIS", value)) {
              return PRIVATE_TO_THIS;
            }
            break;
          }
        }
        return null;
      }
    }
  }

  /**
   * Protobuf enum {@code MemberKind}
   */
  public enum MemberKind implements ProtoEnum<MemberKind> {
    /**
     * <pre>
     *  2 bits
     * </pre>
     *
     * <code>DECLARATION = 0;</code>
     */
    DECLARATION("DECLARATION", 0),

    /**
     * <code>FAKE_OVERRIDE = 1;</code>
     */
    FAKE_OVERRIDE("FAKE_OVERRIDE", 1),

    /**
     * <code>DELEGATION = 2;</code>
     */
    DELEGATION("DELEGATION", 2),

    /**
     * <code>SYNTHESIZED = 3;</code>
     */
    SYNTHESIZED("SYNTHESIZED", 3);

    /**
     * <pre>
     *  2 bits
     * </pre>
     *
     * <code>DECLARATION = 0;</code>
     */
    public static final int DECLARATION_VALUE = 0;

    /**
     * <code>FAKE_OVERRIDE = 1;</code>
     */
    public static final int FAKE_OVERRIDE_VALUE = 1;

    /**
     * <code>DELEGATION = 2;</code>
     */
    public static final int DELEGATION_VALUE = 2;

    /**
     * <code>SYNTHESIZED = 3;</code>
     */
    public static final int SYNTHESIZED_VALUE = 3;

    private final String name;

    private final int number;

    private MemberKind(String name, int number) {
      this.name = name;
      this.number = number;
    }

    /**
     * @return the string representation of enum entry
     */
    @Override
    public String getName() {
      return name;
    }

    /**
     * @return the numeric wire value of this enum entry
     */
    @Override
    public int getNumber() {
      return number;
    }

    /**
     * @return a converter that maps between this enum's numeric and text representations
     */
    public static ProtoEnum.EnumConverter<MemberKind> converter() {
      return MemberKindConverter.INSTANCE;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value, or null if unknown.
     */
    public static MemberKind forNumber(int value) {
      return MemberKindConverter.INSTANCE.forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @param other Fallback value in case the value is not known.
     * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
     */
    public static MemberKind forNumberOr(int number, MemberKind other) {
      MemberKind value = forNumber(number);
      return value == null ? other : value;
    }

    enum MemberKindConverter implements ProtoEnum.EnumConverter<MemberKind> {
      INSTANCE;

      private static final MemberKind[] lookup = new MemberKind[4];

      static {
        lookup[0] = DECLARATION;
        lookup[1] = FAKE_OVERRIDE;
        lookup[2] = DELEGATION;
        lookup[3] = SYNTHESIZED;
      }

      @Override
      public final MemberKind forNumber(final int value) {
        if (value >= 0 && value < lookup.length) {
          return lookup[value];
        }
        return null;
      }

      @Override
      public final MemberKind forName(final CharSequence value) {
        if (value.length() == 10) {
          if (ProtoUtil.isEqual("DELEGATION", value)) {
            return DELEGATION;
          }
        }
        if (value.length() == 11) {
          if (ProtoUtil.isEqual("DECLARATION", value)) {
            return DECLARATION;
          }
          if (ProtoUtil.isEqual("SYNTHESIZED", value)) {
            return SYNTHESIZED;
          }
        }
        if (value.length() == 13) {
          if (ProtoUtil.isEqual("FAKE_OVERRIDE", value)) {
            return FAKE_OVERRIDE;
          }
        }
        return null;
      }
    }
  }

  /**
   * Protobuf enum {@code ReturnValueStatus}
   */
  public enum ReturnValueStatus implements ProtoEnum<ReturnValueStatus> {
    /**
     * <code>UNSPECIFIED = 0;</code>
     */
    UNSPECIFIED("UNSPECIFIED", 0),

    /**
     * <code>MUST_USE = 1;</code>
     */
    MUST_USE("MUST_USE", 1),

    /**
     * <pre>
     *
     * 3 represents @MustUse AND @Ignorable state, which is semantically incorrect.
     * We can reserve this state for future potential extensions.
     * </pre>
     *
     * <code>EXPLICITLY_IGNORABLE = 2;</code>
     */
    EXPLICITLY_IGNORABLE("EXPLICITLY_IGNORABLE", 2);

    /**
     * <code>UNSPECIFIED = 0;</code>
     */
    public static final int UNSPECIFIED_VALUE = 0;

    /**
     * <code>MUST_USE = 1;</code>
     */
    public static final int MUST_USE_VALUE = 1;

    /**
     * <pre>
     *
     * 3 represents @MustUse AND @Ignorable state, which is semantically incorrect.
     * We can reserve this state for future potential extensions.
     * </pre>
     *
     * <code>EXPLICITLY_IGNORABLE = 2;</code>
     */
    public static final int EXPLICITLY_IGNORABLE_VALUE = 2;

    private final String name;

    private final int number;

    private ReturnValueStatus(String name, int number) {
      this.name = name;
      this.number = number;
    }

    /**
     * @return the string representation of enum entry
     */
    @Override
    public String getName() {
      return name;
    }

    /**
     * @return the numeric wire value of this enum entry
     */
    @Override
    public int getNumber() {
      return number;
    }

    /**
     * @return a converter that maps between this enum's numeric and text representations
     */
    public static ProtoEnum.EnumConverter<ReturnValueStatus> converter() {
      return ReturnValueStatusConverter.INSTANCE;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value, or null if unknown.
     */
    public static ReturnValueStatus forNumber(int value) {
      return ReturnValueStatusConverter.INSTANCE.forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @param other Fallback value in case the value is not known.
     * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
     */
    public static ReturnValueStatus forNumberOr(int number, ReturnValueStatus other) {
      ReturnValueStatus value = forNumber(number);
      return value == null ? other : value;
    }

    enum ReturnValueStatusConverter implements ProtoEnum.EnumConverter<ReturnValueStatus> {
      INSTANCE;

      private static final ReturnValueStatus[] lookup = new ReturnValueStatus[3];

      static {
        lookup[0] = UNSPECIFIED;
        lookup[1] = MUST_USE;
        lookup[2] = EXPLICITLY_IGNORABLE;
      }

      @Override
      public final ReturnValueStatus forNumber(final int value) {
        if (value >= 0 && value < lookup.length) {
          return lookup[value];
        }
        return null;
      }

      @Override
      public final ReturnValueStatus forName(final CharSequence value) {
        if (value.length() == 8) {
          if (ProtoUtil.isEqual("MUST_USE", value)) {
            return MUST_USE;
          }
        }
        if (value.length() == 11) {
          if (ProtoUtil.isEqual("UNSPECIFIED", value)) {
            return UNSPECIFIED;
          }
        }
        if (value.length() == 20) {
          if (ProtoUtil.isEqual("EXPLICITLY_IGNORABLE", value)) {
            return EXPLICITLY_IGNORABLE;
          }
        }
        return null;
      }
    }
  }

  /**
   * Protobuf type {@code StringTable}
   */
  public static final class StringTable extends ProtoMessage<StringTable> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>repeated string string = 1;</code>
     */
    private RepeatedString string = null;

    private StringTable() {
    }

    /**
     * @return a new empty instance of {@code StringTable}
     */
    public static StringTable newInstance() {
      return new StringTable();
    }

    private void initString() {
      if (string == null) {
        string = RepeatedString.newEmptyInstance();
      }
    }

    /**
     * <code>repeated string string = 1;</code>
     * @return whether the string field is set
     */
    public boolean hasString() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>repeated string string = 1;</code>
     * @return this
     */
    public StringTable clearString() {
      bitField0_ &= ~0x00000001;
      if (string != null) {
        string.clear();
      }
      return this;
    }

    /**
     * <code>repeated string string = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableString()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedString getString() {
      initString();
      return string;
    }

    /**
     * <code>repeated string string = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedString getMutableString() {
      initString();
      bitField0_ |= 0x00000001;
      return string;
    }

    /**
     * <code>repeated string string = 1;</code>
     * @param value the string to add
     * @return this
     */
    public StringTable addString(final CharSequence value) {
      initString();
      bitField0_ |= 0x00000001;
      string.add(value);
      return this;
    }

    /**
     * <code>repeated string string = 1;</code>
     * @param values the string to add
     * @return this
     */
    public StringTable addAllString(final CharSequence... values) {
      initString();
      bitField0_ |= 0x00000001;
      string.addAll(values);
      return this;
    }

    @Override
    public StringTable copyFrom(final StringTable other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasString()) {
          initString();
          string.copyFrom(other.string);
        } else {
          clearString();
        }
      }
      return this;
    }

    @Override
    public StringTable mergeFrom(final StringTable other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasString()) {
        getMutableString().addAll(other.string);
      }
      return this;
    }

    @Override
    public StringTable clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (string != null) {
        string.clear();
      }
      return this;
    }

    @Override
    public StringTable clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (string != null) {
        string.clear();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StringTable)) {
        return false;
      }
      StringTable other = (StringTable) o;
      return bitField0_ == other.bitField0_
        && (!hasString() || string.equals(other.string));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        for (int i = 0; i < string.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeStringNoTag(string.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += (1 * string.length()) + ProtoSink.computeRepeatedStringSizeNoTag(string);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StringTable mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // string
            initString();
            tag = input.readRepeatedString(string, tag);
            bitField0_ |= 0x00000001;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRepeatedString(FieldNames.string, string);
      }
      output.endObject();
    }

    @Override
    public StringTable mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -891985903: {
            if (input.isAtField(FieldNames.string)) {
              if (!input.trySkipNullValue()) {
                initString();
                input.readRepeatedString(string);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StringTable clone() {
      return new StringTable().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StringTable parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StringTable(), data).checkInitialized();
    }

    public static StringTable parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StringTable(), input).checkInitialized();
    }

    public static StringTable parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StringTable(), input).checkInitialized();
    }

    /**
     * @return factory for creating StringTable messages
     */
    public static MessageFactory<StringTable> getFactory() {
      return StringTableFactory.INSTANCE;
    }

    private enum StringTableFactory implements MessageFactory<StringTable> {
      INSTANCE;

      @Override
      public StringTable create() {
        return StringTable.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName string = FieldName.forField("string");
    }
  }

  /**
   * Protobuf type {@code QualifiedNameTable}
   */
  public static final class QualifiedNameTable extends ProtoMessage<QualifiedNameTable> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName qualified_name = 1;</code>
     */
    private RepeatedMessage<QualifiedName> qualifiedName = null;

    private QualifiedNameTable() {
    }

    /**
     * @return a new empty instance of {@code QualifiedNameTable}
     */
    public static QualifiedNameTable newInstance() {
      return new QualifiedNameTable();
    }

    private void initQualifiedName() {
      if (qualifiedName == null) {
        qualifiedName = RepeatedMessage.newEmptyInstance(QualifiedName.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName qualified_name = 1;</code>
     * @return whether the qualifiedName field is set
     */
    public boolean hasQualifiedName() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName qualified_name = 1;</code>
     * @return this
     */
    public QualifiedNameTable clearQualifiedName() {
      bitField0_ &= ~0x00000001;
      if (qualifiedName != null) {
        qualifiedName.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName qualified_name = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQualifiedName()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<QualifiedName> getQualifiedName() {
      initQualifiedName();
      return qualifiedName;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName qualified_name = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<QualifiedName> getMutableQualifiedName() {
      initQualifiedName();
      bitField0_ |= 0x00000001;
      return qualifiedName;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName qualified_name = 1;</code>
     * @param value the qualifiedName to add
     * @return this
     */
    public QualifiedNameTable addQualifiedName(final QualifiedName value) {
      initQualifiedName();
      bitField0_ |= 0x00000001;
      qualifiedName.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName qualified_name = 1;</code>
     * @param values the qualifiedName to add
     * @return this
     */
    public QualifiedNameTable addAllQualifiedName(final QualifiedName... values) {
      initQualifiedName();
      bitField0_ |= 0x00000001;
      qualifiedName.addAll(values);
      return this;
    }

    @Override
    public QualifiedNameTable copyFrom(final QualifiedNameTable other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasQualifiedName()) {
          initQualifiedName();
          qualifiedName.copyFrom(other.qualifiedName);
        } else {
          clearQualifiedName();
        }
      }
      return this;
    }

    @Override
    public QualifiedNameTable mergeFrom(final QualifiedNameTable other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasQualifiedName()) {
        getMutableQualifiedName().addAll(other.qualifiedName);
      }
      return this;
    }

    @Override
    public QualifiedNameTable clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (qualifiedName != null) {
        qualifiedName.clear();
      }
      return this;
    }

    @Override
    public QualifiedNameTable clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (qualifiedName != null) {
        qualifiedName.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof QualifiedNameTable)) {
        return false;
      }
      QualifiedNameTable other = (QualifiedNameTable) o;
      return bitField0_ == other.bitField0_
        && (!hasQualifiedName() || qualifiedName.equals(other.qualifiedName));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      try {
        if ((bitField0_ & 0x00000001) != 0) {
          for (int i = 0; i < qualifiedName.length(); i++) {
            output.writeRawByte((byte) 10);
            output.writeMessageNoTag(qualifiedName.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      try {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += (1 * qualifiedName.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(qualifiedName);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public QualifiedNameTable mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // qualifiedName
            initQualifiedName();
            tag = input.readRepeatedMessage(qualifiedName, tag);
            bitField0_ |= 0x00000001;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if (hasQualifiedName() && !qualifiedName.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (hasQualifiedName() && !qualifiedName.isInitialized()) {
        getMissingFields(prefix, "qualified_name", qualifiedName, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRepeatedMessage(FieldNames.qualifiedName, qualifiedName);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public QualifiedNameTable mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -572444345:
          case -549829554: {
            if (input.isAtField(FieldNames.qualifiedName)) {
              if (!input.trySkipNullValue()) {
                initQualifiedName();
                input.readRepeatedMessage(qualifiedName);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public QualifiedNameTable clone() {
      return new QualifiedNameTable().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static QualifiedNameTable parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new QualifiedNameTable(), data).checkInitialized();
    }

    public static QualifiedNameTable parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new QualifiedNameTable(), input).checkInitialized();
    }

    public static QualifiedNameTable parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new QualifiedNameTable(), input).checkInitialized();
    }

    /**
     * @return factory for creating QualifiedNameTable messages
     */
    public static MessageFactory<QualifiedNameTable> getFactory() {
      return QualifiedNameTableFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code QualifiedName}
     */
    public static final class QualifiedName extends ProtoMessage<QualifiedName> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional int32 parent_qualified_name = 1 [default = -1];</code>
       */
      private int parentQualifiedName = -1;

      /**
       * <pre>
       *  id in the StringTable
       * </pre>
       *
       * <code>required int32 short_name = 2;</code>
       */
      private int shortName;

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName.Kind kind = 3 [default = PACKAGE];</code>
       */
      private int kind = org.jetbrains.kotlin.metadata.QuickProtoBuf.QualifiedNameTable.QualifiedName.Kind.PACKAGE_VALUE;

      private QualifiedName() {
      }

      /**
       * @return a new empty instance of {@code QualifiedName}
       */
      public static QualifiedName newInstance() {
        return new QualifiedName();
      }

      /**
       * <code>optional int32 parent_qualified_name = 1 [default = -1];</code>
       * @return whether the parentQualifiedName field is set
       */
      public boolean hasParentQualifiedName() {
        return (bitField0_ & 0x00000004) != 0;
      }

      /**
       * <code>optional int32 parent_qualified_name = 1 [default = -1];</code>
       * @return this
       */
      public QualifiedName clearParentQualifiedName() {
        bitField0_ &= ~0x00000004;
        parentQualifiedName = -1;
        return this;
      }

      /**
       * <code>optional int32 parent_qualified_name = 1 [default = -1];</code>
       * @return the parentQualifiedName
       */
      public int getParentQualifiedName() {
        return parentQualifiedName;
      }

      /**
       * <code>optional int32 parent_qualified_name = 1 [default = -1];</code>
       * @param value the parentQualifiedName to set
       * @return this
       */
      public QualifiedName setParentQualifiedName(final int value) {
        bitField0_ |= 0x00000004;
        parentQualifiedName = value;
        return this;
      }

      /**
       * <pre>
       *  id in the StringTable
       * </pre>
       *
       * <code>required int32 short_name = 2;</code>
       * @return whether the shortName field is set
       */
      public boolean hasShortName() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <pre>
       *  id in the StringTable
       * </pre>
       *
       * <code>required int32 short_name = 2;</code>
       * @return this
       */
      public QualifiedName clearShortName() {
        bitField0_ &= ~0x00000002;
        shortName = 0;
        return this;
      }

      /**
       * <pre>
       *  id in the StringTable
       * </pre>
       *
       * <code>required int32 short_name = 2;</code>
       * @return the shortName
       */
      public int getShortName() {
        return shortName;
      }

      /**
       * <pre>
       *  id in the StringTable
       * </pre>
       *
       * <code>required int32 short_name = 2;</code>
       * @param value the shortName to set
       * @return this
       */
      public QualifiedName setShortName(final int value) {
        bitField0_ |= 0x00000002;
        shortName = value;
        return this;
      }

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName.Kind kind = 3 [default = PACKAGE];</code>
       * @return whether the kind field is set
       */
      public boolean hasKind() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName.Kind kind = 3 [default = PACKAGE];</code>
       * @return this
       */
      public QualifiedName clearKind() {
        bitField0_ &= ~0x00000001;
        kind = org.jetbrains.kotlin.metadata.QuickProtoBuf.QualifiedNameTable.QualifiedName.Kind.PACKAGE_VALUE;
        return this;
      }

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName.Kind kind = 3 [default = PACKAGE];</code>
       * @return the kind
       */
      public Kind getKind() {
        return Kind.forNumberOr(kind, org.jetbrains.kotlin.metadata.QuickProtoBuf.QualifiedNameTable.QualifiedName.Kind.PACKAGE);
      }

      /**
       * Gets the value of the internal enum store. The result is
       * equivalent to {@link QualifiedName#getKind()}.getNumber().
       *
       * @return numeric wire representation
       */
      public int getKindValue() {
        return kind;
      }

      /**
       * Sets the value of the internal enum store. This does not
       * do any validity checks, so be sure to use appropriate value
       * constants from {@link Kind}. Setting an invalid value
       * can cause {@link QualifiedName#getKind()} to return null
       *
       * @param value the numeric wire value to set
       * @return this
       */
      public QualifiedName setKindValue(final int value) {
        bitField0_ |= 0x00000001;
        kind = value;
        return this;
      }

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable.QualifiedName.Kind kind = 3 [default = PACKAGE];</code>
       * @param value the kind to set
       * @return this
       */
      public QualifiedName setKind(final Kind value) {
        bitField0_ |= 0x00000001;
        kind = value.getNumber();
        return this;
      }

      @Override
      public QualifiedName copyFrom(final QualifiedName other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          parentQualifiedName = other.parentQualifiedName;
          shortName = other.shortName;
          kind = other.kind;
        }
        return this;
      }

      @Override
      public QualifiedName mergeFrom(final QualifiedName other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasParentQualifiedName()) {
          setParentQualifiedName(other.parentQualifiedName);
        }
        if (other.hasShortName()) {
          setShortName(other.shortName);
        }
        if (other.hasKind()) {
          setKindValue(other.kind);
        }
        return this;
      }

      @Override
      public QualifiedName clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        parentQualifiedName = -1;
        shortName = 0;
        kind = org.jetbrains.kotlin.metadata.QuickProtoBuf.QualifiedNameTable.QualifiedName.Kind.PACKAGE_VALUE;
        return this;
      }

      @Override
      public QualifiedName clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof QualifiedName)) {
          return false;
        }
        QualifiedName other = (QualifiedName) o;
        return bitField0_ == other.bitField0_
          && (!hasParentQualifiedName() || parentQualifiedName == other.parentQualifiedName)
          && (!hasShortName() || shortName == other.shortName)
          && (!hasKind() || kind == other.kind);
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((((bitField0_ & 0x00000002) != 0x00000002))) {
          throw new UninitializedMessageException(this);
        }
        try {
          if ((bitField0_ & 0x00000004) != 0) {
            output.writeRawByte((byte) 8);
            output.writeInt32NoTag(parentQualifiedName);
          }
          output.writeRawByte((byte) 16);
          output.writeInt32NoTag(shortName);
          if ((bitField0_ & 0x00000001) != 0) {
            output.writeRawByte((byte) 24);
            output.writeEnumNoTag(kind);
          }
        } catch (UninitializedMessageException nestedFail) {
          throw rethrowFromParent(nestedFail);
        }
      }

      @Override
      protected int computeSerializedSize() {
        if ((((bitField0_ & 0x00000002) != 0x00000002))) {
          throw new UninitializedMessageException(this);
        }
        try {
          int size = 0;
          if ((bitField0_ & 0x00000004) != 0) {
            size += 1 + ProtoSink.computeInt32SizeNoTag(parentQualifiedName);
          }
          size += 1 + ProtoSink.computeInt32SizeNoTag(shortName);
          if ((bitField0_ & 0x00000001) != 0) {
            size += 1 + ProtoSink.computeEnumSizeNoTag(kind);
          }
          return size;
        } catch (UninitializedMessageException nestedFail) {
          throw rethrowFromParent(nestedFail);
        }
      }

      @Override
      @SuppressWarnings("fallthrough")
      public QualifiedName mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 8: {
              // parentQualifiedName
              parentQualifiedName = input.readInt32();
              bitField0_ |= 0x00000004;
              tag = input.readTag();
              if (tag != 16) {
                break;
              }
            }
            case 16: {
              // shortName
              shortName = input.readInt32();
              bitField0_ |= 0x00000002;
              tag = input.readTag();
              if (tag != 24) {
                break;
              }
            }
            case 24: {
              // kind
              final int value = input.readInt32();
              if (Kind.forNumber(value) != null) {
                kind = value;
                bitField0_ |= 0x00000001;
              }
              tag = input.readTag();
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public final boolean isInitialized() {
        if ((((bitField0_ & 0x00000002) != 0x00000002))) {
          return false;
        }
        return true;
      }

      @Override
      protected final void getMissingFields(String prefix, List<String> results) {
        if (!hasShortName()) {
          results.add(prefix + "short_name");
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        if ((((bitField0_ & 0x00000002) != 0x00000002))) {
          throw new UninitializedMessageException(this);
        }
        try {
          output.beginObject();
          if ((bitField0_ & 0x00000004) != 0) {
            output.writeInt32(FieldNames.parentQualifiedName, parentQualifiedName);
          }
          output.writeInt32(FieldNames.shortName, shortName);
          if ((bitField0_ & 0x00000001) != 0) {
            output.writeEnum(FieldNames.kind, kind, Kind.converter());
          }
          output.endObject();
        } catch (UninitializedMessageException nestedFail) {
          throw rethrowFromParent(nestedFail);
        }
      }

      @Override
      public QualifiedName mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case 1649032381:
            case -2123890557: {
              if (input.isAtField(FieldNames.parentQualifiedName)) {
                if (!input.trySkipNullValue()) {
                  parentQualifiedName = input.readInt32();
                  bitField0_ |= 0x00000004;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -2028219097:
            case 1565793390: {
              if (input.isAtField(FieldNames.shortName)) {
                if (!input.trySkipNullValue()) {
                  shortName = input.readInt32();
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 3292052: {
              if (input.isAtField(FieldNames.kind)) {
                if (!input.trySkipNullValue()) {
                  final Kind value = input.readEnum(Kind.converter());
                  if (value != null) {
                    kind = value.getNumber();
                    bitField0_ |= 0x00000001;
                  } else {
                    input.skipUnknownEnumValue();
                  }
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public QualifiedName clone() {
        return new QualifiedName().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static QualifiedName parseFrom(final byte[] data) throws
          InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new QualifiedName(), data).checkInitialized();
      }

      public static QualifiedName parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new QualifiedName(), input).checkInitialized();
      }

      public static QualifiedName parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new QualifiedName(), input).checkInitialized();
      }

      /**
       * @return factory for creating QualifiedName messages
       */
      public static MessageFactory<QualifiedName> getFactory() {
        return QualifiedNameFactory.INSTANCE;
      }

      /**
       * Protobuf enum {@code Kind}
       */
      public enum Kind implements ProtoEnum<Kind> {
        /**
         * <code>CLASS = 0;</code>
         */
        CLASS("CLASS", 0),

        /**
         * <code>PACKAGE = 1;</code>
         */
        PACKAGE("PACKAGE", 1),

        /**
         * <code>LOCAL = 2;</code>
         */
        LOCAL("LOCAL", 2);

        /**
         * <code>CLASS = 0;</code>
         */
        public static final int CLASS_VALUE = 0;

        /**
         * <code>PACKAGE = 1;</code>
         */
        public static final int PACKAGE_VALUE = 1;

        /**
         * <code>LOCAL = 2;</code>
         */
        public static final int LOCAL_VALUE = 2;

        private final String name;

        private final int number;

        private Kind(String name, int number) {
          this.name = name;
          this.number = number;
        }

        /**
         * @return the string representation of enum entry
         */
        @Override
        public String getName() {
          return name;
        }

        /**
         * @return the numeric wire value of this enum entry
         */
        @Override
        public int getNumber() {
          return number;
        }

        /**
         * @return a converter that maps between this enum's numeric and text representations
         */
        public static ProtoEnum.EnumConverter<Kind> converter() {
          return KindConverter.INSTANCE;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value, or null if unknown.
         */
        public static Kind forNumber(int value) {
          return KindConverter.INSTANCE.forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @param other Fallback value in case the value is not known.
         * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
         */
        public static Kind forNumberOr(int number, Kind other) {
          Kind value = forNumber(number);
          return value == null ? other : value;
        }

        enum KindConverter implements ProtoEnum.EnumConverter<Kind> {
          INSTANCE;

          private static final Kind[] lookup = new Kind[3];

          static {
            lookup[0] = CLASS;
            lookup[1] = PACKAGE;
            lookup[2] = LOCAL;
          }

          @Override
          public final Kind forNumber(final int value) {
            if (value >= 0 && value < lookup.length) {
              return lookup[value];
            }
            return null;
          }

          @Override
          public final Kind forName(final CharSequence value) {
            if (value.length() == 5) {
              if (ProtoUtil.isEqual("CLASS", value)) {
                return CLASS;
              }
              if (ProtoUtil.isEqual("LOCAL", value)) {
                return LOCAL;
              }
            }
            if (value.length() == 7) {
              if (ProtoUtil.isEqual("PACKAGE", value)) {
                return PACKAGE;
              }
            }
            return null;
          }
        }
      }

      private enum QualifiedNameFactory implements MessageFactory<QualifiedName> {
        INSTANCE;

        @Override
        public QualifiedName create() {
          return QualifiedName.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName parentQualifiedName = FieldName.forField("parentQualifiedName", "parent_qualified_name");

        static final FieldName shortName = FieldName.forField("shortName", "short_name");

        static final FieldName kind = FieldName.forField("kind");
      }
    }

    private enum QualifiedNameTableFactory implements MessageFactory<QualifiedNameTable> {
      INSTANCE;

      @Override
      public QualifiedNameTable create() {
        return QualifiedNameTable.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName qualifiedName = FieldName.forField("qualifiedName", "qualified_name");
    }
  }

  /**
   * Protobuf type {@code Annotation}
   */
  public static final class Annotation extends ProtoMessage<Annotation> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>required int32 id = 1;</code>
     */
    private int id;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument argument = 2;</code>
     */
    private RepeatedMessage<Argument> argument = null;

    private Annotation() {
    }

    /**
     * @return a new empty instance of {@code Annotation}
     */
    public static Annotation newInstance() {
      return new Annotation();
    }

    /**
     * <code>required int32 id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>required int32 id = 1;</code>
     * @return this
     */
    public Annotation clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>required int32 id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>required int32 id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Annotation setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    private void initArgument() {
      if (argument == null) {
        argument = RepeatedMessage.newEmptyInstance(Argument.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument argument = 2;</code>
     * @return whether the argument field is set
     */
    public boolean hasArgument() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument argument = 2;</code>
     * @return this
     */
    public Annotation clearArgument() {
      bitField0_ &= ~0x00000001;
      if (argument != null) {
        argument.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument argument = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableArgument()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Argument> getArgument() {
      initArgument();
      return argument;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument argument = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Argument> getMutableArgument() {
      initArgument();
      bitField0_ |= 0x00000001;
      return argument;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument argument = 2;</code>
     * @param value the argument to add
     * @return this
     */
    public Annotation addArgument(final Argument value) {
      initArgument();
      bitField0_ |= 0x00000001;
      argument.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument argument = 2;</code>
     * @param values the argument to add
     * @return this
     */
    public Annotation addAllArgument(final Argument... values) {
      initArgument();
      bitField0_ |= 0x00000001;
      argument.addAll(values);
      return this;
    }

    @Override
    public Annotation copyFrom(final Annotation other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        if (other.hasArgument()) {
          initArgument();
          argument.copyFrom(other.argument);
        } else {
          clearArgument();
        }
      }
      return this;
    }

    @Override
    public Annotation mergeFrom(final Annotation other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasArgument()) {
        getMutableArgument().addAll(other.argument);
      }
      return this;
    }

    @Override
    public Annotation clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      if (argument != null) {
        argument.clear();
      }
      return this;
    }

    @Override
    public Annotation clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (argument != null) {
        argument.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Annotation)) {
        return false;
      }
      Annotation other = (Annotation) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasArgument() || argument.equals(other.argument));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000002) != 0x00000002))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(id);
        if ((bitField0_ & 0x00000001) != 0) {
          for (int i = 0; i < argument.length(); i++) {
            output.writeRawByte((byte) 18);
            output.writeMessageNoTag(argument.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000002) != 0x00000002))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        size += 1 + ProtoSink.computeInt32SizeNoTag(id);
        if ((bitField0_ & 0x00000001) != 0) {
          size += (1 * argument.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(argument);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Annotation mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // argument
            initArgument();
            tag = input.readRepeatedMessage(argument, tag);
            bitField0_ |= 0x00000001;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000002) != 0x00000002))) {
        return false;
      }
      if (hasArgument() && !argument.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasId()) {
        results.add(prefix + "id");
      }
      if (hasArgument() && !argument.isInitialized()) {
        getMissingFields(prefix, "argument", argument, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000002) != 0x00000002))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        output.writeInt32(FieldNames.id, id);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRepeatedMessage(FieldNames.argument, argument);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Annotation mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3355: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1589682499: {
            if (input.isAtField(FieldNames.argument)) {
              if (!input.trySkipNullValue()) {
                initArgument();
                input.readRepeatedMessage(argument);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Annotation clone() {
      return new Annotation().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Annotation parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Annotation(), data).checkInitialized();
    }

    public static Annotation parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Annotation(), input).checkInitialized();
    }

    public static Annotation parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Annotation(), input).checkInitialized();
    }

    /**
     * @return factory for creating Annotation messages
     */
    public static MessageFactory<Annotation> getFactory() {
      return AnnotationFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code Argument}
     */
    public static final class Argument extends ProtoMessage<Argument> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>required int32 name_id = 1;</code>
       */
      private int nameId;

      /**
       * <code>required .org.jetbrains.kotlin.metadata.Annotation.Argument.Value value = 2;</code>
       */
      private final Value value_ = Value.newInstance();

      private Argument() {
      }

      /**
       * @return a new empty instance of {@code Argument}
       */
      public static Argument newInstance() {
        return new Argument();
      }

      /**
       * <code>required int32 name_id = 1;</code>
       * @return whether the nameId field is set
       */
      public boolean hasNameId() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>required int32 name_id = 1;</code>
       * @return this
       */
      public Argument clearNameId() {
        bitField0_ &= ~0x00000001;
        nameId = 0;
        return this;
      }

      /**
       * <code>required int32 name_id = 1;</code>
       * @return the nameId
       */
      public int getNameId() {
        return nameId;
      }

      /**
       * <code>required int32 name_id = 1;</code>
       * @param value the nameId to set
       * @return this
       */
      public Argument setNameId(final int value) {
        bitField0_ |= 0x00000001;
        nameId = value;
        return this;
      }

      /**
       * <code>required .org.jetbrains.kotlin.metadata.Annotation.Argument.Value value = 2;</code>
       * @return whether the value_ field is set
       */
      public boolean hasValue() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>required .org.jetbrains.kotlin.metadata.Annotation.Argument.Value value = 2;</code>
       * @return this
       */
      public Argument clearValue() {
        bitField0_ &= ~0x00000002;
        value_.clear();
        return this;
      }

      /**
       * <code>required .org.jetbrains.kotlin.metadata.Annotation.Argument.Value value = 2;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableValue()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public Value getValue() {
        return value_;
      }

      /**
       * <code>required .org.jetbrains.kotlin.metadata.Annotation.Argument.Value value = 2;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public Value getMutableValue() {
        bitField0_ |= 0x00000002;
        return value_;
      }

      /**
       * <code>required .org.jetbrains.kotlin.metadata.Annotation.Argument.Value value = 2;</code>
       * @param value the value_ to set
       * @return this
       */
      public Argument setValue(final Value value) {
        bitField0_ |= 0x00000002;
        value_.copyFrom(value);
        return this;
      }

      @Override
      public Argument copyFrom(final Argument other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          nameId = other.nameId;
          value_.copyFrom(other.value_);
        }
        return this;
      }

      @Override
      public Argument mergeFrom(final Argument other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasNameId()) {
          setNameId(other.nameId);
        }
        if (other.hasValue()) {
          getMutableValue().mergeFrom(other.value_);
        }
        return this;
      }

      @Override
      public Argument clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        nameId = 0;
        value_.clear();
        return this;
      }

      @Override
      public Argument clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        value_.clearQuick();
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof Argument)) {
          return false;
        }
        Argument other = (Argument) o;
        return bitField0_ == other.bitField0_
          && (!hasNameId() || nameId == other.nameId)
          && (!hasValue() || value_.equals(other.value_));
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((((bitField0_ & 0x00000003) != 0x00000003))) {
          throw new UninitializedMessageException(this);
        }
        try {
          output.writeRawByte((byte) 8);
          output.writeInt32NoTag(nameId);
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(value_);
        } catch (UninitializedMessageException nestedFail) {
          throw rethrowFromParent(nestedFail);
        }
      }

      @Override
      protected int computeSerializedSize() {
        if ((((bitField0_ & 0x00000003) != 0x00000003))) {
          throw new UninitializedMessageException(this);
        }
        try {
          int size = 0;
          size += 1 + ProtoSink.computeInt32SizeNoTag(nameId);
          size += 1 + ProtoSink.computeMessageSizeNoTag(value_);
          return size;
        } catch (UninitializedMessageException nestedFail) {
          throw rethrowFromParent(nestedFail);
        }
      }

      @Override
      @SuppressWarnings("fallthrough")
      public Argument mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 8: {
              // nameId
              nameId = input.readInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 18) {
                break;
              }
            }
            case 18: {
              // value_
              input.readMessage(value_);
              bitField0_ |= 0x00000002;
              tag = input.readTag();
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public final boolean isInitialized() {
        if ((((bitField0_ & 0x00000003) != 0x00000003))) {
          return false;
        }
        if (!value_.isInitialized()) {
          return false;
        }
        return true;
      }

      @Override
      protected final void getMissingFields(String prefix, List<String> results) {
        if (!hasNameId()) {
          results.add(prefix + "name_id");
        }
        if (!hasValue()) {
          results.add(prefix + "value");
        } else {
          getMissingFields(prefix, "value", value_, results);
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        if ((((bitField0_ & 0x00000003) != 0x00000003))) {
          throw new UninitializedMessageException(this);
        }
        try {
          output.beginObject();
          output.writeInt32(FieldNames.nameId, nameId);
          output.writeMessage(FieldNames.value_, value_);
          output.endObject();
        } catch (UninitializedMessageException nestedFail) {
          throw rethrowFromParent(nestedFail);
        }
      }

      @Override
      public Argument mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case -1052832506:
            case 1721952079: {
              if (input.isAtField(FieldNames.nameId)) {
                if (!input.trySkipNullValue()) {
                  nameId = input.readInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 111972721: {
              if (input.isAtField(FieldNames.value_)) {
                if (!input.trySkipNullValue()) {
                  input.readMessage(value_);
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public Argument clone() {
        return new Argument().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static Argument parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new Argument(), data).checkInitialized();
      }

      public static Argument parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Argument(), input).checkInitialized();
      }

      public static Argument parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Argument(), input).checkInitialized();
      }

      /**
       * @return factory for creating Argument messages
       */
      public static MessageFactory<Argument> getFactory() {
        return ArgumentFactory.INSTANCE;
      }

      /**
       * Protobuf type {@code Value}
       */
      public static final class Value extends ProtoMessage<Value> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <code>optional double double_value = 4;</code>
         */
        private double doubleValue;

        /**
         * <code>optional sint64 int_value = 2;</code>
         */
        private long intValue;

        /**
         * <code>optional float float_value = 3;</code>
         */
        private float floatValue;

        /**
         * <code>optional int32 string_value = 5;</code>
         */
        private int stringValue;

        /**
         * <pre>
         *  If type = CLASS, FQ name of the referenced class; if type = ENUM, FQ name of the enum class
         * </pre>
         *
         * <code>optional int32 class_id = 6;</code>
         */
        private int classId;

        /**
         * <code>optional int32 enum_value_id = 7;</code>
         */
        private int enumValueId;

        /**
         * <pre>
         *
         * isUnsigned
         * </pre>
         *
         * <code>optional int32 flags = 10 [default = 0];</code>
         */
        private int flags = 0;

        /**
         * <pre>
         *  If type = CLASS, the number of dimensions of the array of the class specified in class_id.
         *  E.g. if class_id = kotlin/String, this annotation argument value denotes:
         *  - String::class, if array_dimension_count = 0
         *  - Array<String>::class, if array_dimension_count = 1
         *  - Array<Array<String>>::class, if array_dimension_count = 2
         *  - etc.
         *  Since it's very difficult to represent Kotlin-specific type aspects (nullability, type projections) of array arguments
         *  in class literals on JVM, we don't bother to do represent this in our format as well.
         *  So, for example, values `Array<Array<in B?>>::class` and `Array<out Array<B>>?>::class` will be represented exactly the same here.
         * </pre>
         *
         * <code>optional int32 array_dimension_count = 11 [default = 0];</code>
         */
        private int arrayDimensionCount = 0;

        /**
         * <pre>
         *  Note: a *Value* has a Type, not an Argument! This is done for future language features which may involve using arrays
         *  of elements of different types. Such entries are allowed in the constant pool of JVM class files.
         *  However, to save space, this field is optional: in case of homogeneous arrays, only the type of the first element is required
         * </pre>
         *
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value.Type type = 1;</code>
         */
        private int type;

        /**
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
         */
        private Annotation annotation = null;

        /**
         * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument.Value array_element = 9;</code>
         */
        private RepeatedMessage<Value> arrayElement = null;

        private Value() {
        }

        /**
         * @return a new empty instance of {@code Value}
         */
        public static Value newInstance() {
          return new Value();
        }

        /**
         * <code>optional double double_value = 4;</code>
         * @return whether the doubleValue field is set
         */
        public boolean hasDoubleValue() {
          return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <code>optional double double_value = 4;</code>
         * @return this
         */
        public Value clearDoubleValue() {
          bitField0_ &= ~0x00000001;
          doubleValue = 0D;
          return this;
        }

        /**
         * <code>optional double double_value = 4;</code>
         * @return the doubleValue
         */
        public double getDoubleValue() {
          return doubleValue;
        }

        /**
         * <code>optional double double_value = 4;</code>
         * @param value the doubleValue to set
         * @return this
         */
        public Value setDoubleValue(final double value) {
          bitField0_ |= 0x00000001;
          doubleValue = value;
          return this;
        }

        /**
         * <code>optional sint64 int_value = 2;</code>
         * @return whether the intValue field is set
         */
        public boolean hasIntValue() {
          return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <code>optional sint64 int_value = 2;</code>
         * @return this
         */
        public Value clearIntValue() {
          bitField0_ &= ~0x00000002;
          intValue = 0L;
          return this;
        }

        /**
         * <code>optional sint64 int_value = 2;</code>
         * @return the intValue
         */
        public long getIntValue() {
          return intValue;
        }

        /**
         * <code>optional sint64 int_value = 2;</code>
         * @param value the intValue to set
         * @return this
         */
        public Value setIntValue(final long value) {
          bitField0_ |= 0x00000002;
          intValue = value;
          return this;
        }

        /**
         * <code>optional float float_value = 3;</code>
         * @return whether the floatValue field is set
         */
        public boolean hasFloatValue() {
          return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <code>optional float float_value = 3;</code>
         * @return this
         */
        public Value clearFloatValue() {
          bitField0_ &= ~0x00000004;
          floatValue = 0F;
          return this;
        }

        /**
         * <code>optional float float_value = 3;</code>
         * @return the floatValue
         */
        public float getFloatValue() {
          return floatValue;
        }

        /**
         * <code>optional float float_value = 3;</code>
         * @param value the floatValue to set
         * @return this
         */
        public Value setFloatValue(final float value) {
          bitField0_ |= 0x00000004;
          floatValue = value;
          return this;
        }

        /**
         * <code>optional int32 string_value = 5;</code>
         * @return whether the stringValue field is set
         */
        public boolean hasStringValue() {
          return (bitField0_ & 0x00000008) != 0;
        }

        /**
         * <code>optional int32 string_value = 5;</code>
         * @return this
         */
        public Value clearStringValue() {
          bitField0_ &= ~0x00000008;
          stringValue = 0;
          return this;
        }

        /**
         * <code>optional int32 string_value = 5;</code>
         * @return the stringValue
         */
        public int getStringValue() {
          return stringValue;
        }

        /**
         * <code>optional int32 string_value = 5;</code>
         * @param value the stringValue to set
         * @return this
         */
        public Value setStringValue(final int value) {
          bitField0_ |= 0x00000008;
          stringValue = value;
          return this;
        }

        /**
         * <pre>
         *  If type = CLASS, FQ name of the referenced class; if type = ENUM, FQ name of the enum class
         * </pre>
         *
         * <code>optional int32 class_id = 6;</code>
         * @return whether the classId field is set
         */
        public boolean hasClassId() {
          return (bitField0_ & 0x00000010) != 0;
        }

        /**
         * <pre>
         *  If type = CLASS, FQ name of the referenced class; if type = ENUM, FQ name of the enum class
         * </pre>
         *
         * <code>optional int32 class_id = 6;</code>
         * @return this
         */
        public Value clearClassId() {
          bitField0_ &= ~0x00000010;
          classId = 0;
          return this;
        }

        /**
         * <pre>
         *  If type = CLASS, FQ name of the referenced class; if type = ENUM, FQ name of the enum class
         * </pre>
         *
         * <code>optional int32 class_id = 6;</code>
         * @return the classId
         */
        public int getClassId() {
          return classId;
        }

        /**
         * <pre>
         *  If type = CLASS, FQ name of the referenced class; if type = ENUM, FQ name of the enum class
         * </pre>
         *
         * <code>optional int32 class_id = 6;</code>
         * @param value the classId to set
         * @return this
         */
        public Value setClassId(final int value) {
          bitField0_ |= 0x00000010;
          classId = value;
          return this;
        }

        /**
         * <code>optional int32 enum_value_id = 7;</code>
         * @return whether the enumValueId field is set
         */
        public boolean hasEnumValueId() {
          return (bitField0_ & 0x00000020) != 0;
        }

        /**
         * <code>optional int32 enum_value_id = 7;</code>
         * @return this
         */
        public Value clearEnumValueId() {
          bitField0_ &= ~0x00000020;
          enumValueId = 0;
          return this;
        }

        /**
         * <code>optional int32 enum_value_id = 7;</code>
         * @return the enumValueId
         */
        public int getEnumValueId() {
          return enumValueId;
        }

        /**
         * <code>optional int32 enum_value_id = 7;</code>
         * @param value the enumValueId to set
         * @return this
         */
        public Value setEnumValueId(final int value) {
          bitField0_ |= 0x00000020;
          enumValueId = value;
          return this;
        }

        /**
         * <pre>
         *
         * isUnsigned
         * </pre>
         *
         * <code>optional int32 flags = 10 [default = 0];</code>
         * @return whether the flags field is set
         */
        public boolean hasFlags() {
          return (bitField0_ & 0x00000040) != 0;
        }

        /**
         * <pre>
         *
         * isUnsigned
         * </pre>
         *
         * <code>optional int32 flags = 10 [default = 0];</code>
         * @return this
         */
        public Value clearFlags() {
          bitField0_ &= ~0x00000040;
          flags = 0;
          return this;
        }

        /**
         * <pre>
         *
         * isUnsigned
         * </pre>
         *
         * <code>optional int32 flags = 10 [default = 0];</code>
         * @return the flags
         */
        public int getFlags() {
          return flags;
        }

        /**
         * <pre>
         *
         * isUnsigned
         * </pre>
         *
         * <code>optional int32 flags = 10 [default = 0];</code>
         * @param value the flags to set
         * @return this
         */
        public Value setFlags(final int value) {
          bitField0_ |= 0x00000040;
          flags = value;
          return this;
        }

        /**
         * <pre>
         *  If type = CLASS, the number of dimensions of the array of the class specified in class_id.
         *  E.g. if class_id = kotlin/String, this annotation argument value denotes:
         *  - String::class, if array_dimension_count = 0
         *  - Array<String>::class, if array_dimension_count = 1
         *  - Array<Array<String>>::class, if array_dimension_count = 2
         *  - etc.
         *  Since it's very difficult to represent Kotlin-specific type aspects (nullability, type projections) of array arguments
         *  in class literals on JVM, we don't bother to do represent this in our format as well.
         *  So, for example, values `Array<Array<in B?>>::class` and `Array<out Array<B>>?>::class` will be represented exactly the same here.
         * </pre>
         *
         * <code>optional int32 array_dimension_count = 11 [default = 0];</code>
         * @return whether the arrayDimensionCount field is set
         */
        public boolean hasArrayDimensionCount() {
          return (bitField0_ & 0x00000080) != 0;
        }

        /**
         * <pre>
         *  If type = CLASS, the number of dimensions of the array of the class specified in class_id.
         *  E.g. if class_id = kotlin/String, this annotation argument value denotes:
         *  - String::class, if array_dimension_count = 0
         *  - Array<String>::class, if array_dimension_count = 1
         *  - Array<Array<String>>::class, if array_dimension_count = 2
         *  - etc.
         *  Since it's very difficult to represent Kotlin-specific type aspects (nullability, type projections) of array arguments
         *  in class literals on JVM, we don't bother to do represent this in our format as well.
         *  So, for example, values `Array<Array<in B?>>::class` and `Array<out Array<B>>?>::class` will be represented exactly the same here.
         * </pre>
         *
         * <code>optional int32 array_dimension_count = 11 [default = 0];</code>
         * @return this
         */
        public Value clearArrayDimensionCount() {
          bitField0_ &= ~0x00000080;
          arrayDimensionCount = 0;
          return this;
        }

        /**
         * <pre>
         *  If type = CLASS, the number of dimensions of the array of the class specified in class_id.
         *  E.g. if class_id = kotlin/String, this annotation argument value denotes:
         *  - String::class, if array_dimension_count = 0
         *  - Array<String>::class, if array_dimension_count = 1
         *  - Array<Array<String>>::class, if array_dimension_count = 2
         *  - etc.
         *  Since it's very difficult to represent Kotlin-specific type aspects (nullability, type projections) of array arguments
         *  in class literals on JVM, we don't bother to do represent this in our format as well.
         *  So, for example, values `Array<Array<in B?>>::class` and `Array<out Array<B>>?>::class` will be represented exactly the same here.
         * </pre>
         *
         * <code>optional int32 array_dimension_count = 11 [default = 0];</code>
         * @return the arrayDimensionCount
         */
        public int getArrayDimensionCount() {
          return arrayDimensionCount;
        }

        /**
         * <pre>
         *  If type = CLASS, the number of dimensions of the array of the class specified in class_id.
         *  E.g. if class_id = kotlin/String, this annotation argument value denotes:
         *  - String::class, if array_dimension_count = 0
         *  - Array<String>::class, if array_dimension_count = 1
         *  - Array<Array<String>>::class, if array_dimension_count = 2
         *  - etc.
         *  Since it's very difficult to represent Kotlin-specific type aspects (nullability, type projections) of array arguments
         *  in class literals on JVM, we don't bother to do represent this in our format as well.
         *  So, for example, values `Array<Array<in B?>>::class` and `Array<out Array<B>>?>::class` will be represented exactly the same here.
         * </pre>
         *
         * <code>optional int32 array_dimension_count = 11 [default = 0];</code>
         * @param value the arrayDimensionCount to set
         * @return this
         */
        public Value setArrayDimensionCount(final int value) {
          bitField0_ |= 0x00000080;
          arrayDimensionCount = value;
          return this;
        }

        /**
         * <pre>
         *  Note: a *Value* has a Type, not an Argument! This is done for future language features which may involve using arrays
         *  of elements of different types. Such entries are allowed in the constant pool of JVM class files.
         *  However, to save space, this field is optional: in case of homogeneous arrays, only the type of the first element is required
         * </pre>
         *
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value.Type type = 1;</code>
         * @return whether the type field is set
         */
        public boolean hasType() {
          return (bitField0_ & 0x00000100) != 0;
        }

        /**
         * <pre>
         *  Note: a *Value* has a Type, not an Argument! This is done for future language features which may involve using arrays
         *  of elements of different types. Such entries are allowed in the constant pool of JVM class files.
         *  However, to save space, this field is optional: in case of homogeneous arrays, only the type of the first element is required
         * </pre>
         *
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value.Type type = 1;</code>
         * @return this
         */
        public Value clearType() {
          bitField0_ &= ~0x00000100;
          type = 0;
          return this;
        }

        /**
         * <pre>
         *  Note: a *Value* has a Type, not an Argument! This is done for future language features which may involve using arrays
         *  of elements of different types. Such entries are allowed in the constant pool of JVM class files.
         *  However, to save space, this field is optional: in case of homogeneous arrays, only the type of the first element is required
         * </pre>
         *
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value.Type type = 1;</code>
         * @return the type
         */
        public Type getType() {
          return Type.forNumber(type);
        }

        /**
         * Gets the value of the internal enum store. The result is
         * equivalent to {@link Value#getType()}.getNumber().
         *
         * @return numeric wire representation
         */
        public int getTypeValue() {
          return type;
        }

        /**
         * Sets the value of the internal enum store. This does not
         * do any validity checks, so be sure to use appropriate value
         * constants from {@link Type}. Setting an invalid value
         * can cause {@link Value#getType()} to return null
         *
         * @param value the numeric wire value to set
         * @return this
         */
        public Value setTypeValue(final int value) {
          bitField0_ |= 0x00000100;
          type = value;
          return this;
        }

        /**
         * <pre>
         *  Note: a *Value* has a Type, not an Argument! This is done for future language features which may involve using arrays
         *  of elements of different types. Such entries are allowed in the constant pool of JVM class files.
         *  However, to save space, this field is optional: in case of homogeneous arrays, only the type of the first element is required
         * </pre>
         *
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value.Type type = 1;</code>
         * @param value the type to set
         * @return this
         */
        public Value setType(final Type value) {
          bitField0_ |= 0x00000100;
          type = value.getNumber();
          return this;
        }

        private void initAnnotation() {
          if (annotation == null) {
            annotation = Annotation.newInstance();
          }
        }

        /**
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
         * @return whether the annotation field is set
         */
        public boolean hasAnnotation() {
          return (bitField0_ & 0x00000200) != 0;
        }

        /**
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
         * @return this
         */
        public Value clearAnnotation() {
          bitField0_ &= ~0x00000200;
          if (annotation != null) {
            annotation.clear();
          }
          return this;
        }

        /**
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutableAnnotation()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public Annotation getAnnotation() {
          initAnnotation();
          return annotation;
        }

        /**
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public Annotation getMutableAnnotation() {
          initAnnotation();
          bitField0_ |= 0x00000200;
          return annotation;
        }

        /**
         * <code>optional .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
         * @param value the annotation to set
         * @return this
         */
        public Value setAnnotation(final Annotation value) {
          initAnnotation();
          bitField0_ |= 0x00000200;
          annotation.copyFrom(value);
          return this;
        }

        private void initArrayElement() {
          if (arrayElement == null) {
            arrayElement = RepeatedMessage.newEmptyInstance(Value.getFactory());
          }
        }

        /**
         * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument.Value array_element = 9;</code>
         * @return whether the arrayElement field is set
         */
        public boolean hasArrayElement() {
          return (bitField0_ & 0x00000400) != 0;
        }

        /**
         * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument.Value array_element = 9;</code>
         * @return this
         */
        public Value clearArrayElement() {
          bitField0_ &= ~0x00000400;
          if (arrayElement != null) {
            arrayElement.clear();
          }
          return this;
        }

        /**
         * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument.Value array_element = 9;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutableArrayElement()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public RepeatedMessage<Value> getArrayElement() {
          initArrayElement();
          return arrayElement;
        }

        /**
         * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument.Value array_element = 9;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public RepeatedMessage<Value> getMutableArrayElement() {
          initArrayElement();
          bitField0_ |= 0x00000400;
          return arrayElement;
        }

        /**
         * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument.Value array_element = 9;</code>
         * @param value the arrayElement to add
         * @return this
         */
        public Value addArrayElement(final Value value) {
          initArrayElement();
          bitField0_ |= 0x00000400;
          arrayElement.add(value);
          return this;
        }

        /**
         * <code>repeated .org.jetbrains.kotlin.metadata.Annotation.Argument.Value array_element = 9;</code>
         * @param values the arrayElement to add
         * @return this
         */
        public Value addAllArrayElement(final Value... values) {
          initArrayElement();
          bitField0_ |= 0x00000400;
          arrayElement.addAll(values);
          return this;
        }

        @Override
        public Value copyFrom(final Value other) {
          cachedSize = other.cachedSize;
          if ((bitField0_ | other.bitField0_) != 0) {
            bitField0_ = other.bitField0_;
            doubleValue = other.doubleValue;
            intValue = other.intValue;
            floatValue = other.floatValue;
            stringValue = other.stringValue;
            classId = other.classId;
            enumValueId = other.enumValueId;
            flags = other.flags;
            arrayDimensionCount = other.arrayDimensionCount;
            type = other.type;
            if (other.hasAnnotation()) {
              initAnnotation();
              annotation.copyFrom(other.annotation);
            } else {
              clearAnnotation();
            }
            if (other.hasArrayElement()) {
              initArrayElement();
              arrayElement.copyFrom(other.arrayElement);
            } else {
              clearArrayElement();
            }
          }
          return this;
        }

        @Override
        public Value mergeFrom(final Value other) {
          if (other.isEmpty()) {
            return this;
          }
          cachedSize = -1;
          if (other.hasDoubleValue()) {
            setDoubleValue(other.doubleValue);
          }
          if (other.hasIntValue()) {
            setIntValue(other.intValue);
          }
          if (other.hasFloatValue()) {
            setFloatValue(other.floatValue);
          }
          if (other.hasStringValue()) {
            setStringValue(other.stringValue);
          }
          if (other.hasClassId()) {
            setClassId(other.classId);
          }
          if (other.hasEnumValueId()) {
            setEnumValueId(other.enumValueId);
          }
          if (other.hasFlags()) {
            setFlags(other.flags);
          }
          if (other.hasArrayDimensionCount()) {
            setArrayDimensionCount(other.arrayDimensionCount);
          }
          if (other.hasType()) {
            setTypeValue(other.type);
          }
          if (other.hasAnnotation()) {
            getMutableAnnotation().mergeFrom(other.annotation);
          }
          if (other.hasArrayElement()) {
            getMutableArrayElement().addAll(other.arrayElement);
          }
          return this;
        }

        @Override
        public Value clear() {
          if (isEmpty()) {
            return this;
          }
          cachedSize = -1;
          bitField0_ = 0;
          doubleValue = 0D;
          intValue = 0L;
          floatValue = 0F;
          stringValue = 0;
          classId = 0;
          enumValueId = 0;
          flags = 0;
          arrayDimensionCount = 0;
          type = 0;
          if (annotation != null) {
            annotation.clear();
          }
          if (arrayElement != null) {
            arrayElement.clear();
          }
          return this;
        }

        @Override
        public Value clearQuick() {
          if (isEmpty()) {
            return this;
          }
          cachedSize = -1;
          bitField0_ = 0;
          if (annotation != null) {
            annotation.clearQuick();
          }
          if (arrayElement != null) {
            arrayElement.clearQuick();
          }
          return this;
        }

        @Override
        public boolean equals(Object o) {
          if (o == this) {
            return true;
          }
          if (!(o instanceof Value)) {
            return false;
          }
          Value other = (Value) o;
          return bitField0_ == other.bitField0_
            && (!hasDoubleValue() || ProtoUtil.isEqual(doubleValue, other.doubleValue))
            && (!hasIntValue() || intValue == other.intValue)
            && (!hasFloatValue() || ProtoUtil.isEqual(floatValue, other.floatValue))
            && (!hasStringValue() || stringValue == other.stringValue)
            && (!hasClassId() || classId == other.classId)
            && (!hasEnumValueId() || enumValueId == other.enumValueId)
            && (!hasFlags() || flags == other.flags)
            && (!hasArrayDimensionCount() || arrayDimensionCount == other.arrayDimensionCount)
            && (!hasType() || type == other.type)
            && (!hasAnnotation() || annotation.equals(other.annotation))
            && (!hasArrayElement() || arrayElement.equals(other.arrayElement));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
          try {
            if ((bitField0_ & 0x00000001) != 0) {
              output.writeRawByte((byte) 33);
              output.writeDoubleNoTag(doubleValue);
            }
            if ((bitField0_ & 0x00000002) != 0) {
              output.writeRawByte((byte) 16);
              output.writeSInt64NoTag(intValue);
            }
            if ((bitField0_ & 0x00000004) != 0) {
              output.writeRawByte((byte) 29);
              output.writeFloatNoTag(floatValue);
            }
            if ((bitField0_ & 0x00000008) != 0) {
              output.writeRawByte((byte) 40);
              output.writeInt32NoTag(stringValue);
            }
            if ((bitField0_ & 0x00000010) != 0) {
              output.writeRawByte((byte) 48);
              output.writeInt32NoTag(classId);
            }
            if ((bitField0_ & 0x00000020) != 0) {
              output.writeRawByte((byte) 56);
              output.writeInt32NoTag(enumValueId);
            }
            if ((bitField0_ & 0x00000040) != 0) {
              output.writeRawByte((byte) 80);
              output.writeInt32NoTag(flags);
            }
            if ((bitField0_ & 0x00000080) != 0) {
              output.writeRawByte((byte) 88);
              output.writeInt32NoTag(arrayDimensionCount);
            }
            if ((bitField0_ & 0x00000100) != 0) {
              output.writeRawByte((byte) 8);
              output.writeEnumNoTag(type);
            }
            if ((bitField0_ & 0x00000200) != 0) {
              output.writeRawByte((byte) 66);
              output.writeMessageNoTag(annotation);
            }
            if ((bitField0_ & 0x00000400) != 0) {
              for (int i = 0; i < arrayElement.length(); i++) {
                output.writeRawByte((byte) 74);
                output.writeMessageNoTag(arrayElement.get(i));
              }
            }
          } catch (UninitializedMessageException nestedFail) {
            throw rethrowFromParent(nestedFail);
          }
        }

        @Override
        protected int computeSerializedSize() {
          try {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
              size += 9;
            }
            if ((bitField0_ & 0x00000002) != 0) {
              size += 1 + ProtoSink.computeSInt64SizeNoTag(intValue);
            }
            if ((bitField0_ & 0x00000004) != 0) {
              size += 5;
            }
            if ((bitField0_ & 0x00000008) != 0) {
              size += 1 + ProtoSink.computeInt32SizeNoTag(stringValue);
            }
            if ((bitField0_ & 0x00000010) != 0) {
              size += 1 + ProtoSink.computeInt32SizeNoTag(classId);
            }
            if ((bitField0_ & 0x00000020) != 0) {
              size += 1 + ProtoSink.computeInt32SizeNoTag(enumValueId);
            }
            if ((bitField0_ & 0x00000040) != 0) {
              size += 1 + ProtoSink.computeInt32SizeNoTag(flags);
            }
            if ((bitField0_ & 0x00000080) != 0) {
              size += 1 + ProtoSink.computeInt32SizeNoTag(arrayDimensionCount);
            }
            if ((bitField0_ & 0x00000100) != 0) {
              size += 1 + ProtoSink.computeEnumSizeNoTag(type);
            }
            if ((bitField0_ & 0x00000200) != 0) {
              size += 1 + ProtoSink.computeMessageSizeNoTag(annotation);
            }
            if ((bitField0_ & 0x00000400) != 0) {
              size += (1 * arrayElement.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(arrayElement);
            }
            return size;
          } catch (UninitializedMessageException nestedFail) {
            throw rethrowFromParent(nestedFail);
          }
        }

        @Override
        @SuppressWarnings("fallthrough")
        public Value mergeFrom(final ProtoSource input) throws IOException {
          // Enabled Fall-Through Optimization (QuickBuffers)
          int tag = input.readTag();
          while (true) {
            switch (tag) {
              case 33: {
                // doubleValue
                doubleValue = input.readDouble();
                bitField0_ |= 0x00000001;
                tag = input.readTag();
                if (tag != 16) {
                  break;
                }
              }
              case 16: {
                // intValue
                intValue = input.readSInt64();
                bitField0_ |= 0x00000002;
                tag = input.readTag();
                if (tag != 29) {
                  break;
                }
              }
              case 29: {
                // floatValue
                floatValue = input.readFloat();
                bitField0_ |= 0x00000004;
                tag = input.readTag();
                if (tag != 40) {
                  break;
                }
              }
              case 40: {
                // stringValue
                stringValue = input.readInt32();
                bitField0_ |= 0x00000008;
                tag = input.readTag();
                if (tag != 48) {
                  break;
                }
              }
              case 48: {
                // classId
                classId = input.readInt32();
                bitField0_ |= 0x00000010;
                tag = input.readTag();
                if (tag != 56) {
                  break;
                }
              }
              case 56: {
                // enumValueId
                enumValueId = input.readInt32();
                bitField0_ |= 0x00000020;
                tag = input.readTag();
                if (tag != 80) {
                  break;
                }
              }
              case 80: {
                // flags
                flags = input.readInt32();
                bitField0_ |= 0x00000040;
                tag = input.readTag();
                if (tag != 88) {
                  break;
                }
              }
              case 88: {
                // arrayDimensionCount
                arrayDimensionCount = input.readInt32();
                bitField0_ |= 0x00000080;
                tag = input.readTag();
                if (tag != 8) {
                  break;
                }
              }
              case 8: {
                // type
                final int value = input.readInt32();
                if (Type.forNumber(value) != null) {
                  type = value;
                  bitField0_ |= 0x00000100;
                }
                tag = input.readTag();
                if (tag != 66) {
                  break;
                }
              }
              case 66: {
                // annotation
                initAnnotation();
                input.readMessage(annotation);
                bitField0_ |= 0x00000200;
                tag = input.readTag();
                if (tag != 74) {
                  break;
                }
              }
              case 74: {
                // arrayElement
                initArrayElement();
                tag = input.readRepeatedMessage(arrayElement, tag);
                bitField0_ |= 0x00000400;
                if (tag != 0) {
                  break;
                }
              }
              case 0: {
                return this;
              }
              default: {
                if (!input.skipField(tag)) {
                  return this;
                }
                tag = input.readTag();
                break;
              }
            }
          }
        }

        @Override
        public final boolean isInitialized() {
          if (hasAnnotation() && !annotation.isInitialized()) {
            return false;
          }
          if (hasArrayElement() && !arrayElement.isInitialized()) {
            return false;
          }
          return true;
        }

        @Override
        protected final void getMissingFields(String prefix, List<String> results) {
          if (hasAnnotation() && !annotation.isInitialized()) {
            getMissingFields(prefix, "annotation", annotation, results);
          }
          if (hasArrayElement() && !arrayElement.isInitialized()) {
            getMissingFields(prefix, "array_element", arrayElement, results);
          }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
          try {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
              output.writeDouble(FieldNames.doubleValue, doubleValue);
            }
            if ((bitField0_ & 0x00000002) != 0) {
              output.writeSInt64(FieldNames.intValue, intValue);
            }
            if ((bitField0_ & 0x00000004) != 0) {
              output.writeFloat(FieldNames.floatValue, floatValue);
            }
            if ((bitField0_ & 0x00000008) != 0) {
              output.writeInt32(FieldNames.stringValue, stringValue);
            }
            if ((bitField0_ & 0x00000010) != 0) {
              output.writeInt32(FieldNames.classId, classId);
            }
            if ((bitField0_ & 0x00000020) != 0) {
              output.writeInt32(FieldNames.enumValueId, enumValueId);
            }
            if ((bitField0_ & 0x00000040) != 0) {
              output.writeInt32(FieldNames.flags, flags);
            }
            if ((bitField0_ & 0x00000080) != 0) {
              output.writeInt32(FieldNames.arrayDimensionCount, arrayDimensionCount);
            }
            if ((bitField0_ & 0x00000100) != 0) {
              output.writeEnum(FieldNames.type, type, Type.converter());
            }
            if ((bitField0_ & 0x00000200) != 0) {
              output.writeMessage(FieldNames.annotation, annotation);
            }
            if ((bitField0_ & 0x00000400) != 0) {
              output.writeRepeatedMessage(FieldNames.arrayElement, arrayElement);
            }
            output.endObject();
          } catch (UninitializedMessageException nestedFail) {
            throw rethrowFromParent(nestedFail);
          }
        }

        @Override
        public Value mergeFrom(final JsonSource input) throws IOException {
          if (!input.beginObject()) {
            return this;
          }
          while (!input.isAtEnd()) {
            switch (input.readFieldHash()) {
              case -1626611680:
              case 1391366019: {
                if (input.isAtField(FieldNames.doubleValue)) {
                  if (!input.trySkipNullValue()) {
                    doubleValue = input.readDouble();
                    bitField0_ |= 0x00000001;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case 556050114:
              case 334404897: {
                if (input.isAtField(FieldNames.intValue)) {
                  if (!input.trySkipNullValue()) {
                    intValue = input.readSInt64();
                    bitField0_ |= 0x00000002;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case -1025730443:
              case -1456152114: {
                if (input.isAtField(FieldNames.floatValue)) {
                  if (!input.trySkipNullValue()) {
                    floatValue = input.readFloat();
                    bitField0_ |= 0x00000004;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case -1519213600:
              case 425739203: {
                if (input.isAtField(FieldNames.stringValue)) {
                  if (!input.trySkipNullValue()) {
                    stringValue = input.readInt32();
                    bitField0_ |= 0x00000008;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case 853619891:
              case 692434242: {
                if (input.isAtField(FieldNames.classId)) {
                  if (!input.trySkipNullValue()) {
                    classId = input.readInt32();
                    bitField0_ |= 0x00000010;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case 620139051:
              case 690572327: {
                if (input.isAtField(FieldNames.enumValueId)) {
                  if (!input.trySkipNullValue()) {
                    enumValueId = input.readInt32();
                    bitField0_ |= 0x00000020;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case 97513095: {
                if (input.isAtField(FieldNames.flags)) {
                  if (!input.trySkipNullValue()) {
                    flags = input.readInt32();
                    bitField0_ |= 0x00000040;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case 129962498:
              case 466416400: {
                if (input.isAtField(FieldNames.arrayDimensionCount)) {
                  if (!input.trySkipNullValue()) {
                    arrayDimensionCount = input.readInt32();
                    bitField0_ |= 0x00000080;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case 3575610: {
                if (input.isAtField(FieldNames.type)) {
                  if (!input.trySkipNullValue()) {
                    final Type value = input.readEnum(Type.converter());
                    if (value != null) {
                      type = value.getNumber();
                      bitField0_ |= 0x00000100;
                    } else {
                      input.skipUnknownEnumValue();
                    }
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case -1555043537: {
                if (input.isAtField(FieldNames.annotation)) {
                  if (!input.trySkipNullValue()) {
                    initAnnotation();
                    input.readMessage(annotation);
                    bitField0_ |= 0x00000200;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              case 1213439587:
              case -398995690: {
                if (input.isAtField(FieldNames.arrayElement)) {
                  if (!input.trySkipNullValue()) {
                    initArrayElement();
                    input.readRepeatedMessage(arrayElement);
                    bitField0_ |= 0x00000400;
                  }
                } else {
                  input.skipUnknownField();
                }
                break;
              }
              default: {
                input.skipUnknownField();
                break;
              }
            }
          }
          input.endObject();
          return this;
        }

        @Override
        public Value clone() {
          return new Value().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
          return ((bitField0_) == 0);
        }

        public static Value parseFrom(final byte[] data) throws InvalidProtocolBufferException {
          return ProtoMessage.mergeFrom(new Value(), data).checkInitialized();
        }

        public static Value parseFrom(final ProtoSource input) throws IOException {
          return ProtoMessage.mergeFrom(new Value(), input).checkInitialized();
        }

        public static Value parseFrom(final JsonSource input) throws IOException {
          return ProtoMessage.mergeFrom(new Value(), input).checkInitialized();
        }

        /**
         * @return factory for creating Value messages
         */
        public static MessageFactory<Value> getFactory() {
          return ValueFactory.INSTANCE;
        }

        /**
         * Protobuf enum {@code Type}
         */
        public enum Type implements ProtoEnum<Type> {
          /**
           * <code>BYTE = 0;</code>
           */
          BYTE("BYTE", 0),

          /**
           * <code>CHAR = 1;</code>
           */
          CHAR("CHAR", 1),

          /**
           * <code>SHORT = 2;</code>
           */
          SHORT("SHORT", 2),

          /**
           * <code>INT = 3;</code>
           */
          INT("INT", 3),

          /**
           * <code>LONG = 4;</code>
           */
          LONG("LONG", 4),

          /**
           * <code>FLOAT = 5;</code>
           */
          FLOAT("FLOAT", 5),

          /**
           * <code>DOUBLE = 6;</code>
           */
          DOUBLE("DOUBLE", 6),

          /**
           * <code>BOOLEAN = 7;</code>
           */
          BOOLEAN("BOOLEAN", 7),

          /**
           * <code>STRING = 8;</code>
           */
          STRING("STRING", 8),

          /**
           * <code>CLASS = 9;</code>
           */
          CLASS("CLASS", 9),

          /**
           * <code>ENUM = 10;</code>
           */
          ENUM("ENUM", 10),

          /**
           * <code>ANNOTATION = 11;</code>
           */
          ANNOTATION("ANNOTATION", 11),

          /**
           * <code>ARRAY = 12;</code>
           */
          ARRAY("ARRAY", 12);

          /**
           * <code>BYTE = 0;</code>
           */
          public static final int BYTE_VALUE = 0;

          /**
           * <code>CHAR = 1;</code>
           */
          public static final int CHAR_VALUE = 1;

          /**
           * <code>SHORT = 2;</code>
           */
          public static final int SHORT_VALUE = 2;

          /**
           * <code>INT = 3;</code>
           */
          public static final int INT_VALUE = 3;

          /**
           * <code>LONG = 4;</code>
           */
          public static final int LONG_VALUE = 4;

          /**
           * <code>FLOAT = 5;</code>
           */
          public static final int FLOAT_VALUE = 5;

          /**
           * <code>DOUBLE = 6;</code>
           */
          public static final int DOUBLE_VALUE = 6;

          /**
           * <code>BOOLEAN = 7;</code>
           */
          public static final int BOOLEAN_VALUE = 7;

          /**
           * <code>STRING = 8;</code>
           */
          public static final int STRING_VALUE = 8;

          /**
           * <code>CLASS = 9;</code>
           */
          public static final int CLASS_VALUE = 9;

          /**
           * <code>ENUM = 10;</code>
           */
          public static final int ENUM_VALUE = 10;

          /**
           * <code>ANNOTATION = 11;</code>
           */
          public static final int ANNOTATION_VALUE = 11;

          /**
           * <code>ARRAY = 12;</code>
           */
          public static final int ARRAY_VALUE = 12;

          private final String name;

          private final int number;

          private Type(String name, int number) {
            this.name = name;
            this.number = number;
          }

          /**
           * @return the string representation of enum entry
           */
          @Override
          public String getName() {
            return name;
          }

          /**
           * @return the numeric wire value of this enum entry
           */
          @Override
          public int getNumber() {
            return number;
          }

          /**
           * @return a converter that maps between this enum's numeric and text representations
           */
          public static ProtoEnum.EnumConverter<Type> converter() {
            return TypeConverter.INSTANCE;
          }

          /**
           * @param value The numeric wire value of the corresponding enum entry.
           * @return The enum associated with the given numeric wire value, or null if unknown.
           */
          public static Type forNumber(int value) {
            return TypeConverter.INSTANCE.forNumber(value);
          }

          /**
           * @param value The numeric wire value of the corresponding enum entry.
           * @param other Fallback value in case the value is not known.
           * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
           */
          public static Type forNumberOr(int number, Type other) {
            Type value = forNumber(number);
            return value == null ? other : value;
          }

          enum TypeConverter implements ProtoEnum.EnumConverter<Type> {
            INSTANCE;

            private static final Type[] lookup = new Type[13];

            static {
              lookup[0] = BYTE;
              lookup[1] = CHAR;
              lookup[2] = SHORT;
              lookup[3] = INT;
              lookup[4] = LONG;
              lookup[5] = FLOAT;
              lookup[6] = DOUBLE;
              lookup[7] = BOOLEAN;
              lookup[8] = STRING;
              lookup[9] = CLASS;
              lookup[10] = ENUM;
              lookup[11] = ANNOTATION;
              lookup[12] = ARRAY;
            }

            @Override
            public final Type forNumber(final int value) {
              if (value >= 0 && value < lookup.length) {
                return lookup[value];
              }
              return null;
            }

            @Override
            public final Type forName(final CharSequence value) {
              switch (value.length()) {
                case 3: {
                  if (ProtoUtil.isEqual("INT", value)) {
                    return INT;
                  }
                  break;
                }
                case 4: {
                  if (ProtoUtil.isEqual("BYTE", value)) {
                    return BYTE;
                  }
                  if (ProtoUtil.isEqual("CHAR", value)) {
                    return CHAR;
                  }
                  if (ProtoUtil.isEqual("LONG", value)) {
                    return LONG;
                  }
                  if (ProtoUtil.isEqual("ENUM", value)) {
                    return ENUM;
                  }
                  break;
                }
                case 5: {
                  if (ProtoUtil.isEqual("SHORT", value)) {
                    return SHORT;
                  }
                  if (ProtoUtil.isEqual("FLOAT", value)) {
                    return FLOAT;
                  }
                  if (ProtoUtil.isEqual("CLASS", value)) {
                    return CLASS;
                  }
                  if (ProtoUtil.isEqual("ARRAY", value)) {
                    return ARRAY;
                  }
                  break;
                }
                case 6: {
                  if (ProtoUtil.isEqual("DOUBLE", value)) {
                    return DOUBLE;
                  }
                  if (ProtoUtil.isEqual("STRING", value)) {
                    return STRING;
                  }
                  break;
                }
                case 7: {
                  if (ProtoUtil.isEqual("BOOLEAN", value)) {
                    return BOOLEAN;
                  }
                  break;
                }
                case 10: {
                  if (ProtoUtil.isEqual("ANNOTATION", value)) {
                    return ANNOTATION;
                  }
                  break;
                }
              }
              return null;
            }
          }
        }

        private enum ValueFactory implements MessageFactory<Value> {
          INSTANCE;

          @Override
          public Value create() {
            return Value.newInstance();
          }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
          static final FieldName doubleValue = FieldName.forField("doubleValue", "double_value");

          static final FieldName intValue = FieldName.forField("intValue", "int_value");

          static final FieldName floatValue = FieldName.forField("floatValue", "float_value");

          static final FieldName stringValue = FieldName.forField("stringValue", "string_value");

          static final FieldName classId = FieldName.forField("classId", "class_id");

          static final FieldName enumValueId = FieldName.forField("enumValueId", "enum_value_id");

          static final FieldName flags = FieldName.forField("flags");

          static final FieldName arrayDimensionCount = FieldName.forField("arrayDimensionCount", "array_dimension_count");

          static final FieldName type = FieldName.forField("type");

          static final FieldName annotation = FieldName.forField("annotation");

          static final FieldName arrayElement = FieldName.forField("arrayElement", "array_element");
        }
      }

      private enum ArgumentFactory implements MessageFactory<Argument> {
        INSTANCE;

        @Override
        public Argument create() {
          return Argument.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName nameId = FieldName.forField("nameId", "name_id");

        static final FieldName value_ = FieldName.forField("value");
      }
    }

    private enum AnnotationFactory implements MessageFactory<Annotation> {
      INSTANCE;

      @Override
      public Annotation create() {
        return Annotation.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("id");

      static final FieldName argument = FieldName.forField("argument");
    }
  }

  /**
   * Protobuf type {@code Type}
   */
  public static final class Type extends ProtoMessage<Type> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <pre>
     *
     * suspend
     * definitelyNonNull
     * </pre>
     *
     * <code>optional int32 flags = 1;</code>
     */
    private int flags;

    /**
     * <pre>
     *  If this field is set, the type is flexible.
     *  All the other fields and extensions represent its lower bound, and flexible_upper_bound must be set and represents its upper bound.
     * </pre>
     *
     * <code>optional int32 flexible_type_capabilities_id = 4;</code>
     */
    private int flexibleTypeCapabilitiesId;

    /**
     * <code>optional int32 class_name = 6;</code>
     */
    private int className;

    /**
     * <pre>
     *  id of the type parameter
     * </pre>
     *
     * <code>optional int32 type_parameter = 7;</code>
     */
    private int typeParameter;

    /**
     * <code>optional int32 flexible_upper_bound_id = 8;</code>
     */
    private int flexibleUpperBoundId;

    /**
     * <pre>
     *  Name of the type parameter in the immediate owner
     * </pre>
     *
     * <code>optional int32 type_parameter_name = 9;</code>
     */
    private int typeParameterName;

    /**
     * <code>optional int32 outer_type_id = 11;</code>
     */
    private int outerTypeId;

    /**
     * <pre>
     *  Note that this may be present only for abbreviated_type
     *  Top level types are always fully expanded
     * </pre>
     *
     * <code>optional int32 type_alias_name = 12;</code>
     */
    private int typeAliasName;

    /**
     * <code>optional int32 abbreviated_type_id = 14;</code>
     */
    private int abbreviatedTypeId;

    /**
     * <code>optional bool nullable = 3 [default = false];</code>
     */
    private boolean nullable = false;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type flexible_upper_bound = 5;</code>
     */
    private Type flexibleUpperBound = null;

    /**
     * <pre>
     *  Outer type may be present only if class_name or type_alias_name is present
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type outer_type = 10;</code>
     */
    private Type outerType = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type abbreviated_type = 13;</code>
     */
    private Type abbreviatedType = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type.Argument argument = 2;</code>
     */
    private RepeatedMessage<Argument> argument = null;

    private Type() {
    }

    /**
     * @return a new empty instance of {@code Type}
     */
    public static Type newInstance() {
      return new Type();
    }

    /**
     * <pre>
     *
     * suspend
     * definitelyNonNull
     * </pre>
     *
     * <code>optional int32 flags = 1;</code>
     * @return whether the flags field is set
     */
    public boolean hasFlags() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <pre>
     *
     * suspend
     * definitelyNonNull
     * </pre>
     *
     * <code>optional int32 flags = 1;</code>
     * @return this
     */
    public Type clearFlags() {
      bitField0_ &= ~0x00000001;
      flags = 0;
      return this;
    }

    /**
     * <pre>
     *
     * suspend
     * definitelyNonNull
     * </pre>
     *
     * <code>optional int32 flags = 1;</code>
     * @return the flags
     */
    public int getFlags() {
      return flags;
    }

    /**
     * <pre>
     *
     * suspend
     * definitelyNonNull
     * </pre>
     *
     * <code>optional int32 flags = 1;</code>
     * @param value the flags to set
     * @return this
     */
    public Type setFlags(final int value) {
      bitField0_ |= 0x00000001;
      flags = value;
      return this;
    }

    /**
     * <pre>
     *  If this field is set, the type is flexible.
     *  All the other fields and extensions represent its lower bound, and flexible_upper_bound must be set and represents its upper bound.
     * </pre>
     *
     * <code>optional int32 flexible_type_capabilities_id = 4;</code>
     * @return whether the flexibleTypeCapabilitiesId field is set
     */
    public boolean hasFlexibleTypeCapabilitiesId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <pre>
     *  If this field is set, the type is flexible.
     *  All the other fields and extensions represent its lower bound, and flexible_upper_bound must be set and represents its upper bound.
     * </pre>
     *
     * <code>optional int32 flexible_type_capabilities_id = 4;</code>
     * @return this
     */
    public Type clearFlexibleTypeCapabilitiesId() {
      bitField0_ &= ~0x00000002;
      flexibleTypeCapabilitiesId = 0;
      return this;
    }

    /**
     * <pre>
     *  If this field is set, the type is flexible.
     *  All the other fields and extensions represent its lower bound, and flexible_upper_bound must be set and represents its upper bound.
     * </pre>
     *
     * <code>optional int32 flexible_type_capabilities_id = 4;</code>
     * @return the flexibleTypeCapabilitiesId
     */
    public int getFlexibleTypeCapabilitiesId() {
      return flexibleTypeCapabilitiesId;
    }

    /**
     * <pre>
     *  If this field is set, the type is flexible.
     *  All the other fields and extensions represent its lower bound, and flexible_upper_bound must be set and represents its upper bound.
     * </pre>
     *
     * <code>optional int32 flexible_type_capabilities_id = 4;</code>
     * @param value the flexibleTypeCapabilitiesId to set
     * @return this
     */
    public Type setFlexibleTypeCapabilitiesId(final int value) {
      bitField0_ |= 0x00000002;
      flexibleTypeCapabilitiesId = value;
      return this;
    }

    /**
     * <code>optional int32 class_name = 6;</code>
     * @return whether the className field is set
     */
    public boolean hasClassName() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional int32 class_name = 6;</code>
     * @return this
     */
    public Type clearClassName() {
      bitField0_ &= ~0x00000004;
      className = 0;
      return this;
    }

    /**
     * <code>optional int32 class_name = 6;</code>
     * @return the className
     */
    public int getClassName() {
      return className;
    }

    /**
     * <code>optional int32 class_name = 6;</code>
     * @param value the className to set
     * @return this
     */
    public Type setClassName(final int value) {
      bitField0_ |= 0x00000004;
      className = value;
      return this;
    }

    /**
     * <pre>
     *  id of the type parameter
     * </pre>
     *
     * <code>optional int32 type_parameter = 7;</code>
     * @return whether the typeParameter field is set
     */
    public boolean hasTypeParameter() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <pre>
     *  id of the type parameter
     * </pre>
     *
     * <code>optional int32 type_parameter = 7;</code>
     * @return this
     */
    public Type clearTypeParameter() {
      bitField0_ &= ~0x00000008;
      typeParameter = 0;
      return this;
    }

    /**
     * <pre>
     *  id of the type parameter
     * </pre>
     *
     * <code>optional int32 type_parameter = 7;</code>
     * @return the typeParameter
     */
    public int getTypeParameter() {
      return typeParameter;
    }

    /**
     * <pre>
     *  id of the type parameter
     * </pre>
     *
     * <code>optional int32 type_parameter = 7;</code>
     * @param value the typeParameter to set
     * @return this
     */
    public Type setTypeParameter(final int value) {
      bitField0_ |= 0x00000008;
      typeParameter = value;
      return this;
    }

    /**
     * <code>optional int32 flexible_upper_bound_id = 8;</code>
     * @return whether the flexibleUpperBoundId field is set
     */
    public boolean hasFlexibleUpperBoundId() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional int32 flexible_upper_bound_id = 8;</code>
     * @return this
     */
    public Type clearFlexibleUpperBoundId() {
      bitField0_ &= ~0x00000010;
      flexibleUpperBoundId = 0;
      return this;
    }

    /**
     * <code>optional int32 flexible_upper_bound_id = 8;</code>
     * @return the flexibleUpperBoundId
     */
    public int getFlexibleUpperBoundId() {
      return flexibleUpperBoundId;
    }

    /**
     * <code>optional int32 flexible_upper_bound_id = 8;</code>
     * @param value the flexibleUpperBoundId to set
     * @return this
     */
    public Type setFlexibleUpperBoundId(final int value) {
      bitField0_ |= 0x00000010;
      flexibleUpperBoundId = value;
      return this;
    }

    /**
     * <pre>
     *  Name of the type parameter in the immediate owner
     * </pre>
     *
     * <code>optional int32 type_parameter_name = 9;</code>
     * @return whether the typeParameterName field is set
     */
    public boolean hasTypeParameterName() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <pre>
     *  Name of the type parameter in the immediate owner
     * </pre>
     *
     * <code>optional int32 type_parameter_name = 9;</code>
     * @return this
     */
    public Type clearTypeParameterName() {
      bitField0_ &= ~0x00000020;
      typeParameterName = 0;
      return this;
    }

    /**
     * <pre>
     *  Name of the type parameter in the immediate owner
     * </pre>
     *
     * <code>optional int32 type_parameter_name = 9;</code>
     * @return the typeParameterName
     */
    public int getTypeParameterName() {
      return typeParameterName;
    }

    /**
     * <pre>
     *  Name of the type parameter in the immediate owner
     * </pre>
     *
     * <code>optional int32 type_parameter_name = 9;</code>
     * @param value the typeParameterName to set
     * @return this
     */
    public Type setTypeParameterName(final int value) {
      bitField0_ |= 0x00000020;
      typeParameterName = value;
      return this;
    }

    /**
     * <code>optional int32 outer_type_id = 11;</code>
     * @return whether the outerTypeId field is set
     */
    public boolean hasOuterTypeId() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional int32 outer_type_id = 11;</code>
     * @return this
     */
    public Type clearOuterTypeId() {
      bitField0_ &= ~0x00000040;
      outerTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 outer_type_id = 11;</code>
     * @return the outerTypeId
     */
    public int getOuterTypeId() {
      return outerTypeId;
    }

    /**
     * <code>optional int32 outer_type_id = 11;</code>
     * @param value the outerTypeId to set
     * @return this
     */
    public Type setOuterTypeId(final int value) {
      bitField0_ |= 0x00000040;
      outerTypeId = value;
      return this;
    }

    /**
     * <pre>
     *  Note that this may be present only for abbreviated_type
     *  Top level types are always fully expanded
     * </pre>
     *
     * <code>optional int32 type_alias_name = 12;</code>
     * @return whether the typeAliasName field is set
     */
    public boolean hasTypeAliasName() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <pre>
     *  Note that this may be present only for abbreviated_type
     *  Top level types are always fully expanded
     * </pre>
     *
     * <code>optional int32 type_alias_name = 12;</code>
     * @return this
     */
    public Type clearTypeAliasName() {
      bitField0_ &= ~0x00000080;
      typeAliasName = 0;
      return this;
    }

    /**
     * <pre>
     *  Note that this may be present only for abbreviated_type
     *  Top level types are always fully expanded
     * </pre>
     *
     * <code>optional int32 type_alias_name = 12;</code>
     * @return the typeAliasName
     */
    public int getTypeAliasName() {
      return typeAliasName;
    }

    /**
     * <pre>
     *  Note that this may be present only for abbreviated_type
     *  Top level types are always fully expanded
     * </pre>
     *
     * <code>optional int32 type_alias_name = 12;</code>
     * @param value the typeAliasName to set
     * @return this
     */
    public Type setTypeAliasName(final int value) {
      bitField0_ |= 0x00000080;
      typeAliasName = value;
      return this;
    }

    /**
     * <code>optional int32 abbreviated_type_id = 14;</code>
     * @return whether the abbreviatedTypeId field is set
     */
    public boolean hasAbbreviatedTypeId() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional int32 abbreviated_type_id = 14;</code>
     * @return this
     */
    public Type clearAbbreviatedTypeId() {
      bitField0_ &= ~0x00000100;
      abbreviatedTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 abbreviated_type_id = 14;</code>
     * @return the abbreviatedTypeId
     */
    public int getAbbreviatedTypeId() {
      return abbreviatedTypeId;
    }

    /**
     * <code>optional int32 abbreviated_type_id = 14;</code>
     * @param value the abbreviatedTypeId to set
     * @return this
     */
    public Type setAbbreviatedTypeId(final int value) {
      bitField0_ |= 0x00000100;
      abbreviatedTypeId = value;
      return this;
    }

    /**
     * <code>optional bool nullable = 3 [default = false];</code>
     * @return whether the nullable field is set
     */
    public boolean hasNullable() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional bool nullable = 3 [default = false];</code>
     * @return this
     */
    public Type clearNullable() {
      bitField0_ &= ~0x00000200;
      nullable = false;
      return this;
    }

    /**
     * <code>optional bool nullable = 3 [default = false];</code>
     * @return the nullable
     */
    public boolean getNullable() {
      return nullable;
    }

    /**
     * <code>optional bool nullable = 3 [default = false];</code>
     * @param value the nullable to set
     * @return this
     */
    public Type setNullable(final boolean value) {
      bitField0_ |= 0x00000200;
      nullable = value;
      return this;
    }

    private void initFlexibleUpperBound() {
      if (flexibleUpperBound == null) {
        flexibleUpperBound = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type flexible_upper_bound = 5;</code>
     * @return whether the flexibleUpperBound field is set
     */
    public boolean hasFlexibleUpperBound() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type flexible_upper_bound = 5;</code>
     * @return this
     */
    public Type clearFlexibleUpperBound() {
      bitField0_ &= ~0x00000400;
      if (flexibleUpperBound != null) {
        flexibleUpperBound.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type flexible_upper_bound = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFlexibleUpperBound()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getFlexibleUpperBound() {
      initFlexibleUpperBound();
      return flexibleUpperBound;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type flexible_upper_bound = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableFlexibleUpperBound() {
      initFlexibleUpperBound();
      bitField0_ |= 0x00000400;
      return flexibleUpperBound;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type flexible_upper_bound = 5;</code>
     * @param value the flexibleUpperBound to set
     * @return this
     */
    public Type setFlexibleUpperBound(final Type value) {
      initFlexibleUpperBound();
      bitField0_ |= 0x00000400;
      flexibleUpperBound.copyFrom(value);
      return this;
    }

    private void initOuterType() {
      if (outerType == null) {
        outerType = Type.newInstance();
      }
    }

    /**
     * <pre>
     *  Outer type may be present only if class_name or type_alias_name is present
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type outer_type = 10;</code>
     * @return whether the outerType field is set
     */
    public boolean hasOuterType() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <pre>
     *  Outer type may be present only if class_name or type_alias_name is present
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type outer_type = 10;</code>
     * @return this
     */
    public Type clearOuterType() {
      bitField0_ &= ~0x00000800;
      if (outerType != null) {
        outerType.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  Outer type may be present only if class_name or type_alias_name is present
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type outer_type = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOuterType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getOuterType() {
      initOuterType();
      return outerType;
    }

    /**
     * <pre>
     *  Outer type may be present only if class_name or type_alias_name is present
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type outer_type = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableOuterType() {
      initOuterType();
      bitField0_ |= 0x00000800;
      return outerType;
    }

    /**
     * <pre>
     *  Outer type may be present only if class_name or type_alias_name is present
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type outer_type = 10;</code>
     * @param value the outerType to set
     * @return this
     */
    public Type setOuterType(final Type value) {
      initOuterType();
      bitField0_ |= 0x00000800;
      outerType.copyFrom(value);
      return this;
    }

    private void initAbbreviatedType() {
      if (abbreviatedType == null) {
        abbreviatedType = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type abbreviated_type = 13;</code>
     * @return whether the abbreviatedType field is set
     */
    public boolean hasAbbreviatedType() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type abbreviated_type = 13;</code>
     * @return this
     */
    public Type clearAbbreviatedType() {
      bitField0_ &= ~0x00001000;
      if (abbreviatedType != null) {
        abbreviatedType.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type abbreviated_type = 13;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAbbreviatedType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getAbbreviatedType() {
      initAbbreviatedType();
      return abbreviatedType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type abbreviated_type = 13;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableAbbreviatedType() {
      initAbbreviatedType();
      bitField0_ |= 0x00001000;
      return abbreviatedType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type abbreviated_type = 13;</code>
     * @param value the abbreviatedType to set
     * @return this
     */
    public Type setAbbreviatedType(final Type value) {
      initAbbreviatedType();
      bitField0_ |= 0x00001000;
      abbreviatedType.copyFrom(value);
      return this;
    }

    private void initArgument() {
      if (argument == null) {
        argument = RepeatedMessage.newEmptyInstance(Argument.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type.Argument argument = 2;</code>
     * @return whether the argument field is set
     */
    public boolean hasArgument() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type.Argument argument = 2;</code>
     * @return this
     */
    public Type clearArgument() {
      bitField0_ &= ~0x00002000;
      if (argument != null) {
        argument.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type.Argument argument = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableArgument()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Argument> getArgument() {
      initArgument();
      return argument;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type.Argument argument = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Argument> getMutableArgument() {
      initArgument();
      bitField0_ |= 0x00002000;
      return argument;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type.Argument argument = 2;</code>
     * @param value the argument to add
     * @return this
     */
    public Type addArgument(final Argument value) {
      initArgument();
      bitField0_ |= 0x00002000;
      argument.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type.Argument argument = 2;</code>
     * @param values the argument to add
     * @return this
     */
    public Type addAllArgument(final Argument... values) {
      initArgument();
      bitField0_ |= 0x00002000;
      argument.addAll(values);
      return this;
    }

    @Override
    public Type copyFrom(final Type other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        flags = other.flags;
        flexibleTypeCapabilitiesId = other.flexibleTypeCapabilitiesId;
        className = other.className;
        typeParameter = other.typeParameter;
        flexibleUpperBoundId = other.flexibleUpperBoundId;
        typeParameterName = other.typeParameterName;
        outerTypeId = other.outerTypeId;
        typeAliasName = other.typeAliasName;
        abbreviatedTypeId = other.abbreviatedTypeId;
        nullable = other.nullable;
        if (other.hasFlexibleUpperBound()) {
          initFlexibleUpperBound();
          flexibleUpperBound.copyFrom(other.flexibleUpperBound);
        } else {
          clearFlexibleUpperBound();
        }
        if (other.hasOuterType()) {
          initOuterType();
          outerType.copyFrom(other.outerType);
        } else {
          clearOuterType();
        }
        if (other.hasAbbreviatedType()) {
          initAbbreviatedType();
          abbreviatedType.copyFrom(other.abbreviatedType);
        } else {
          clearAbbreviatedType();
        }
        if (other.hasArgument()) {
          initArgument();
          argument.copyFrom(other.argument);
        } else {
          clearArgument();
        }
      }
      return this;
    }

    @Override
    public Type mergeFrom(final Type other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFlags()) {
        setFlags(other.flags);
      }
      if (other.hasFlexibleTypeCapabilitiesId()) {
        setFlexibleTypeCapabilitiesId(other.flexibleTypeCapabilitiesId);
      }
      if (other.hasClassName()) {
        setClassName(other.className);
      }
      if (other.hasTypeParameter()) {
        setTypeParameter(other.typeParameter);
      }
      if (other.hasFlexibleUpperBoundId()) {
        setFlexibleUpperBoundId(other.flexibleUpperBoundId);
      }
      if (other.hasTypeParameterName()) {
        setTypeParameterName(other.typeParameterName);
      }
      if (other.hasOuterTypeId()) {
        setOuterTypeId(other.outerTypeId);
      }
      if (other.hasTypeAliasName()) {
        setTypeAliasName(other.typeAliasName);
      }
      if (other.hasAbbreviatedTypeId()) {
        setAbbreviatedTypeId(other.abbreviatedTypeId);
      }
      if (other.hasNullable()) {
        setNullable(other.nullable);
      }
      if (other.hasFlexibleUpperBound()) {
        getMutableFlexibleUpperBound().mergeFrom(other.flexibleUpperBound);
      }
      if (other.hasOuterType()) {
        getMutableOuterType().mergeFrom(other.outerType);
      }
      if (other.hasAbbreviatedType()) {
        getMutableAbbreviatedType().mergeFrom(other.abbreviatedType);
      }
      if (other.hasArgument()) {
        getMutableArgument().addAll(other.argument);
      }
      return this;
    }

    @Override
    public Type clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flags = 0;
      flexibleTypeCapabilitiesId = 0;
      className = 0;
      typeParameter = 0;
      flexibleUpperBoundId = 0;
      typeParameterName = 0;
      outerTypeId = 0;
      typeAliasName = 0;
      abbreviatedTypeId = 0;
      nullable = false;
      if (flexibleUpperBound != null) {
        flexibleUpperBound.clear();
      }
      if (outerType != null) {
        outerType.clear();
      }
      if (abbreviatedType != null) {
        abbreviatedType.clear();
      }
      if (argument != null) {
        argument.clear();
      }
      return this;
    }

    @Override
    public Type clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (flexibleUpperBound != null) {
        flexibleUpperBound.clearQuick();
      }
      if (outerType != null) {
        outerType.clearQuick();
      }
      if (abbreviatedType != null) {
        abbreviatedType.clearQuick();
      }
      if (argument != null) {
        argument.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Type)) {
        return false;
      }
      Type other = (Type) o;
      return bitField0_ == other.bitField0_
        && (!hasFlags() || flags == other.flags)
        && (!hasFlexibleTypeCapabilitiesId() || flexibleTypeCapabilitiesId == other.flexibleTypeCapabilitiesId)
        && (!hasClassName() || className == other.className)
        && (!hasTypeParameter() || typeParameter == other.typeParameter)
        && (!hasFlexibleUpperBoundId() || flexibleUpperBoundId == other.flexibleUpperBoundId)
        && (!hasTypeParameterName() || typeParameterName == other.typeParameterName)
        && (!hasOuterTypeId() || outerTypeId == other.outerTypeId)
        && (!hasTypeAliasName() || typeAliasName == other.typeAliasName)
        && (!hasAbbreviatedTypeId() || abbreviatedTypeId == other.abbreviatedTypeId)
        && (!hasNullable() || nullable == other.nullable)
        && (!hasFlexibleUpperBound() || flexibleUpperBound.equals(other.flexibleUpperBound))
        && (!hasOuterType() || outerType.equals(other.outerType))
        && (!hasAbbreviatedType() || abbreviatedType.equals(other.abbreviatedType))
        && (!hasArgument() || argument.equals(other.argument));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(flags);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt32NoTag(flexibleTypeCapabilitiesId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 48);
        output.writeInt32NoTag(className);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 56);
        output.writeInt32NoTag(typeParameter);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 64);
        output.writeInt32NoTag(flexibleUpperBoundId);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 72);
        output.writeInt32NoTag(typeParameterName);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 88);
        output.writeInt32NoTag(outerTypeId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 96);
        output.writeInt32NoTag(typeAliasName);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 112);
        output.writeInt32NoTag(abbreviatedTypeId);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(nullable);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 42);
        output.writeMessageNoTag(flexibleUpperBound);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawByte((byte) 82);
        output.writeMessageNoTag(outerType);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRawByte((byte) 106);
        output.writeMessageNoTag(abbreviatedType);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        for (int i = 0; i < argument.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(argument.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(flags);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(flexibleTypeCapabilitiesId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(className);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(typeParameter);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(flexibleUpperBoundId);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(typeParameterName);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(outerTypeId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(typeAliasName);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(abbreviatedTypeId);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(flexibleUpperBound);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(outerType);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(abbreviatedType);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        size += (1 * argument.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(argument);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Type mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // flags
            flags = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // flexibleTypeCapabilitiesId
            flexibleTypeCapabilitiesId = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // className
            className = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // typeParameter
            typeParameter = input.readInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // flexibleUpperBoundId
            flexibleUpperBoundId = input.readInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // typeParameterName
            typeParameterName = input.readInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 88) {
              break;
            }
          }
          case 88: {
            // outerTypeId
            outerTypeId = input.readInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 96) {
              break;
            }
          }
          case 96: {
            // typeAliasName
            typeAliasName = input.readInt32();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // abbreviatedTypeId
            abbreviatedTypeId = input.readInt32();
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // nullable
            nullable = input.readBool();
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // flexibleUpperBound
            initFlexibleUpperBound();
            input.readMessage(flexibleUpperBound);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // outerType
            initOuterType();
            input.readMessage(outerType);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // abbreviatedType
            initAbbreviatedType();
            input.readMessage(abbreviatedType);
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // argument
            initArgument();
            tag = input.readRepeatedMessage(argument, tag);
            bitField0_ |= 0x00002000;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.flags, flags);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt32(FieldNames.flexibleTypeCapabilitiesId, flexibleTypeCapabilitiesId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeInt32(FieldNames.className, className);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeInt32(FieldNames.typeParameter, typeParameter);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeInt32(FieldNames.flexibleUpperBoundId, flexibleUpperBoundId);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeInt32(FieldNames.typeParameterName, typeParameterName);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeInt32(FieldNames.outerTypeId, outerTypeId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeInt32(FieldNames.typeAliasName, typeAliasName);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeInt32(FieldNames.abbreviatedTypeId, abbreviatedTypeId);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeBool(FieldNames.nullable, nullable);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeMessage(FieldNames.flexibleUpperBound, flexibleUpperBound);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeMessage(FieldNames.outerType, outerType);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeMessage(FieldNames.abbreviatedType, abbreviatedType);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeRepeatedMessage(FieldNames.argument, argument);
      }
      output.endObject();
    }

    @Override
    public Type mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 97513095: {
            if (input.isAtField(FieldNames.flags)) {
              if (!input.trySkipNullValue()) {
                flags = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1054622838:
          case -1673505997: {
            if (input.isAtField(FieldNames.flexibleTypeCapabilitiesId)) {
              if (!input.trySkipNullValue()) {
                flexibleTypeCapabilitiesId = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -9888733:
          case -290474766: {
            if (input.isAtField(FieldNames.className)) {
              if (!input.trySkipNullValue()) {
                className = input.readInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 659473807:
          case 1277164772: {
            if (input.isAtField(FieldNames.typeParameter)) {
              if (!input.trySkipNullValue()) {
                typeParameter = input.readInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1954221986:
          case -714622611: {
            if (input.isAtField(FieldNames.flexibleUpperBoundId)) {
              if (!input.trySkipNullValue()) {
                flexibleUpperBoundId = input.readInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1335339846:
          case -16997114: {
            if (input.isAtField(FieldNames.typeParameterName)) {
              if (!input.trySkipNullValue()) {
                typeParameterName = input.readInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2075249072:
          case 667614332: {
            if (input.isAtField(FieldNames.outerTypeId)) {
              if (!input.trySkipNullValue()) {
                outerTypeId = input.readInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 304803553:
          case -1451365057: {
            if (input.isAtField(FieldNames.typeAliasName)) {
              if (!input.trySkipNullValue()) {
                typeAliasName = input.readInt32();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1758969874:
          case -330754406: {
            if (input.isAtField(FieldNames.abbreviatedTypeId)) {
              if (!input.trySkipNullValue()) {
                abbreviatedTypeId = input.readInt32();
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1905967263: {
            if (input.isAtField(FieldNames.nullable)) {
              if (!input.trySkipNullValue()) {
                nullable = input.readBool();
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2022143015:
          case -1858663123: {
            if (input.isAtField(FieldNames.flexibleUpperBound)) {
              if (!input.trySkipNullValue()) {
                initFlexibleUpperBound();
                input.readMessage(flexibleUpperBound);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1857056341:
          case 1744190590: {
            if (input.isAtField(FieldNames.outerType)) {
              if (!input.trySkipNullValue()) {
                initOuterType();
                input.readMessage(outerType);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1830569843:
          case 923109152: {
            if (input.isAtField(FieldNames.abbreviatedType)) {
              if (!input.trySkipNullValue()) {
                initAbbreviatedType();
                input.readMessage(abbreviatedType);
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1589682499: {
            if (input.isAtField(FieldNames.argument)) {
              if (!input.trySkipNullValue()) {
                initArgument();
                input.readRepeatedMessage(argument);
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Type clone() {
      return new Type().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Type parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Type(), data).checkInitialized();
    }

    public static Type parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Type(), input).checkInitialized();
    }

    public static Type parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Type(), input).checkInitialized();
    }

    /**
     * @return factory for creating Type messages
     */
    public static MessageFactory<Type> getFactory() {
      return TypeFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code Argument}
     */
    public static final class Argument extends ProtoMessage<Argument> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional int32 type_id = 3;</code>
       */
      private int typeId;

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.Type.Argument.Projection projection = 1 [default = INV];</code>
       */
      private int projection = org.jetbrains.kotlin.metadata.QuickProtoBuf.Type.Argument.Projection.INV_VALUE;

      /**
       * <pre>
       *  When projection is STAR, no type is written, otherwise type must be specified
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.Type type = 2;</code>
       */
      private Type type = null;

      private Argument() {
      }

      /**
       * @return a new empty instance of {@code Argument}
       */
      public static Argument newInstance() {
        return new Argument();
      }

      /**
       * <code>optional int32 type_id = 3;</code>
       * @return whether the typeId field is set
       */
      public boolean hasTypeId() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional int32 type_id = 3;</code>
       * @return this
       */
      public Argument clearTypeId() {
        bitField0_ &= ~0x00000001;
        typeId = 0;
        return this;
      }

      /**
       * <code>optional int32 type_id = 3;</code>
       * @return the typeId
       */
      public int getTypeId() {
        return typeId;
      }

      /**
       * <code>optional int32 type_id = 3;</code>
       * @param value the typeId to set
       * @return this
       */
      public Argument setTypeId(final int value) {
        bitField0_ |= 0x00000001;
        typeId = value;
        return this;
      }

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.Type.Argument.Projection projection = 1 [default = INV];</code>
       * @return whether the projection field is set
       */
      public boolean hasProjection() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.Type.Argument.Projection projection = 1 [default = INV];</code>
       * @return this
       */
      public Argument clearProjection() {
        bitField0_ &= ~0x00000002;
        projection = org.jetbrains.kotlin.metadata.QuickProtoBuf.Type.Argument.Projection.INV_VALUE;
        return this;
      }

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.Type.Argument.Projection projection = 1 [default = INV];</code>
       * @return the projection
       */
      public Projection getProjection() {
        return Projection.forNumberOr(projection, org.jetbrains.kotlin.metadata.QuickProtoBuf.Type.Argument.Projection.INV);
      }

      /**
       * Gets the value of the internal enum store. The result is
       * equivalent to {@link Argument#getProjection()}.getNumber().
       *
       * @return numeric wire representation
       */
      public int getProjectionValue() {
        return projection;
      }

      /**
       * Sets the value of the internal enum store. This does not
       * do any validity checks, so be sure to use appropriate value
       * constants from {@link Projection}. Setting an invalid value
       * can cause {@link Argument#getProjection()} to return null
       *
       * @param value the numeric wire value to set
       * @return this
       */
      public Argument setProjectionValue(final int value) {
        bitField0_ |= 0x00000002;
        projection = value;
        return this;
      }

      /**
       * <code>optional .org.jetbrains.kotlin.metadata.Type.Argument.Projection projection = 1 [default = INV];</code>
       * @param value the projection to set
       * @return this
       */
      public Argument setProjection(final Projection value) {
        bitField0_ |= 0x00000002;
        projection = value.getNumber();
        return this;
      }

      private void initType() {
        if (type == null) {
          type = Type.newInstance();
        }
      }

      /**
       * <pre>
       *  When projection is STAR, no type is written, otherwise type must be specified
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.Type type = 2;</code>
       * @return whether the type field is set
       */
      public boolean hasType() {
        return (bitField0_ & 0x00000004) != 0;
      }

      /**
       * <pre>
       *  When projection is STAR, no type is written, otherwise type must be specified
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.Type type = 2;</code>
       * @return this
       */
      public Argument clearType() {
        bitField0_ &= ~0x00000004;
        if (type != null) {
          type.clear();
        }
        return this;
      }

      /**
       * <pre>
       *  When projection is STAR, no type is written, otherwise type must be specified
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.Type type = 2;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableType()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public Type getType() {
        initType();
        return type;
      }

      /**
       * <pre>
       *  When projection is STAR, no type is written, otherwise type must be specified
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.Type type = 2;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public Type getMutableType() {
        initType();
        bitField0_ |= 0x00000004;
        return type;
      }

      /**
       * <pre>
       *  When projection is STAR, no type is written, otherwise type must be specified
       * </pre>
       *
       * <code>optional .org.jetbrains.kotlin.metadata.Type type = 2;</code>
       * @param value the type to set
       * @return this
       */
      public Argument setType(final Type value) {
        initType();
        bitField0_ |= 0x00000004;
        type.copyFrom(value);
        return this;
      }

      @Override
      public Argument copyFrom(final Argument other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          typeId = other.typeId;
          projection = other.projection;
          if (other.hasType()) {
            initType();
            type.copyFrom(other.type);
          } else {
            clearType();
          }
        }
        return this;
      }

      @Override
      public Argument mergeFrom(final Argument other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasTypeId()) {
          setTypeId(other.typeId);
        }
        if (other.hasProjection()) {
          setProjectionValue(other.projection);
        }
        if (other.hasType()) {
          getMutableType().mergeFrom(other.type);
        }
        return this;
      }

      @Override
      public Argument clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        typeId = 0;
        projection = org.jetbrains.kotlin.metadata.QuickProtoBuf.Type.Argument.Projection.INV_VALUE;
        if (type != null) {
          type.clear();
        }
        return this;
      }

      @Override
      public Argument clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        if (type != null) {
          type.clearQuick();
        }
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof Argument)) {
          return false;
        }
        Argument other = (Argument) o;
        return bitField0_ == other.bitField0_
          && (!hasTypeId() || typeId == other.typeId)
          && (!hasProjection() || projection == other.projection)
          && (!hasType() || type.equals(other.type));
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 24);
          output.writeInt32NoTag(typeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 8);
          output.writeEnumNoTag(projection);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(type);
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(typeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeEnumSizeNoTag(projection);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(type);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public Argument mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 24: {
              // typeId
              typeId = input.readInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 8) {
                break;
              }
            }
            case 8: {
              // projection
              final int value = input.readInt32();
              if (Projection.forNumber(value) != null) {
                projection = value;
                bitField0_ |= 0x00000002;
              }
              tag = input.readTag();
              if (tag != 18) {
                break;
              }
            }
            case 18: {
              // type
              initType();
              input.readMessage(type);
              bitField0_ |= 0x00000004;
              tag = input.readTag();
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt32(FieldNames.typeId, typeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeEnum(FieldNames.projection, projection, Projection.converter());
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeMessage(FieldNames.type, type);
        }
        output.endObject();
      }

      @Override
      public Argument mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case -858803723:
            case -853090240: {
              if (input.isAtField(FieldNames.typeId)) {
                if (!input.trySkipNullValue()) {
                  typeId = input.readInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -1969960369: {
              if (input.isAtField(FieldNames.projection)) {
                if (!input.trySkipNullValue()) {
                  final Projection value = input.readEnum(Projection.converter());
                  if (value != null) {
                    projection = value.getNumber();
                    bitField0_ |= 0x00000002;
                  } else {
                    input.skipUnknownEnumValue();
                  }
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 3575610: {
              if (input.isAtField(FieldNames.type)) {
                if (!input.trySkipNullValue()) {
                  initType();
                  input.readMessage(type);
                  bitField0_ |= 0x00000004;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public Argument clone() {
        return new Argument().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static Argument parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new Argument(), data).checkInitialized();
      }

      public static Argument parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Argument(), input).checkInitialized();
      }

      public static Argument parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Argument(), input).checkInitialized();
      }

      /**
       * @return factory for creating Argument messages
       */
      public static MessageFactory<Argument> getFactory() {
        return ArgumentFactory.INSTANCE;
      }

      /**
       * Protobuf enum {@code Projection}
       */
      public enum Projection implements ProtoEnum<Projection> {
        /**
         * <code>IN = 0;</code>
         */
        IN("IN", 0),

        /**
         * <code>OUT = 1;</code>
         */
        OUT("OUT", 1),

        /**
         * <code>INV = 2;</code>
         */
        INV("INV", 2),

        /**
         * <code>STAR = 3;</code>
         */
        STAR("STAR", 3);

        /**
         * <code>IN = 0;</code>
         */
        public static final int IN_VALUE = 0;

        /**
         * <code>OUT = 1;</code>
         */
        public static final int OUT_VALUE = 1;

        /**
         * <code>INV = 2;</code>
         */
        public static final int INV_VALUE = 2;

        /**
         * <code>STAR = 3;</code>
         */
        public static final int STAR_VALUE = 3;

        private final String name;

        private final int number;

        private Projection(String name, int number) {
          this.name = name;
          this.number = number;
        }

        /**
         * @return the string representation of enum entry
         */
        @Override
        public String getName() {
          return name;
        }

        /**
         * @return the numeric wire value of this enum entry
         */
        @Override
        public int getNumber() {
          return number;
        }

        /**
         * @return a converter that maps between this enum's numeric and text representations
         */
        public static ProtoEnum.EnumConverter<Projection> converter() {
          return ProjectionConverter.INSTANCE;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value, or null if unknown.
         */
        public static Projection forNumber(int value) {
          return ProjectionConverter.INSTANCE.forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @param other Fallback value in case the value is not known.
         * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
         */
        public static Projection forNumberOr(int number, Projection other) {
          Projection value = forNumber(number);
          return value == null ? other : value;
        }

        enum ProjectionConverter implements ProtoEnum.EnumConverter<Projection> {
          INSTANCE;

          private static final Projection[] lookup = new Projection[4];

          static {
            lookup[0] = IN;
            lookup[1] = OUT;
            lookup[2] = INV;
            lookup[3] = STAR;
          }

          @Override
          public final Projection forNumber(final int value) {
            if (value >= 0 && value < lookup.length) {
              return lookup[value];
            }
            return null;
          }

          @Override
          public final Projection forName(final CharSequence value) {
            if (value.length() == 2) {
              if (ProtoUtil.isEqual("IN", value)) {
                return IN;
              }
            }
            if (value.length() == 3) {
              if (ProtoUtil.isEqual("OUT", value)) {
                return OUT;
              }
              if (ProtoUtil.isEqual("INV", value)) {
                return INV;
              }
            }
            if (value.length() == 4) {
              if (ProtoUtil.isEqual("STAR", value)) {
                return STAR;
              }
            }
            return null;
          }
        }
      }

      private enum ArgumentFactory implements MessageFactory<Argument> {
        INSTANCE;

        @Override
        public Argument create() {
          return Argument.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName typeId = FieldName.forField("typeId", "type_id");

        static final FieldName projection = FieldName.forField("projection");

        static final FieldName type = FieldName.forField("type");
      }
    }

    private enum TypeFactory implements MessageFactory<Type> {
      INSTANCE;

      @Override
      public Type create() {
        return Type.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName flags = FieldName.forField("flags");

      static final FieldName flexibleTypeCapabilitiesId = FieldName.forField("flexibleTypeCapabilitiesId", "flexible_type_capabilities_id");

      static final FieldName className = FieldName.forField("className", "class_name");

      static final FieldName typeParameter = FieldName.forField("typeParameter", "type_parameter");

      static final FieldName flexibleUpperBoundId = FieldName.forField("flexibleUpperBoundId", "flexible_upper_bound_id");

      static final FieldName typeParameterName = FieldName.forField("typeParameterName", "type_parameter_name");

      static final FieldName outerTypeId = FieldName.forField("outerTypeId", "outer_type_id");

      static final FieldName typeAliasName = FieldName.forField("typeAliasName", "type_alias_name");

      static final FieldName abbreviatedTypeId = FieldName.forField("abbreviatedTypeId", "abbreviated_type_id");

      static final FieldName nullable = FieldName.forField("nullable");

      static final FieldName flexibleUpperBound = FieldName.forField("flexibleUpperBound", "flexible_upper_bound");

      static final FieldName outerType = FieldName.forField("outerType", "outer_type");

      static final FieldName abbreviatedType = FieldName.forField("abbreviatedType", "abbreviated_type");

      static final FieldName argument = FieldName.forField("argument");
    }
  }

  /**
   * Protobuf type {@code TypeParameter}
   */
  public static final class TypeParameter extends ProtoMessage<TypeParameter> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>required int32 id = 1;</code>
     */
    private int id;

    /**
     * <code>required int32 name = 2;</code>
     */
    private int name;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeParameter.Variance variance = 4 [default = INV];</code>
     */
    private int variance = org.jetbrains.kotlin.metadata.QuickProtoBuf.TypeParameter.Variance.INV_VALUE;

    /**
     * <code>optional bool reified = 3 [default = false];</code>
     */
    private boolean reified = false;

    /**
     * <code>repeated int32 upper_bound_id = 6 [packed = true];</code>
     */
    private RepeatedInt upperBoundId = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type upper_bound = 5;</code>
     */
    private RepeatedMessage<Type> upperBound = null;

    private TypeParameter() {
    }

    /**
     * @return a new empty instance of {@code TypeParameter}
     */
    public static TypeParameter newInstance() {
      return new TypeParameter();
    }

    /**
     * <code>required int32 id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>required int32 id = 1;</code>
     * @return this
     */
    public TypeParameter clearId() {
      bitField0_ &= ~0x00000010;
      id = 0;
      return this;
    }

    /**
     * <code>required int32 id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>required int32 id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public TypeParameter setId(final int value) {
      bitField0_ |= 0x00000010;
      id = value;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return this
     */
    public TypeParameter clearName() {
      bitField0_ &= ~0x00000020;
      name = 0;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return the name
     */
    public int getName() {
      return name;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @param value the name to set
     * @return this
     */
    public TypeParameter setName(final int value) {
      bitField0_ |= 0x00000020;
      name = value;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeParameter.Variance variance = 4 [default = INV];</code>
     * @return whether the variance field is set
     */
    public boolean hasVariance() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeParameter.Variance variance = 4 [default = INV];</code>
     * @return this
     */
    public TypeParameter clearVariance() {
      bitField0_ &= ~0x00000001;
      variance = org.jetbrains.kotlin.metadata.QuickProtoBuf.TypeParameter.Variance.INV_VALUE;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeParameter.Variance variance = 4 [default = INV];</code>
     * @return the variance
     */
    public Variance getVariance() {
      return Variance.forNumberOr(variance, org.jetbrains.kotlin.metadata.QuickProtoBuf.TypeParameter.Variance.INV);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link TypeParameter#getVariance()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getVarianceValue() {
      return variance;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link Variance}. Setting an invalid value
     * can cause {@link TypeParameter#getVariance()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public TypeParameter setVarianceValue(final int value) {
      bitField0_ |= 0x00000001;
      variance = value;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeParameter.Variance variance = 4 [default = INV];</code>
     * @param value the variance to set
     * @return this
     */
    public TypeParameter setVariance(final Variance value) {
      bitField0_ |= 0x00000001;
      variance = value.getNumber();
      return this;
    }

    /**
     * <code>optional bool reified = 3 [default = false];</code>
     * @return whether the reified field is set
     */
    public boolean hasReified() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool reified = 3 [default = false];</code>
     * @return this
     */
    public TypeParameter clearReified() {
      bitField0_ &= ~0x00000002;
      reified = false;
      return this;
    }

    /**
     * <code>optional bool reified = 3 [default = false];</code>
     * @return the reified
     */
    public boolean getReified() {
      return reified;
    }

    /**
     * <code>optional bool reified = 3 [default = false];</code>
     * @param value the reified to set
     * @return this
     */
    public TypeParameter setReified(final boolean value) {
      bitField0_ |= 0x00000002;
      reified = value;
      return this;
    }

    private void initUpperBoundId() {
      if (upperBoundId == null) {
        upperBoundId = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <code>repeated int32 upper_bound_id = 6 [packed = true];</code>
     * @return whether the upperBoundId field is set
     */
    public boolean hasUpperBoundId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated int32 upper_bound_id = 6 [packed = true];</code>
     * @return this
     */
    public TypeParameter clearUpperBoundId() {
      bitField0_ &= ~0x00000004;
      if (upperBoundId != null) {
        upperBoundId.clear();
      }
      return this;
    }

    /**
     * <code>repeated int32 upper_bound_id = 6 [packed = true];</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableUpperBoundId()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getUpperBoundId() {
      initUpperBoundId();
      return upperBoundId;
    }

    /**
     * <code>repeated int32 upper_bound_id = 6 [packed = true];</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableUpperBoundId() {
      initUpperBoundId();
      bitField0_ |= 0x00000004;
      return upperBoundId;
    }

    /**
     * <code>repeated int32 upper_bound_id = 6 [packed = true];</code>
     * @param value the upperBoundId to add
     * @return this
     */
    public TypeParameter addUpperBoundId(final int value) {
      initUpperBoundId();
      bitField0_ |= 0x00000004;
      upperBoundId.add(value);
      return this;
    }

    /**
     * <code>repeated int32 upper_bound_id = 6 [packed = true];</code>
     * @param values the upperBoundId to add
     * @return this
     */
    public TypeParameter addAllUpperBoundId(final int... values) {
      initUpperBoundId();
      bitField0_ |= 0x00000004;
      upperBoundId.addAll(values);
      return this;
    }

    private void initUpperBound() {
      if (upperBound == null) {
        upperBound = RepeatedMessage.newEmptyInstance(Type.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type upper_bound = 5;</code>
     * @return whether the upperBound field is set
     */
    public boolean hasUpperBound() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type upper_bound = 5;</code>
     * @return this
     */
    public TypeParameter clearUpperBound() {
      bitField0_ &= ~0x00000008;
      if (upperBound != null) {
        upperBound.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type upper_bound = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableUpperBound()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Type> getUpperBound() {
      initUpperBound();
      return upperBound;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type upper_bound = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Type> getMutableUpperBound() {
      initUpperBound();
      bitField0_ |= 0x00000008;
      return upperBound;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type upper_bound = 5;</code>
     * @param value the upperBound to add
     * @return this
     */
    public TypeParameter addUpperBound(final Type value) {
      initUpperBound();
      bitField0_ |= 0x00000008;
      upperBound.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type upper_bound = 5;</code>
     * @param values the upperBound to add
     * @return this
     */
    public TypeParameter addAllUpperBound(final Type... values) {
      initUpperBound();
      bitField0_ |= 0x00000008;
      upperBound.addAll(values);
      return this;
    }

    @Override
    public TypeParameter copyFrom(final TypeParameter other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        name = other.name;
        variance = other.variance;
        reified = other.reified;
        if (other.hasUpperBoundId()) {
          initUpperBoundId();
          upperBoundId.copyFrom(other.upperBoundId);
        } else {
          clearUpperBoundId();
        }
        if (other.hasUpperBound()) {
          initUpperBound();
          upperBound.copyFrom(other.upperBound);
        } else {
          clearUpperBound();
        }
      }
      return this;
    }

    @Override
    public TypeParameter mergeFrom(final TypeParameter other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasName()) {
        setName(other.name);
      }
      if (other.hasVariance()) {
        setVarianceValue(other.variance);
      }
      if (other.hasReified()) {
        setReified(other.reified);
      }
      if (other.hasUpperBoundId()) {
        getMutableUpperBoundId().addAll(other.upperBoundId);
      }
      if (other.hasUpperBound()) {
        getMutableUpperBound().addAll(other.upperBound);
      }
      return this;
    }

    @Override
    public TypeParameter clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      name = 0;
      variance = org.jetbrains.kotlin.metadata.QuickProtoBuf.TypeParameter.Variance.INV_VALUE;
      reified = false;
      if (upperBoundId != null) {
        upperBoundId.clear();
      }
      if (upperBound != null) {
        upperBound.clear();
      }
      return this;
    }

    @Override
    public TypeParameter clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (upperBoundId != null) {
        upperBoundId.clear();
      }
      if (upperBound != null) {
        upperBound.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TypeParameter)) {
        return false;
      }
      TypeParameter other = (TypeParameter) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasName() || name == other.name)
        && (!hasVariance() || variance == other.variance)
        && (!hasReified() || reified == other.reified)
        && (!hasUpperBoundId() || upperBoundId.equals(other.upperBoundId))
        && (!hasUpperBound() || upperBound.equals(other.upperBound));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000030) != 0x00000030))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(id);
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 32);
          output.writeEnumNoTag(variance);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 24);
          output.writeBoolNoTag(reified);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 50);
          output.writePackedInt32NoTag(upperBoundId);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          for (int i = 0; i < upperBound.length(); i++) {
            output.writeRawByte((byte) 42);
            output.writeMessageNoTag(upperBound.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000030) != 0x00000030))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        size += 1 + ProtoSink.computeInt32SizeNoTag(id);
        size += 1 + ProtoSink.computeInt32SizeNoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeEnumSizeNoTag(variance);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 2;
        }
        if ((bitField0_ & 0x00000004) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(upperBoundId);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += (1 * upperBound.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(upperBound);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TypeParameter mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // name
            name = input.readInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // variance
            final int value = input.readInt32();
            if (Variance.forNumber(value) != null) {
              variance = value;
              bitField0_ |= 0x00000001;
            }
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // reified
            reified = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // upperBoundId [packed=true]
            initUpperBoundId();
            input.readPackedInt32(upperBoundId, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // upperBound
            initUpperBound();
            tag = input.readRepeatedMessage(upperBound, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 48: {
            // upperBoundId [packed=false]
            initUpperBoundId();
            tag = input.readRepeatedInt32(upperBoundId, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000030) != 0x00000030))) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasId()) {
        results.add(prefix + "id");
      }
      if (!hasName()) {
        results.add(prefix + "name");
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000030) != 0x00000030))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        output.writeInt32(FieldNames.id, id);
        output.writeInt32(FieldNames.name, name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeEnum(FieldNames.variance, variance, Variance.converter());
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeBool(FieldNames.reified, reified);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRepeatedInt32(FieldNames.upperBoundId, upperBoundId);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRepeatedMessage(FieldNames.upperBound, upperBound);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public TypeParameter mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3355: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3373707: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                name = input.readInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1249575311: {
            if (input.isAtField(FieldNames.variance)) {
              if (!input.trySkipNullValue()) {
                final Variance value = input.readEnum(Variance.converter());
                if (value != null) {
                  variance = value.getNumber();
                  bitField0_ |= 0x00000001;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1087861304: {
            if (input.isAtField(FieldNames.reified)) {
              if (!input.trySkipNullValue()) {
                reified = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1324384201:
          case -5812615: {
            if (input.isAtField(FieldNames.upperBoundId)) {
              if (!input.trySkipNullValue()) {
                initUpperBoundId();
                input.readRepeatedInt32(upperBoundId);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1690761732:
          case -55938143: {
            if (input.isAtField(FieldNames.upperBound)) {
              if (!input.trySkipNullValue()) {
                initUpperBound();
                input.readRepeatedMessage(upperBound);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TypeParameter clone() {
      return new TypeParameter().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TypeParameter parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TypeParameter(), data).checkInitialized();
    }

    public static TypeParameter parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TypeParameter(), input).checkInitialized();
    }

    public static TypeParameter parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TypeParameter(), input).checkInitialized();
    }

    /**
     * @return factory for creating TypeParameter messages
     */
    public static MessageFactory<TypeParameter> getFactory() {
      return TypeParameterFactory.INSTANCE;
    }

    /**
     * Protobuf enum {@code Variance}
     */
    public enum Variance implements ProtoEnum<Variance> {
      /**
       * <code>IN = 0;</code>
       */
      IN("IN", 0),

      /**
       * <code>OUT = 1;</code>
       */
      OUT("OUT", 1),

      /**
       * <code>INV = 2;</code>
       */
      INV("INV", 2);

      /**
       * <code>IN = 0;</code>
       */
      public static final int IN_VALUE = 0;

      /**
       * <code>OUT = 1;</code>
       */
      public static final int OUT_VALUE = 1;

      /**
       * <code>INV = 2;</code>
       */
      public static final int INV_VALUE = 2;

      private final String name;

      private final int number;

      private Variance(String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<Variance> converter() {
        return VarianceConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static Variance forNumber(int value) {
        return VarianceConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static Variance forNumberOr(int number, Variance other) {
        Variance value = forNumber(number);
        return value == null ? other : value;
      }

      enum VarianceConverter implements ProtoEnum.EnumConverter<Variance> {
        INSTANCE;

        private static final Variance[] lookup = new Variance[3];

        static {
          lookup[0] = IN;
          lookup[1] = OUT;
          lookup[2] = INV;
        }

        @Override
        public final Variance forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final Variance forName(final CharSequence value) {
          if (value.length() == 2) {
            if (ProtoUtil.isEqual("IN", value)) {
              return IN;
            }
          }
          if (value.length() == 3) {
            if (ProtoUtil.isEqual("OUT", value)) {
              return OUT;
            }
            if (ProtoUtil.isEqual("INV", value)) {
              return INV;
            }
          }
          return null;
        }
      }
    }

    private enum TypeParameterFactory implements MessageFactory<TypeParameter> {
      INSTANCE;

      @Override
      public TypeParameter create() {
        return TypeParameter.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("id");

      static final FieldName name = FieldName.forField("name");

      static final FieldName variance = FieldName.forField("variance");

      static final FieldName reified = FieldName.forField("reified");

      static final FieldName upperBoundId = FieldName.forField("upperBoundId", "upper_bound_id");

      static final FieldName upperBound = FieldName.forField("upperBound", "upper_bound");
    }
  }

  /**
   * Protobuf type {@code Class}
   */
  public static final class Class extends ProtoMessage<Class> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     */
    private int flags = 6;

    /**
     * <code>required int32 fq_name = 3;</code>
     */
    private int fqName;

    /**
     * <code>optional int32 companion_object_name = 4;</code>
     */
    private int companionObjectName;

    /**
     * <code>optional int32 inline_class_underlying_property_name = 17;</code>
     */
    private int inlineClassUnderlyingPropertyName;

    /**
     * <code>optional int32 inline_class_underlying_type_id = 19;</code>
     */
    private int inlineClassUnderlyingTypeId;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type inline_class_underlying_type = 18;</code>
     */
    private Type inlineClassUnderlyingType = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     */
    private TypeTable typeTable = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     */
    private VersionRequirementTable versionRequirementTable = null;

    /**
     * <code>repeated int32 supertype_id = 2 [packed = true];</code>
     */
    private RepeatedInt supertypeId = null;

    /**
     * <code>repeated int32 nested_class_name = 7 [packed = true];</code>
     */
    private RepeatedInt nestedClassName = null;

    /**
     * <code>repeated int32 sealed_subclass_fq_name = 16 [packed = true];</code>
     */
    private RepeatedInt sealedSubclassFqName = null;

    /**
     * <code>repeated int32 context_receiver_type_id = 21 [packed = true];</code>
     */
    private RepeatedInt contextReceiverTypeId = null;

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     */
    private RepeatedInt versionRequirement = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 5;</code>
     */
    private RepeatedMessage<TypeParameter> typeParameter = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type supertype = 6;</code>
     */
    private RepeatedMessage<Type> supertype = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Constructor constructor = 8;</code>
     */
    private RepeatedMessage<Constructor> constructor = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 9;</code>
     */
    private RepeatedMessage<Function> function = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 10;</code>
     */
    private RepeatedMessage<Property> property = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 11;</code>
     */
    private RepeatedMessage<TypeAlias> typeAlias = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.EnumEntry enum_entry = 13;</code>
     */
    private RepeatedMessage<EnumEntry> enumEntry = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 20;</code>
     */
    private RepeatedMessage<Type> contextReceiverType = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 25;</code>
     */
    private RepeatedMessage<Annotation> annotation = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     */
    private RepeatedMessage<CompilerPluginData> compilerPluginData = null;

    private Class() {
    }

    /**
     * @return a new empty instance of {@code Class}
     */
    public static Class newInstance() {
      return new Class();
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @return whether the flags field is set
     */
    public boolean hasFlags() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @return this
     */
    public Class clearFlags() {
      bitField0_ &= ~0x00002000;
      flags = 6;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @return the flags
     */
    public int getFlags() {
      return flags;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @param value the flags to set
     * @return this
     */
    public Class setFlags(final int value) {
      bitField0_ |= 0x00002000;
      flags = value;
      return this;
    }

    /**
     * <code>required int32 fq_name = 3;</code>
     * @return whether the fqName field is set
     */
    public boolean hasFqName() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>required int32 fq_name = 3;</code>
     * @return this
     */
    public Class clearFqName() {
      bitField0_ &= ~0x00001000;
      fqName = 0;
      return this;
    }

    /**
     * <code>required int32 fq_name = 3;</code>
     * @return the fqName
     */
    public int getFqName() {
      return fqName;
    }

    /**
     * <code>required int32 fq_name = 3;</code>
     * @param value the fqName to set
     * @return this
     */
    public Class setFqName(final int value) {
      bitField0_ |= 0x00001000;
      fqName = value;
      return this;
    }

    /**
     * <code>optional int32 companion_object_name = 4;</code>
     * @return whether the companionObjectName field is set
     */
    public boolean hasCompanionObjectName() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 companion_object_name = 4;</code>
     * @return this
     */
    public Class clearCompanionObjectName() {
      bitField0_ &= ~0x00000001;
      companionObjectName = 0;
      return this;
    }

    /**
     * <code>optional int32 companion_object_name = 4;</code>
     * @return the companionObjectName
     */
    public int getCompanionObjectName() {
      return companionObjectName;
    }

    /**
     * <code>optional int32 companion_object_name = 4;</code>
     * @param value the companionObjectName to set
     * @return this
     */
    public Class setCompanionObjectName(final int value) {
      bitField0_ |= 0x00000001;
      companionObjectName = value;
      return this;
    }

    /**
     * <code>optional int32 inline_class_underlying_property_name = 17;</code>
     * @return whether the inlineClassUnderlyingPropertyName field is set
     */
    public boolean hasInlineClassUnderlyingPropertyName() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int32 inline_class_underlying_property_name = 17;</code>
     * @return this
     */
    public Class clearInlineClassUnderlyingPropertyName() {
      bitField0_ &= ~0x00000002;
      inlineClassUnderlyingPropertyName = 0;
      return this;
    }

    /**
     * <code>optional int32 inline_class_underlying_property_name = 17;</code>
     * @return the inlineClassUnderlyingPropertyName
     */
    public int getInlineClassUnderlyingPropertyName() {
      return inlineClassUnderlyingPropertyName;
    }

    /**
     * <code>optional int32 inline_class_underlying_property_name = 17;</code>
     * @param value the inlineClassUnderlyingPropertyName to set
     * @return this
     */
    public Class setInlineClassUnderlyingPropertyName(final int value) {
      bitField0_ |= 0x00000002;
      inlineClassUnderlyingPropertyName = value;
      return this;
    }

    /**
     * <code>optional int32 inline_class_underlying_type_id = 19;</code>
     * @return whether the inlineClassUnderlyingTypeId field is set
     */
    public boolean hasInlineClassUnderlyingTypeId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional int32 inline_class_underlying_type_id = 19;</code>
     * @return this
     */
    public Class clearInlineClassUnderlyingTypeId() {
      bitField0_ &= ~0x00000004;
      inlineClassUnderlyingTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 inline_class_underlying_type_id = 19;</code>
     * @return the inlineClassUnderlyingTypeId
     */
    public int getInlineClassUnderlyingTypeId() {
      return inlineClassUnderlyingTypeId;
    }

    /**
     * <code>optional int32 inline_class_underlying_type_id = 19;</code>
     * @param value the inlineClassUnderlyingTypeId to set
     * @return this
     */
    public Class setInlineClassUnderlyingTypeId(final int value) {
      bitField0_ |= 0x00000004;
      inlineClassUnderlyingTypeId = value;
      return this;
    }

    private void initInlineClassUnderlyingType() {
      if (inlineClassUnderlyingType == null) {
        inlineClassUnderlyingType = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type inline_class_underlying_type = 18;</code>
     * @return whether the inlineClassUnderlyingType field is set
     */
    public boolean hasInlineClassUnderlyingType() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type inline_class_underlying_type = 18;</code>
     * @return this
     */
    public Class clearInlineClassUnderlyingType() {
      bitField0_ &= ~0x00004000;
      if (inlineClassUnderlyingType != null) {
        inlineClassUnderlyingType.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type inline_class_underlying_type = 18;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInlineClassUnderlyingType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getInlineClassUnderlyingType() {
      initInlineClassUnderlyingType();
      return inlineClassUnderlyingType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type inline_class_underlying_type = 18;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableInlineClassUnderlyingType() {
      initInlineClassUnderlyingType();
      bitField0_ |= 0x00004000;
      return inlineClassUnderlyingType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type inline_class_underlying_type = 18;</code>
     * @param value the inlineClassUnderlyingType to set
     * @return this
     */
    public Class setInlineClassUnderlyingType(final Type value) {
      initInlineClassUnderlyingType();
      bitField0_ |= 0x00004000;
      inlineClassUnderlyingType.copyFrom(value);
      return this;
    }

    private void initTypeTable() {
      if (typeTable == null) {
        typeTable = TypeTable.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     * @return whether the typeTable field is set
     */
    public boolean hasTypeTable() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     * @return this
     */
    public Class clearTypeTable() {
      bitField0_ &= ~0x00000008;
      if (typeTable != null) {
        typeTable.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypeTable()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public TypeTable getTypeTable() {
      initTypeTable();
      return typeTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public TypeTable getMutableTypeTable() {
      initTypeTable();
      bitField0_ |= 0x00000008;
      return typeTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     * @param value the typeTable to set
     * @return this
     */
    public Class setTypeTable(final TypeTable value) {
      initTypeTable();
      bitField0_ |= 0x00000008;
      typeTable.copyFrom(value);
      return this;
    }

    private void initVersionRequirementTable() {
      if (versionRequirementTable == null) {
        versionRequirementTable = VersionRequirementTable.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     * @return whether the versionRequirementTable field is set
     */
    public boolean hasVersionRequirementTable() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     * @return this
     */
    public Class clearVersionRequirementTable() {
      bitField0_ &= ~0x00008000;
      if (versionRequirementTable != null) {
        versionRequirementTable.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVersionRequirementTable()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public VersionRequirementTable getVersionRequirementTable() {
      initVersionRequirementTable();
      return versionRequirementTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public VersionRequirementTable getMutableVersionRequirementTable() {
      initVersionRequirementTable();
      bitField0_ |= 0x00008000;
      return versionRequirementTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     * @param value the versionRequirementTable to set
     * @return this
     */
    public Class setVersionRequirementTable(final VersionRequirementTable value) {
      initVersionRequirementTable();
      bitField0_ |= 0x00008000;
      versionRequirementTable.copyFrom(value);
      return this;
    }

    private void initSupertypeId() {
      if (supertypeId == null) {
        supertypeId = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <code>repeated int32 supertype_id = 2 [packed = true];</code>
     * @return whether the supertypeId field is set
     */
    public boolean hasSupertypeId() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated int32 supertype_id = 2 [packed = true];</code>
     * @return this
     */
    public Class clearSupertypeId() {
      bitField0_ &= ~0x00000010;
      if (supertypeId != null) {
        supertypeId.clear();
      }
      return this;
    }

    /**
     * <code>repeated int32 supertype_id = 2 [packed = true];</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSupertypeId()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getSupertypeId() {
      initSupertypeId();
      return supertypeId;
    }

    /**
     * <code>repeated int32 supertype_id = 2 [packed = true];</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableSupertypeId() {
      initSupertypeId();
      bitField0_ |= 0x00000010;
      return supertypeId;
    }

    /**
     * <code>repeated int32 supertype_id = 2 [packed = true];</code>
     * @param value the supertypeId to add
     * @return this
     */
    public Class addSupertypeId(final int value) {
      initSupertypeId();
      bitField0_ |= 0x00000010;
      supertypeId.add(value);
      return this;
    }

    /**
     * <code>repeated int32 supertype_id = 2 [packed = true];</code>
     * @param values the supertypeId to add
     * @return this
     */
    public Class addAllSupertypeId(final int... values) {
      initSupertypeId();
      bitField0_ |= 0x00000010;
      supertypeId.addAll(values);
      return this;
    }

    private void initNestedClassName() {
      if (nestedClassName == null) {
        nestedClassName = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <code>repeated int32 nested_class_name = 7 [packed = true];</code>
     * @return whether the nestedClassName field is set
     */
    public boolean hasNestedClassName() {
      return (bitField0_ & 0x00010000) != 0;
    }

    /**
     * <code>repeated int32 nested_class_name = 7 [packed = true];</code>
     * @return this
     */
    public Class clearNestedClassName() {
      bitField0_ &= ~0x00010000;
      if (nestedClassName != null) {
        nestedClassName.clear();
      }
      return this;
    }

    /**
     * <code>repeated int32 nested_class_name = 7 [packed = true];</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNestedClassName()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getNestedClassName() {
      initNestedClassName();
      return nestedClassName;
    }

    /**
     * <code>repeated int32 nested_class_name = 7 [packed = true];</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableNestedClassName() {
      initNestedClassName();
      bitField0_ |= 0x00010000;
      return nestedClassName;
    }

    /**
     * <code>repeated int32 nested_class_name = 7 [packed = true];</code>
     * @param value the nestedClassName to add
     * @return this
     */
    public Class addNestedClassName(final int value) {
      initNestedClassName();
      bitField0_ |= 0x00010000;
      nestedClassName.add(value);
      return this;
    }

    /**
     * <code>repeated int32 nested_class_name = 7 [packed = true];</code>
     * @param values the nestedClassName to add
     * @return this
     */
    public Class addAllNestedClassName(final int... values) {
      initNestedClassName();
      bitField0_ |= 0x00010000;
      nestedClassName.addAll(values);
      return this;
    }

    private void initSealedSubclassFqName() {
      if (sealedSubclassFqName == null) {
        sealedSubclassFqName = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <code>repeated int32 sealed_subclass_fq_name = 16 [packed = true];</code>
     * @return whether the sealedSubclassFqName field is set
     */
    public boolean hasSealedSubclassFqName() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated int32 sealed_subclass_fq_name = 16 [packed = true];</code>
     * @return this
     */
    public Class clearSealedSubclassFqName() {
      bitField0_ &= ~0x00000020;
      if (sealedSubclassFqName != null) {
        sealedSubclassFqName.clear();
      }
      return this;
    }

    /**
     * <code>repeated int32 sealed_subclass_fq_name = 16 [packed = true];</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSealedSubclassFqName()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getSealedSubclassFqName() {
      initSealedSubclassFqName();
      return sealedSubclassFqName;
    }

    /**
     * <code>repeated int32 sealed_subclass_fq_name = 16 [packed = true];</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableSealedSubclassFqName() {
      initSealedSubclassFqName();
      bitField0_ |= 0x00000020;
      return sealedSubclassFqName;
    }

    /**
     * <code>repeated int32 sealed_subclass_fq_name = 16 [packed = true];</code>
     * @param value the sealedSubclassFqName to add
     * @return this
     */
    public Class addSealedSubclassFqName(final int value) {
      initSealedSubclassFqName();
      bitField0_ |= 0x00000020;
      sealedSubclassFqName.add(value);
      return this;
    }

    /**
     * <code>repeated int32 sealed_subclass_fq_name = 16 [packed = true];</code>
     * @param values the sealedSubclassFqName to add
     * @return this
     */
    public Class addAllSealedSubclassFqName(final int... values) {
      initSealedSubclassFqName();
      bitField0_ |= 0x00000020;
      sealedSubclassFqName.addAll(values);
      return this;
    }

    private void initContextReceiverTypeId() {
      if (contextReceiverTypeId == null) {
        contextReceiverTypeId = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 21 [packed = true];</code>
     * @return whether the contextReceiverTypeId field is set
     */
    public boolean hasContextReceiverTypeId() {
      return (bitField0_ & 0x00020000) != 0;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 21 [packed = true];</code>
     * @return this
     */
    public Class clearContextReceiverTypeId() {
      bitField0_ &= ~0x00020000;
      if (contextReceiverTypeId != null) {
        contextReceiverTypeId.clear();
      }
      return this;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 21 [packed = true];</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContextReceiverTypeId()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getContextReceiverTypeId() {
      initContextReceiverTypeId();
      return contextReceiverTypeId;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 21 [packed = true];</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableContextReceiverTypeId() {
      initContextReceiverTypeId();
      bitField0_ |= 0x00020000;
      return contextReceiverTypeId;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 21 [packed = true];</code>
     * @param value the contextReceiverTypeId to add
     * @return this
     */
    public Class addContextReceiverTypeId(final int value) {
      initContextReceiverTypeId();
      bitField0_ |= 0x00020000;
      contextReceiverTypeId.add(value);
      return this;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 21 [packed = true];</code>
     * @param values the contextReceiverTypeId to add
     * @return this
     */
    public Class addAllContextReceiverTypeId(final int... values) {
      initContextReceiverTypeId();
      bitField0_ |= 0x00020000;
      contextReceiverTypeId.addAll(values);
      return this;
    }

    private void initVersionRequirement() {
      if (versionRequirement == null) {
        versionRequirement = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return whether the versionRequirement field is set
     */
    public boolean hasVersionRequirement() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return this
     */
    public Class clearVersionRequirement() {
      bitField0_ &= ~0x00000040;
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVersionRequirement()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getVersionRequirement() {
      initVersionRequirement();
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableVersionRequirement() {
      initVersionRequirement();
      bitField0_ |= 0x00000040;
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param value the versionRequirement to add
     * @return this
     */
    public Class addVersionRequirement(final int value) {
      initVersionRequirement();
      bitField0_ |= 0x00000040;
      versionRequirement.add(value);
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param values the versionRequirement to add
     * @return this
     */
    public Class addAllVersionRequirement(final int... values) {
      initVersionRequirement();
      bitField0_ |= 0x00000040;
      versionRequirement.addAll(values);
      return this;
    }

    private void initTypeParameter() {
      if (typeParameter == null) {
        typeParameter = RepeatedMessage.newEmptyInstance(TypeParameter.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 5;</code>
     * @return whether the typeParameter field is set
     */
    public boolean hasTypeParameter() {
      return (bitField0_ & 0x00040000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 5;</code>
     * @return this
     */
    public Class clearTypeParameter() {
      bitField0_ &= ~0x00040000;
      if (typeParameter != null) {
        typeParameter.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypeParameter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<TypeParameter> getTypeParameter() {
      initTypeParameter();
      return typeParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<TypeParameter> getMutableTypeParameter() {
      initTypeParameter();
      bitField0_ |= 0x00040000;
      return typeParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 5;</code>
     * @param value the typeParameter to add
     * @return this
     */
    public Class addTypeParameter(final TypeParameter value) {
      initTypeParameter();
      bitField0_ |= 0x00040000;
      typeParameter.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 5;</code>
     * @param values the typeParameter to add
     * @return this
     */
    public Class addAllTypeParameter(final TypeParameter... values) {
      initTypeParameter();
      bitField0_ |= 0x00040000;
      typeParameter.addAll(values);
      return this;
    }

    private void initSupertype() {
      if (supertype == null) {
        supertype = RepeatedMessage.newEmptyInstance(Type.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type supertype = 6;</code>
     * @return whether the supertype field is set
     */
    public boolean hasSupertype() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type supertype = 6;</code>
     * @return this
     */
    public Class clearSupertype() {
      bitField0_ &= ~0x00000080;
      if (supertype != null) {
        supertype.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type supertype = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSupertype()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Type> getSupertype() {
      initSupertype();
      return supertype;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type supertype = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Type> getMutableSupertype() {
      initSupertype();
      bitField0_ |= 0x00000080;
      return supertype;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type supertype = 6;</code>
     * @param value the supertype to add
     * @return this
     */
    public Class addSupertype(final Type value) {
      initSupertype();
      bitField0_ |= 0x00000080;
      supertype.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type supertype = 6;</code>
     * @param values the supertype to add
     * @return this
     */
    public Class addAllSupertype(final Type... values) {
      initSupertype();
      bitField0_ |= 0x00000080;
      supertype.addAll(values);
      return this;
    }

    private void initConstructor() {
      if (constructor == null) {
        constructor = RepeatedMessage.newEmptyInstance(Constructor.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Constructor constructor = 8;</code>
     * @return whether the constructor field is set
     */
    public boolean hasConstructor() {
      return (bitField0_ & 0x00080000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Constructor constructor = 8;</code>
     * @return this
     */
    public Class clearConstructor() {
      bitField0_ &= ~0x00080000;
      if (constructor != null) {
        constructor.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Constructor constructor = 8;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableConstructor()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Constructor> getConstructor() {
      initConstructor();
      return constructor;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Constructor constructor = 8;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Constructor> getMutableConstructor() {
      initConstructor();
      bitField0_ |= 0x00080000;
      return constructor;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Constructor constructor = 8;</code>
     * @param value the constructor to add
     * @return this
     */
    public Class addConstructor(final Constructor value) {
      initConstructor();
      bitField0_ |= 0x00080000;
      constructor.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Constructor constructor = 8;</code>
     * @param values the constructor to add
     * @return this
     */
    public Class addAllConstructor(final Constructor... values) {
      initConstructor();
      bitField0_ |= 0x00080000;
      constructor.addAll(values);
      return this;
    }

    private void initFunction() {
      if (function == null) {
        function = RepeatedMessage.newEmptyInstance(Function.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 9;</code>
     * @return whether the function field is set
     */
    public boolean hasFunction() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 9;</code>
     * @return this
     */
    public Class clearFunction() {
      bitField0_ &= ~0x00000100;
      if (function != null) {
        function.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 9;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFunction()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Function> getFunction() {
      initFunction();
      return function;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 9;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Function> getMutableFunction() {
      initFunction();
      bitField0_ |= 0x00000100;
      return function;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 9;</code>
     * @param value the function to add
     * @return this
     */
    public Class addFunction(final Function value) {
      initFunction();
      bitField0_ |= 0x00000100;
      function.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 9;</code>
     * @param values the function to add
     * @return this
     */
    public Class addAllFunction(final Function... values) {
      initFunction();
      bitField0_ |= 0x00000100;
      function.addAll(values);
      return this;
    }

    private void initProperty() {
      if (property == null) {
        property = RepeatedMessage.newEmptyInstance(Property.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 10;</code>
     * @return whether the property field is set
     */
    public boolean hasProperty() {
      return (bitField0_ & 0x00100000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 10;</code>
     * @return this
     */
    public Class clearProperty() {
      bitField0_ &= ~0x00100000;
      if (property != null) {
        property.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableProperty()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Property> getProperty() {
      initProperty();
      return property;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Property> getMutableProperty() {
      initProperty();
      bitField0_ |= 0x00100000;
      return property;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 10;</code>
     * @param value the property to add
     * @return this
     */
    public Class addProperty(final Property value) {
      initProperty();
      bitField0_ |= 0x00100000;
      property.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 10;</code>
     * @param values the property to add
     * @return this
     */
    public Class addAllProperty(final Property... values) {
      initProperty();
      bitField0_ |= 0x00100000;
      property.addAll(values);
      return this;
    }

    private void initTypeAlias() {
      if (typeAlias == null) {
        typeAlias = RepeatedMessage.newEmptyInstance(TypeAlias.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 11;</code>
     * @return whether the typeAlias field is set
     */
    public boolean hasTypeAlias() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 11;</code>
     * @return this
     */
    public Class clearTypeAlias() {
      bitField0_ &= ~0x00000200;
      if (typeAlias != null) {
        typeAlias.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypeAlias()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<TypeAlias> getTypeAlias() {
      initTypeAlias();
      return typeAlias;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<TypeAlias> getMutableTypeAlias() {
      initTypeAlias();
      bitField0_ |= 0x00000200;
      return typeAlias;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 11;</code>
     * @param value the typeAlias to add
     * @return this
     */
    public Class addTypeAlias(final TypeAlias value) {
      initTypeAlias();
      bitField0_ |= 0x00000200;
      typeAlias.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 11;</code>
     * @param values the typeAlias to add
     * @return this
     */
    public Class addAllTypeAlias(final TypeAlias... values) {
      initTypeAlias();
      bitField0_ |= 0x00000200;
      typeAlias.addAll(values);
      return this;
    }

    private void initEnumEntry() {
      if (enumEntry == null) {
        enumEntry = RepeatedMessage.newEmptyInstance(EnumEntry.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.EnumEntry enum_entry = 13;</code>
     * @return whether the enumEntry field is set
     */
    public boolean hasEnumEntry() {
      return (bitField0_ & 0x00200000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.EnumEntry enum_entry = 13;</code>
     * @return this
     */
    public Class clearEnumEntry() {
      bitField0_ &= ~0x00200000;
      if (enumEntry != null) {
        enumEntry.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.EnumEntry enum_entry = 13;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEnumEntry()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<EnumEntry> getEnumEntry() {
      initEnumEntry();
      return enumEntry;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.EnumEntry enum_entry = 13;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<EnumEntry> getMutableEnumEntry() {
      initEnumEntry();
      bitField0_ |= 0x00200000;
      return enumEntry;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.EnumEntry enum_entry = 13;</code>
     * @param value the enumEntry to add
     * @return this
     */
    public Class addEnumEntry(final EnumEntry value) {
      initEnumEntry();
      bitField0_ |= 0x00200000;
      enumEntry.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.EnumEntry enum_entry = 13;</code>
     * @param values the enumEntry to add
     * @return this
     */
    public Class addAllEnumEntry(final EnumEntry... values) {
      initEnumEntry();
      bitField0_ |= 0x00200000;
      enumEntry.addAll(values);
      return this;
    }

    private void initContextReceiverType() {
      if (contextReceiverType == null) {
        contextReceiverType = RepeatedMessage.newEmptyInstance(Type.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 20;</code>
     * @return whether the contextReceiverType field is set
     */
    public boolean hasContextReceiverType() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 20;</code>
     * @return this
     */
    public Class clearContextReceiverType() {
      bitField0_ &= ~0x00000400;
      if (contextReceiverType != null) {
        contextReceiverType.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 20;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContextReceiverType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Type> getContextReceiverType() {
      initContextReceiverType();
      return contextReceiverType;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 20;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Type> getMutableContextReceiverType() {
      initContextReceiverType();
      bitField0_ |= 0x00000400;
      return contextReceiverType;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 20;</code>
     * @param value the contextReceiverType to add
     * @return this
     */
    public Class addContextReceiverType(final Type value) {
      initContextReceiverType();
      bitField0_ |= 0x00000400;
      contextReceiverType.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 20;</code>
     * @param values the contextReceiverType to add
     * @return this
     */
    public Class addAllContextReceiverType(final Type... values) {
      initContextReceiverType();
      bitField0_ |= 0x00000400;
      contextReceiverType.addAll(values);
      return this;
    }

    private void initAnnotation() {
      if (annotation == null) {
        annotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 25;</code>
     * @return whether the annotation field is set
     */
    public boolean hasAnnotation() {
      return (bitField0_ & 0x00400000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 25;</code>
     * @return this
     */
    public Class clearAnnotation() {
      bitField0_ &= ~0x00400000;
      if (annotation != null) {
        annotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 25;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getAnnotation() {
      initAnnotation();
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 25;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableAnnotation() {
      initAnnotation();
      bitField0_ |= 0x00400000;
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 25;</code>
     * @param value the annotation to add
     * @return this
     */
    public Class addAnnotation(final Annotation value) {
      initAnnotation();
      bitField0_ |= 0x00400000;
      annotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 25;</code>
     * @param values the annotation to add
     * @return this
     */
    public Class addAllAnnotation(final Annotation... values) {
      initAnnotation();
      bitField0_ |= 0x00400000;
      annotation.addAll(values);
      return this;
    }

    private void initCompilerPluginData() {
      if (compilerPluginData == null) {
        compilerPluginData = RepeatedMessage.newEmptyInstance(CompilerPluginData.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     * @return whether the compilerPluginData field is set
     */
    public boolean hasCompilerPluginData() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     * @return this
     */
    public Class clearCompilerPluginData() {
      bitField0_ &= ~0x00000800;
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCompilerPluginData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CompilerPluginData> getCompilerPluginData() {
      initCompilerPluginData();
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CompilerPluginData> getMutableCompilerPluginData() {
      initCompilerPluginData();
      bitField0_ |= 0x00000800;
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     * @param value the compilerPluginData to add
     * @return this
     */
    public Class addCompilerPluginData(final CompilerPluginData value) {
      initCompilerPluginData();
      bitField0_ |= 0x00000800;
      compilerPluginData.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     * @param values the compilerPluginData to add
     * @return this
     */
    public Class addAllCompilerPluginData(final CompilerPluginData... values) {
      initCompilerPluginData();
      bitField0_ |= 0x00000800;
      compilerPluginData.addAll(values);
      return this;
    }

    @Override
    public Class copyFrom(final Class other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        flags = other.flags;
        fqName = other.fqName;
        companionObjectName = other.companionObjectName;
        inlineClassUnderlyingPropertyName = other.inlineClassUnderlyingPropertyName;
        inlineClassUnderlyingTypeId = other.inlineClassUnderlyingTypeId;
        if (other.hasInlineClassUnderlyingType()) {
          initInlineClassUnderlyingType();
          inlineClassUnderlyingType.copyFrom(other.inlineClassUnderlyingType);
        } else {
          clearInlineClassUnderlyingType();
        }
        if (other.hasTypeTable()) {
          initTypeTable();
          typeTable.copyFrom(other.typeTable);
        } else {
          clearTypeTable();
        }
        if (other.hasVersionRequirementTable()) {
          initVersionRequirementTable();
          versionRequirementTable.copyFrom(other.versionRequirementTable);
        } else {
          clearVersionRequirementTable();
        }
        if (other.hasSupertypeId()) {
          initSupertypeId();
          supertypeId.copyFrom(other.supertypeId);
        } else {
          clearSupertypeId();
        }
        if (other.hasNestedClassName()) {
          initNestedClassName();
          nestedClassName.copyFrom(other.nestedClassName);
        } else {
          clearNestedClassName();
        }
        if (other.hasSealedSubclassFqName()) {
          initSealedSubclassFqName();
          sealedSubclassFqName.copyFrom(other.sealedSubclassFqName);
        } else {
          clearSealedSubclassFqName();
        }
        if (other.hasContextReceiverTypeId()) {
          initContextReceiverTypeId();
          contextReceiverTypeId.copyFrom(other.contextReceiverTypeId);
        } else {
          clearContextReceiverTypeId();
        }
        if (other.hasVersionRequirement()) {
          initVersionRequirement();
          versionRequirement.copyFrom(other.versionRequirement);
        } else {
          clearVersionRequirement();
        }
        if (other.hasTypeParameter()) {
          initTypeParameter();
          typeParameter.copyFrom(other.typeParameter);
        } else {
          clearTypeParameter();
        }
        if (other.hasSupertype()) {
          initSupertype();
          supertype.copyFrom(other.supertype);
        } else {
          clearSupertype();
        }
        if (other.hasConstructor()) {
          initConstructor();
          constructor.copyFrom(other.constructor);
        } else {
          clearConstructor();
        }
        if (other.hasFunction()) {
          initFunction();
          function.copyFrom(other.function);
        } else {
          clearFunction();
        }
        if (other.hasProperty()) {
          initProperty();
          property.copyFrom(other.property);
        } else {
          clearProperty();
        }
        if (other.hasTypeAlias()) {
          initTypeAlias();
          typeAlias.copyFrom(other.typeAlias);
        } else {
          clearTypeAlias();
        }
        if (other.hasEnumEntry()) {
          initEnumEntry();
          enumEntry.copyFrom(other.enumEntry);
        } else {
          clearEnumEntry();
        }
        if (other.hasContextReceiverType()) {
          initContextReceiverType();
          contextReceiverType.copyFrom(other.contextReceiverType);
        } else {
          clearContextReceiverType();
        }
        if (other.hasAnnotation()) {
          initAnnotation();
          annotation.copyFrom(other.annotation);
        } else {
          clearAnnotation();
        }
        if (other.hasCompilerPluginData()) {
          initCompilerPluginData();
          compilerPluginData.copyFrom(other.compilerPluginData);
        } else {
          clearCompilerPluginData();
        }
      }
      return this;
    }

    @Override
    public Class mergeFrom(final Class other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFlags()) {
        setFlags(other.flags);
      }
      if (other.hasFqName()) {
        setFqName(other.fqName);
      }
      if (other.hasCompanionObjectName()) {
        setCompanionObjectName(other.companionObjectName);
      }
      if (other.hasInlineClassUnderlyingPropertyName()) {
        setInlineClassUnderlyingPropertyName(other.inlineClassUnderlyingPropertyName);
      }
      if (other.hasInlineClassUnderlyingTypeId()) {
        setInlineClassUnderlyingTypeId(other.inlineClassUnderlyingTypeId);
      }
      if (other.hasInlineClassUnderlyingType()) {
        getMutableInlineClassUnderlyingType().mergeFrom(other.inlineClassUnderlyingType);
      }
      if (other.hasTypeTable()) {
        getMutableTypeTable().mergeFrom(other.typeTable);
      }
      if (other.hasVersionRequirementTable()) {
        getMutableVersionRequirementTable().mergeFrom(other.versionRequirementTable);
      }
      if (other.hasSupertypeId()) {
        getMutableSupertypeId().addAll(other.supertypeId);
      }
      if (other.hasNestedClassName()) {
        getMutableNestedClassName().addAll(other.nestedClassName);
      }
      if (other.hasSealedSubclassFqName()) {
        getMutableSealedSubclassFqName().addAll(other.sealedSubclassFqName);
      }
      if (other.hasContextReceiverTypeId()) {
        getMutableContextReceiverTypeId().addAll(other.contextReceiverTypeId);
      }
      if (other.hasVersionRequirement()) {
        getMutableVersionRequirement().addAll(other.versionRequirement);
      }
      if (other.hasTypeParameter()) {
        getMutableTypeParameter().addAll(other.typeParameter);
      }
      if (other.hasSupertype()) {
        getMutableSupertype().addAll(other.supertype);
      }
      if (other.hasConstructor()) {
        getMutableConstructor().addAll(other.constructor);
      }
      if (other.hasFunction()) {
        getMutableFunction().addAll(other.function);
      }
      if (other.hasProperty()) {
        getMutableProperty().addAll(other.property);
      }
      if (other.hasTypeAlias()) {
        getMutableTypeAlias().addAll(other.typeAlias);
      }
      if (other.hasEnumEntry()) {
        getMutableEnumEntry().addAll(other.enumEntry);
      }
      if (other.hasContextReceiverType()) {
        getMutableContextReceiverType().addAll(other.contextReceiverType);
      }
      if (other.hasAnnotation()) {
        getMutableAnnotation().addAll(other.annotation);
      }
      if (other.hasCompilerPluginData()) {
        getMutableCompilerPluginData().addAll(other.compilerPluginData);
      }
      return this;
    }

    @Override
    public Class clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flags = 6;
      fqName = 0;
      companionObjectName = 0;
      inlineClassUnderlyingPropertyName = 0;
      inlineClassUnderlyingTypeId = 0;
      if (inlineClassUnderlyingType != null) {
        inlineClassUnderlyingType.clear();
      }
      if (typeTable != null) {
        typeTable.clear();
      }
      if (versionRequirementTable != null) {
        versionRequirementTable.clear();
      }
      if (supertypeId != null) {
        supertypeId.clear();
      }
      if (nestedClassName != null) {
        nestedClassName.clear();
      }
      if (sealedSubclassFqName != null) {
        sealedSubclassFqName.clear();
      }
      if (contextReceiverTypeId != null) {
        contextReceiverTypeId.clear();
      }
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (typeParameter != null) {
        typeParameter.clear();
      }
      if (supertype != null) {
        supertype.clear();
      }
      if (constructor != null) {
        constructor.clear();
      }
      if (function != null) {
        function.clear();
      }
      if (property != null) {
        property.clear();
      }
      if (typeAlias != null) {
        typeAlias.clear();
      }
      if (enumEntry != null) {
        enumEntry.clear();
      }
      if (contextReceiverType != null) {
        contextReceiverType.clear();
      }
      if (annotation != null) {
        annotation.clear();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      return this;
    }

    @Override
    public Class clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (inlineClassUnderlyingType != null) {
        inlineClassUnderlyingType.clearQuick();
      }
      if (typeTable != null) {
        typeTable.clearQuick();
      }
      if (versionRequirementTable != null) {
        versionRequirementTable.clearQuick();
      }
      if (supertypeId != null) {
        supertypeId.clear();
      }
      if (nestedClassName != null) {
        nestedClassName.clear();
      }
      if (sealedSubclassFqName != null) {
        sealedSubclassFqName.clear();
      }
      if (contextReceiverTypeId != null) {
        contextReceiverTypeId.clear();
      }
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (typeParameter != null) {
        typeParameter.clearQuick();
      }
      if (supertype != null) {
        supertype.clearQuick();
      }
      if (constructor != null) {
        constructor.clearQuick();
      }
      if (function != null) {
        function.clearQuick();
      }
      if (property != null) {
        property.clearQuick();
      }
      if (typeAlias != null) {
        typeAlias.clearQuick();
      }
      if (enumEntry != null) {
        enumEntry.clearQuick();
      }
      if (contextReceiverType != null) {
        contextReceiverType.clearQuick();
      }
      if (annotation != null) {
        annotation.clearQuick();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Class)) {
        return false;
      }
      Class other = (Class) o;
      return bitField0_ == other.bitField0_
        && (!hasFlags() || flags == other.flags)
        && (!hasFqName() || fqName == other.fqName)
        && (!hasCompanionObjectName() || companionObjectName == other.companionObjectName)
        && (!hasInlineClassUnderlyingPropertyName() || inlineClassUnderlyingPropertyName == other.inlineClassUnderlyingPropertyName)
        && (!hasInlineClassUnderlyingTypeId() || inlineClassUnderlyingTypeId == other.inlineClassUnderlyingTypeId)
        && (!hasInlineClassUnderlyingType() || inlineClassUnderlyingType.equals(other.inlineClassUnderlyingType))
        && (!hasTypeTable() || typeTable.equals(other.typeTable))
        && (!hasVersionRequirementTable() || versionRequirementTable.equals(other.versionRequirementTable))
        && (!hasSupertypeId() || supertypeId.equals(other.supertypeId))
        && (!hasNestedClassName() || nestedClassName.equals(other.nestedClassName))
        && (!hasSealedSubclassFqName() || sealedSubclassFqName.equals(other.sealedSubclassFqName))
        && (!hasContextReceiverTypeId() || contextReceiverTypeId.equals(other.contextReceiverTypeId))
        && (!hasVersionRequirement() || versionRequirement.equals(other.versionRequirement))
        && (!hasTypeParameter() || typeParameter.equals(other.typeParameter))
        && (!hasSupertype() || supertype.equals(other.supertype))
        && (!hasConstructor() || constructor.equals(other.constructor))
        && (!hasFunction() || function.equals(other.function))
        && (!hasProperty() || property.equals(other.property))
        && (!hasTypeAlias() || typeAlias.equals(other.typeAlias))
        && (!hasEnumEntry() || enumEntry.equals(other.enumEntry))
        && (!hasContextReceiverType() || contextReceiverType.equals(other.contextReceiverType))
        && (!hasAnnotation() || annotation.equals(other.annotation))
        && (!hasCompilerPluginData() || compilerPluginData.equals(other.compilerPluginData));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00001000) != 0x00001000))) {
        throw new UninitializedMessageException(this);
      }
      try {
        if ((bitField0_ & 0x00002000) != 0) {
          output.writeRawByte((byte) 8);
          output.writeInt32NoTag(flags);
        }
        output.writeRawByte((byte) 24);
        output.writeInt32NoTag(fqName);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 32);
          output.writeInt32NoTag(companionObjectName);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawLittleEndian16((short) 392);
          output.writeInt32NoTag(inlineClassUnderlyingPropertyName);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawLittleEndian16((short) 408);
          output.writeInt32NoTag(inlineClassUnderlyingTypeId);
        }
        if ((bitField0_ & 0x00004000) != 0) {
          output.writeRawLittleEndian16((short) 402);
          output.writeMessageNoTag(inlineClassUnderlyingType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRawLittleEndian16((short) 498);
          output.writeMessageNoTag(typeTable);
        }
        if ((bitField0_ & 0x00008000) != 0) {
          output.writeRawLittleEndian16((short) 642);
          output.writeMessageNoTag(versionRequirementTable);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRawByte((byte) 18);
          output.writePackedInt32NoTag(supertypeId);
        }
        if ((bitField0_ & 0x00010000) != 0) {
          output.writeRawByte((byte) 58);
          output.writePackedInt32NoTag(nestedClassName);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRawLittleEndian16((short) 386);
          output.writePackedInt32NoTag(sealedSubclassFqName);
        }
        if ((bitField0_ & 0x00020000) != 0) {
          output.writeRawLittleEndian16((short) 426);
          output.writePackedInt32NoTag(contextReceiverTypeId);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          for (int i = 0; i < versionRequirement.length(); i++) {
            output.writeRawLittleEndian16((short) 504);
            output.writeInt32NoTag(versionRequirement.array()[i]);
          }
        }
        if ((bitField0_ & 0x00040000) != 0) {
          for (int i = 0; i < typeParameter.length(); i++) {
            output.writeRawByte((byte) 42);
            output.writeMessageNoTag(typeParameter.get(i));
          }
        }
        if ((bitField0_ & 0x00000080) != 0) {
          for (int i = 0; i < supertype.length(); i++) {
            output.writeRawByte((byte) 50);
            output.writeMessageNoTag(supertype.get(i));
          }
        }
        if ((bitField0_ & 0x00080000) != 0) {
          for (int i = 0; i < constructor.length(); i++) {
            output.writeRawByte((byte) 66);
            output.writeMessageNoTag(constructor.get(i));
          }
        }
        if ((bitField0_ & 0x00000100) != 0) {
          for (int i = 0; i < function.length(); i++) {
            output.writeRawByte((byte) 74);
            output.writeMessageNoTag(function.get(i));
          }
        }
        if ((bitField0_ & 0x00100000) != 0) {
          for (int i = 0; i < property.length(); i++) {
            output.writeRawByte((byte) 82);
            output.writeMessageNoTag(property.get(i));
          }
        }
        if ((bitField0_ & 0x00000200) != 0) {
          for (int i = 0; i < typeAlias.length(); i++) {
            output.writeRawByte((byte) 90);
            output.writeMessageNoTag(typeAlias.get(i));
          }
        }
        if ((bitField0_ & 0x00200000) != 0) {
          for (int i = 0; i < enumEntry.length(); i++) {
            output.writeRawByte((byte) 106);
            output.writeMessageNoTag(enumEntry.get(i));
          }
        }
        if ((bitField0_ & 0x00000400) != 0) {
          for (int i = 0; i < contextReceiverType.length(); i++) {
            output.writeRawLittleEndian16((short) 418);
            output.writeMessageNoTag(contextReceiverType.get(i));
          }
        }
        if ((bitField0_ & 0x00400000) != 0) {
          for (int i = 0; i < annotation.length(); i++) {
            output.writeRawLittleEndian16((short) 458);
            output.writeMessageNoTag(annotation.get(i));
          }
        }
        if ((bitField0_ & 0x00000800) != 0) {
          for (int i = 0; i < compilerPluginData.length(); i++) {
            output.writeRawLittleEndian16((short) 650);
            output.writeMessageNoTag(compilerPluginData.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00001000) != 0x00001000))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        if ((bitField0_ & 0x00002000) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(flags);
        }
        size += 1 + ProtoSink.computeInt32SizeNoTag(fqName);
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(companionObjectName);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 2 + ProtoSink.computeInt32SizeNoTag(inlineClassUnderlyingPropertyName);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 2 + ProtoSink.computeInt32SizeNoTag(inlineClassUnderlyingTypeId);
        }
        if ((bitField0_ & 0x00004000) != 0) {
          size += 2 + ProtoSink.computeMessageSizeNoTag(inlineClassUnderlyingType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += 2 + ProtoSink.computeMessageSizeNoTag(typeTable);
        }
        if ((bitField0_ & 0x00008000) != 0) {
          size += 2 + ProtoSink.computeMessageSizeNoTag(versionRequirementTable);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(supertypeId);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00010000) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(nestedClassName);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(sealedSubclassFqName);
          size += 2 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00020000) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(contextReceiverTypeId);
          size += 2 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          size += (2 * versionRequirement.length()) + ProtoSink.computeRepeatedInt32SizeNoTag(versionRequirement);
        }
        if ((bitField0_ & 0x00040000) != 0) {
          size += (1 * typeParameter.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(typeParameter);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          size += (1 * supertype.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(supertype);
        }
        if ((bitField0_ & 0x00080000) != 0) {
          size += (1 * constructor.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(constructor);
        }
        if ((bitField0_ & 0x00000100) != 0) {
          size += (1 * function.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(function);
        }
        if ((bitField0_ & 0x00100000) != 0) {
          size += (1 * property.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(property);
        }
        if ((bitField0_ & 0x00000200) != 0) {
          size += (1 * typeAlias.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(typeAlias);
        }
        if ((bitField0_ & 0x00200000) != 0) {
          size += (1 * enumEntry.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(enumEntry);
        }
        if ((bitField0_ & 0x00000400) != 0) {
          size += (2 * contextReceiverType.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(contextReceiverType);
        }
        if ((bitField0_ & 0x00400000) != 0) {
          size += (2 * annotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(annotation);
        }
        if ((bitField0_ & 0x00000800) != 0) {
          size += (2 * compilerPluginData.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(compilerPluginData);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Class mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // flags
            flags = input.readInt32();
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // fqName
            fqName = input.readInt32();
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // companionObjectName
            companionObjectName = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 136) {
              break;
            }
          }
          case 136: {
            // inlineClassUnderlyingPropertyName
            inlineClassUnderlyingPropertyName = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 152) {
              break;
            }
          }
          case 152: {
            // inlineClassUnderlyingTypeId
            inlineClassUnderlyingTypeId = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 146) {
              break;
            }
          }
          case 146: {
            // inlineClassUnderlyingType
            initInlineClassUnderlyingType();
            input.readMessage(inlineClassUnderlyingType);
            bitField0_ |= 0x00004000;
            tag = input.readTag();
            if (tag != 242) {
              break;
            }
          }
          case 242: {
            // typeTable
            initTypeTable();
            input.readMessage(typeTable);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 258) {
              break;
            }
          }
          case 258: {
            // versionRequirementTable
            initVersionRequirementTable();
            input.readMessage(versionRequirementTable);
            bitField0_ |= 0x00008000;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // supertypeId [packed=true]
            initSupertypeId();
            input.readPackedInt32(supertypeId, tag);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // nestedClassName [packed=true]
            initNestedClassName();
            input.readPackedInt32(nestedClassName, tag);
            bitField0_ |= 0x00010000;
            tag = input.readTag();
            if (tag != 130) {
              break;
            }
          }
          case 130: {
            // sealedSubclassFqName [packed=true]
            initSealedSubclassFqName();
            input.readPackedInt32(sealedSubclassFqName, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 170) {
              break;
            }
          }
          case 170: {
            // contextReceiverTypeId [packed=true]
            initContextReceiverTypeId();
            input.readPackedInt32(contextReceiverTypeId, tag);
            bitField0_ |= 0x00020000;
            tag = input.readTag();
            if (tag != 250) {
              break;
            }
          }
          case 250: {
            // versionRequirement [packed=true]
            initVersionRequirement();
            input.readPackedInt32(versionRequirement, tag);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // typeParameter
            initTypeParameter();
            tag = input.readRepeatedMessage(typeParameter, tag);
            bitField0_ |= 0x00040000;
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // supertype
            initSupertype();
            tag = input.readRepeatedMessage(supertype, tag);
            bitField0_ |= 0x00000080;
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            // constructor
            initConstructor();
            tag = input.readRepeatedMessage(constructor, tag);
            bitField0_ |= 0x00080000;
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // function
            initFunction();
            tag = input.readRepeatedMessage(function, tag);
            bitField0_ |= 0x00000100;
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // property
            initProperty();
            tag = input.readRepeatedMessage(property, tag);
            bitField0_ |= 0x00100000;
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // typeAlias
            initTypeAlias();
            tag = input.readRepeatedMessage(typeAlias, tag);
            bitField0_ |= 0x00000200;
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // enumEntry
            initEnumEntry();
            tag = input.readRepeatedMessage(enumEntry, tag);
            bitField0_ |= 0x00200000;
            if (tag != 162) {
              break;
            }
          }
          case 162: {
            // contextReceiverType
            initContextReceiverType();
            tag = input.readRepeatedMessage(contextReceiverType, tag);
            bitField0_ |= 0x00000400;
            if (tag != 202) {
              break;
            }
          }
          case 202: {
            // annotation
            initAnnotation();
            tag = input.readRepeatedMessage(annotation, tag);
            bitField0_ |= 0x00400000;
            if (tag != 266) {
              break;
            }
          }
          case 266: {
            // compilerPluginData
            initCompilerPluginData();
            tag = input.readRepeatedMessage(compilerPluginData, tag);
            bitField0_ |= 0x00000800;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // supertypeId [packed=false]
            initSupertypeId();
            tag = input.readRepeatedInt32(supertypeId, tag);
            bitField0_ |= 0x00000010;
            break;
          }
          case 56: {
            // nestedClassName [packed=false]
            initNestedClassName();
            tag = input.readRepeatedInt32(nestedClassName, tag);
            bitField0_ |= 0x00010000;
            break;
          }
          case 128: {
            // sealedSubclassFqName [packed=false]
            initSealedSubclassFqName();
            tag = input.readRepeatedInt32(sealedSubclassFqName, tag);
            bitField0_ |= 0x00000020;
            break;
          }
          case 168: {
            // contextReceiverTypeId [packed=false]
            initContextReceiverTypeId();
            tag = input.readRepeatedInt32(contextReceiverTypeId, tag);
            bitField0_ |= 0x00020000;
            break;
          }
          case 248: {
            // versionRequirement [packed=false]
            initVersionRequirement();
            tag = input.readRepeatedInt32(versionRequirement, tag);
            bitField0_ |= 0x00000040;
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00001000) != 0x00001000))) {
        return false;
      }
      if (hasTypeParameter() && !typeParameter.isInitialized()) {
        return false;
      }
      if (hasConstructor() && !constructor.isInitialized()) {
        return false;
      }
      if (hasFunction() && !function.isInitialized()) {
        return false;
      }
      if (hasProperty() && !property.isInitialized()) {
        return false;
      }
      if (hasTypeAlias() && !typeAlias.isInitialized()) {
        return false;
      }
      if (hasEnumEntry() && !enumEntry.isInitialized()) {
        return false;
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        return false;
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasFqName()) {
        results.add(prefix + "fq_name");
      }
      if (hasTypeParameter() && !typeParameter.isInitialized()) {
        getMissingFields(prefix, "type_parameter", typeParameter, results);
      }
      if (hasConstructor() && !constructor.isInitialized()) {
        getMissingFields(prefix, "constructor", constructor, results);
      }
      if (hasFunction() && !function.isInitialized()) {
        getMissingFields(prefix, "function", function, results);
      }
      if (hasProperty() && !property.isInitialized()) {
        getMissingFields(prefix, "property", property, results);
      }
      if (hasTypeAlias() && !typeAlias.isInitialized()) {
        getMissingFields(prefix, "type_alias", typeAlias, results);
      }
      if (hasEnumEntry() && !enumEntry.isInitialized()) {
        getMissingFields(prefix, "enum_entry", enumEntry, results);
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        getMissingFields(prefix, "annotation", annotation, results);
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        getMissingFields(prefix, "compiler_plugin_data", compilerPluginData, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00001000) != 0x00001000))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        if ((bitField0_ & 0x00002000) != 0) {
          output.writeInt32(FieldNames.flags, flags);
        }
        output.writeInt32(FieldNames.fqName, fqName);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt32(FieldNames.companionObjectName, companionObjectName);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeInt32(FieldNames.inlineClassUnderlyingPropertyName, inlineClassUnderlyingPropertyName);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeInt32(FieldNames.inlineClassUnderlyingTypeId, inlineClassUnderlyingTypeId);
        }
        if ((bitField0_ & 0x00004000) != 0) {
          output.writeMessage(FieldNames.inlineClassUnderlyingType, inlineClassUnderlyingType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeMessage(FieldNames.typeTable, typeTable);
        }
        if ((bitField0_ & 0x00008000) != 0) {
          output.writeMessage(FieldNames.versionRequirementTable, versionRequirementTable);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRepeatedInt32(FieldNames.supertypeId, supertypeId);
        }
        if ((bitField0_ & 0x00010000) != 0) {
          output.writeRepeatedInt32(FieldNames.nestedClassName, nestedClassName);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRepeatedInt32(FieldNames.sealedSubclassFqName, sealedSubclassFqName);
        }
        if ((bitField0_ & 0x00020000) != 0) {
          output.writeRepeatedInt32(FieldNames.contextReceiverTypeId, contextReceiverTypeId);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          output.writeRepeatedInt32(FieldNames.versionRequirement, versionRequirement);
        }
        if ((bitField0_ & 0x00040000) != 0) {
          output.writeRepeatedMessage(FieldNames.typeParameter, typeParameter);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          output.writeRepeatedMessage(FieldNames.supertype, supertype);
        }
        if ((bitField0_ & 0x00080000) != 0) {
          output.writeRepeatedMessage(FieldNames.constructor, constructor);
        }
        if ((bitField0_ & 0x00000100) != 0) {
          output.writeRepeatedMessage(FieldNames.function, function);
        }
        if ((bitField0_ & 0x00100000) != 0) {
          output.writeRepeatedMessage(FieldNames.property, property);
        }
        if ((bitField0_ & 0x00000200) != 0) {
          output.writeRepeatedMessage(FieldNames.typeAlias, typeAlias);
        }
        if ((bitField0_ & 0x00200000) != 0) {
          output.writeRepeatedMessage(FieldNames.enumEntry, enumEntry);
        }
        if ((bitField0_ & 0x00000400) != 0) {
          output.writeRepeatedMessage(FieldNames.contextReceiverType, contextReceiverType);
        }
        if ((bitField0_ & 0x00400000) != 0) {
          output.writeRepeatedMessage(FieldNames.annotation, annotation);
        }
        if ((bitField0_ & 0x00000800) != 0) {
          output.writeRepeatedMessage(FieldNames.compilerPluginData, compilerPluginData);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Class mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 97513095: {
            if (input.isAtField(FieldNames.flags)) {
              if (!input.trySkipNullValue()) {
                flags = input.readInt32();
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1268015626:
          case -637702785: {
            if (input.isAtField(FieldNames.fqName)) {
              if (!input.trySkipNullValue()) {
                fqName = input.readInt32();
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1071105386:
          case 838520536: {
            if (input.isAtField(FieldNames.companionObjectName)) {
              if (!input.trySkipNullValue()) {
                companionObjectName = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -56612036:
          case -1108819808: {
            if (input.isAtField(FieldNames.inlineClassUnderlyingPropertyName)) {
              if (!input.trySkipNullValue()) {
                inlineClassUnderlyingPropertyName = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1167155151:
          case 793016939: {
            if (input.isAtField(FieldNames.inlineClassUnderlyingTypeId)) {
              if (!input.trySkipNullValue()) {
                inlineClassUnderlyingTypeId = input.readInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -403448714:
          case 1935940847: {
            if (input.isAtField(FieldNames.inlineClassUnderlyingType)) {
              if (!input.trySkipNullValue()) {
                initInlineClassUnderlyingType();
                input.readMessage(inlineClassUnderlyingType);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 508637364:
          case -1079682423: {
            if (input.isAtField(FieldNames.typeTable)) {
              if (!input.trySkipNullValue()) {
                initTypeTable();
                input.readMessage(typeTable);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 284643907:
          case 1372421419: {
            if (input.isAtField(FieldNames.versionRequirementTable)) {
              if (!input.trySkipNullValue()) {
                initVersionRequirementTable();
                input.readMessage(versionRequirementTable);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1117103824:
          case -270458779: {
            if (input.isAtField(FieldNames.supertypeId)) {
              if (!input.trySkipNullValue()) {
                initSupertypeId();
                input.readRepeatedInt32(supertypeId);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -68615956:
          case -1472317126: {
            if (input.isAtField(FieldNames.nestedClassName)) {
              if (!input.trySkipNullValue()) {
                initNestedClassName();
                input.readRepeatedInt32(nestedClassName);
                bitField0_ |= 0x00010000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1196876342:
          case 1120364027: {
            if (input.isAtField(FieldNames.sealedSubclassFqName)) {
              if (!input.trySkipNullValue()) {
                initSealedSubclassFqName();
                input.readRepeatedInt32(sealedSubclassFqName);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -614859693:
          case -769035648: {
            if (input.isAtField(FieldNames.contextReceiverTypeId)) {
              if (!input.trySkipNullValue()) {
                initContextReceiverTypeId();
                input.readRepeatedInt32(contextReceiverTypeId);
                bitField0_ |= 0x00020000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 351760459:
          case -783428772: {
            if (input.isAtField(FieldNames.versionRequirement)) {
              if (!input.trySkipNullValue()) {
                initVersionRequirement();
                input.readRepeatedInt32(versionRequirement);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 659473807:
          case 1277164772: {
            if (input.isAtField(FieldNames.typeParameter)) {
              if (!input.trySkipNullValue()) {
                initTypeParameter();
                input.readRepeatedMessage(typeParameter);
                bitField0_ |= 0x00040000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -331888331: {
            if (input.isAtField(FieldNames.supertype)) {
              if (!input.trySkipNullValue()) {
                initSupertype();
                input.readRepeatedMessage(supertype);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1588406278: {
            if (input.isAtField(FieldNames.constructor)) {
              if (!input.trySkipNullValue()) {
                initConstructor();
                input.readRepeatedMessage(constructor);
                bitField0_ |= 0x00080000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1380938712: {
            if (input.isAtField(FieldNames.function)) {
              if (!input.trySkipNullValue()) {
                initFunction();
                input.readRepeatedMessage(function);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -993141291: {
            if (input.isAtField(FieldNames.property)) {
              if (!input.trySkipNullValue()) {
                initProperty();
                input.readRepeatedMessage(property);
                bitField0_ |= 0x00100000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 491424566:
          case -1096895221: {
            if (input.isAtField(FieldNames.typeAlias)) {
              if (!input.trySkipNullValue()) {
                initTypeAlias();
                input.readRepeatedMessage(typeAlias);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 217742321:
          case -1104053324: {
            if (input.isAtField(FieldNames.enumEntry)) {
              if (!input.trySkipNullValue()) {
                initEnumEntry();
                input.readRepeatedMessage(enumEntry);
                bitField0_ |= 0x00200000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -420751080:
          case 1699161338: {
            if (input.isAtField(FieldNames.contextReceiverType)) {
              if (!input.trySkipNullValue()) {
                initContextReceiverType();
                input.readRepeatedMessage(contextReceiverType);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1555043537: {
            if (input.isAtField(FieldNames.annotation)) {
              if (!input.trySkipNullValue()) {
                initAnnotation();
                input.readRepeatedMessage(annotation);
                bitField0_ |= 0x00400000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1393610620:
          case -1920592490: {
            if (input.isAtField(FieldNames.compilerPluginData)) {
              if (!input.trySkipNullValue()) {
                initCompilerPluginData();
                input.readRepeatedMessage(compilerPluginData);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Class clone() {
      return new Class().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Class parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Class(), data).checkInitialized();
    }

    public static Class parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Class(), input).checkInitialized();
    }

    public static Class parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Class(), input).checkInitialized();
    }

    /**
     * @return factory for creating Class messages
     */
    public static MessageFactory<Class> getFactory() {
      return ClassFactory.INSTANCE;
    }

    /**
     * Protobuf enum {@code Kind}
     */
    public enum Kind implements ProtoEnum<Kind> {
      /**
       * <pre>
       *  3 bits
       * </pre>
       *
       * <code>CLASS = 0;</code>
       */
      CLASS("CLASS", 0),

      /**
       * <code>INTERFACE = 1;</code>
       */
      INTERFACE("INTERFACE", 1),

      /**
       * <code>ENUM_CLASS = 2;</code>
       */
      ENUM_CLASS("ENUM_CLASS", 2),

      /**
       * <code>ENUM_ENTRY = 3;</code>
       */
      ENUM_ENTRY("ENUM_ENTRY", 3),

      /**
       * <code>ANNOTATION_CLASS = 4;</code>
       */
      ANNOTATION_CLASS("ANNOTATION_CLASS", 4),

      /**
       * <code>OBJECT = 5;</code>
       */
      OBJECT("OBJECT", 5),

      /**
       * <code>COMPANION_OBJECT = 6;</code>
       */
      COMPANION_OBJECT("COMPANION_OBJECT", 6);

      /**
       * <pre>
       *  3 bits
       * </pre>
       *
       * <code>CLASS = 0;</code>
       */
      public static final int CLASS_VALUE = 0;

      /**
       * <code>INTERFACE = 1;</code>
       */
      public static final int INTERFACE_VALUE = 1;

      /**
       * <code>ENUM_CLASS = 2;</code>
       */
      public static final int ENUM_CLASS_VALUE = 2;

      /**
       * <code>ENUM_ENTRY = 3;</code>
       */
      public static final int ENUM_ENTRY_VALUE = 3;

      /**
       * <code>ANNOTATION_CLASS = 4;</code>
       */
      public static final int ANNOTATION_CLASS_VALUE = 4;

      /**
       * <code>OBJECT = 5;</code>
       */
      public static final int OBJECT_VALUE = 5;

      /**
       * <code>COMPANION_OBJECT = 6;</code>
       */
      public static final int COMPANION_OBJECT_VALUE = 6;

      private final String name;

      private final int number;

      private Kind(String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<Kind> converter() {
        return KindConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static Kind forNumber(int value) {
        return KindConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static Kind forNumberOr(int number, Kind other) {
        Kind value = forNumber(number);
        return value == null ? other : value;
      }

      enum KindConverter implements ProtoEnum.EnumConverter<Kind> {
        INSTANCE;

        private static final Kind[] lookup = new Kind[7];

        static {
          lookup[0] = CLASS;
          lookup[1] = INTERFACE;
          lookup[2] = ENUM_CLASS;
          lookup[3] = ENUM_ENTRY;
          lookup[4] = ANNOTATION_CLASS;
          lookup[5] = OBJECT;
          lookup[6] = COMPANION_OBJECT;
        }

        @Override
        public final Kind forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final Kind forName(final CharSequence value) {
          switch (value.length()) {
            case 5: {
              if (ProtoUtil.isEqual("CLASS", value)) {
                return CLASS;
              }
              break;
            }
            case 6: {
              if (ProtoUtil.isEqual("OBJECT", value)) {
                return OBJECT;
              }
              break;
            }
            case 9: {
              if (ProtoUtil.isEqual("INTERFACE", value)) {
                return INTERFACE;
              }
              break;
            }
            case 10: {
              if (ProtoUtil.isEqual("ENUM_CLASS", value)) {
                return ENUM_CLASS;
              }
              if (ProtoUtil.isEqual("ENUM_ENTRY", value)) {
                return ENUM_ENTRY;
              }
              break;
            }
            case 16: {
              if (ProtoUtil.isEqual("ANNOTATION_CLASS", value)) {
                return ANNOTATION_CLASS;
              }
              if (ProtoUtil.isEqual("COMPANION_OBJECT", value)) {
                return COMPANION_OBJECT;
              }
              break;
            }
          }
          return null;
        }
      }
    }

    private enum ClassFactory implements MessageFactory<Class> {
      INSTANCE;

      @Override
      public Class create() {
        return Class.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName flags = FieldName.forField("flags");

      static final FieldName fqName = FieldName.forField("fqName", "fq_name");

      static final FieldName companionObjectName = FieldName.forField("companionObjectName", "companion_object_name");

      static final FieldName inlineClassUnderlyingPropertyName = FieldName.forField("inlineClassUnderlyingPropertyName", "inline_class_underlying_property_name");

      static final FieldName inlineClassUnderlyingTypeId = FieldName.forField("inlineClassUnderlyingTypeId", "inline_class_underlying_type_id");

      static final FieldName inlineClassUnderlyingType = FieldName.forField("inlineClassUnderlyingType", "inline_class_underlying_type");

      static final FieldName typeTable = FieldName.forField("typeTable", "type_table");

      static final FieldName versionRequirementTable = FieldName.forField("versionRequirementTable", "version_requirement_table");

      static final FieldName supertypeId = FieldName.forField("supertypeId", "supertype_id");

      static final FieldName nestedClassName = FieldName.forField("nestedClassName", "nested_class_name");

      static final FieldName sealedSubclassFqName = FieldName.forField("sealedSubclassFqName", "sealed_subclass_fq_name");

      static final FieldName contextReceiverTypeId = FieldName.forField("contextReceiverTypeId", "context_receiver_type_id");

      static final FieldName versionRequirement = FieldName.forField("versionRequirement", "version_requirement");

      static final FieldName typeParameter = FieldName.forField("typeParameter", "type_parameter");

      static final FieldName supertype = FieldName.forField("supertype");

      static final FieldName constructor = FieldName.forField("constructor");

      static final FieldName function = FieldName.forField("function");

      static final FieldName property = FieldName.forField("property");

      static final FieldName typeAlias = FieldName.forField("typeAlias", "type_alias");

      static final FieldName enumEntry = FieldName.forField("enumEntry", "enum_entry");

      static final FieldName contextReceiverType = FieldName.forField("contextReceiverType", "context_receiver_type");

      static final FieldName annotation = FieldName.forField("annotation");

      static final FieldName compilerPluginData = FieldName.forField("compilerPluginData", "compiler_plugin_data");
    }
  }

  /**
   * Protobuf type {@code Package}
   */
  public static final class Package extends ProtoMessage<Package> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     */
    private TypeTable typeTable = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     */
    private VersionRequirementTable versionRequirementTable = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 3;</code>
     */
    private RepeatedMessage<Function> function = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 4;</code>
     */
    private RepeatedMessage<Property> property = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 5;</code>
     */
    private RepeatedMessage<TypeAlias> typeAlias = null;

    private Package() {
    }

    /**
     * @return a new empty instance of {@code Package}
     */
    public static Package newInstance() {
      return new Package();
    }

    private void initTypeTable() {
      if (typeTable == null) {
        typeTable = TypeTable.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     * @return whether the typeTable field is set
     */
    public boolean hasTypeTable() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     * @return this
     */
    public Package clearTypeTable() {
      bitField0_ &= ~0x00000001;
      if (typeTable != null) {
        typeTable.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypeTable()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public TypeTable getTypeTable() {
      initTypeTable();
      return typeTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public TypeTable getMutableTypeTable() {
      initTypeTable();
      bitField0_ |= 0x00000001;
      return typeTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     * @param value the typeTable to set
     * @return this
     */
    public Package setTypeTable(final TypeTable value) {
      initTypeTable();
      bitField0_ |= 0x00000001;
      typeTable.copyFrom(value);
      return this;
    }

    private void initVersionRequirementTable() {
      if (versionRequirementTable == null) {
        versionRequirementTable = VersionRequirementTable.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     * @return whether the versionRequirementTable field is set
     */
    public boolean hasVersionRequirementTable() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     * @return this
     */
    public Package clearVersionRequirementTable() {
      bitField0_ &= ~0x00000002;
      if (versionRequirementTable != null) {
        versionRequirementTable.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVersionRequirementTable()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public VersionRequirementTable getVersionRequirementTable() {
      initVersionRequirementTable();
      return versionRequirementTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public VersionRequirementTable getMutableVersionRequirementTable() {
      initVersionRequirementTable();
      bitField0_ |= 0x00000002;
      return versionRequirementTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirementTable version_requirement_table = 32;</code>
     * @param value the versionRequirementTable to set
     * @return this
     */
    public Package setVersionRequirementTable(final VersionRequirementTable value) {
      initVersionRequirementTable();
      bitField0_ |= 0x00000002;
      versionRequirementTable.copyFrom(value);
      return this;
    }

    private void initFunction() {
      if (function == null) {
        function = RepeatedMessage.newEmptyInstance(Function.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 3;</code>
     * @return whether the function field is set
     */
    public boolean hasFunction() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 3;</code>
     * @return this
     */
    public Package clearFunction() {
      bitField0_ &= ~0x00000004;
      if (function != null) {
        function.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFunction()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Function> getFunction() {
      initFunction();
      return function;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Function> getMutableFunction() {
      initFunction();
      bitField0_ |= 0x00000004;
      return function;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 3;</code>
     * @param value the function to add
     * @return this
     */
    public Package addFunction(final Function value) {
      initFunction();
      bitField0_ |= 0x00000004;
      function.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Function function = 3;</code>
     * @param values the function to add
     * @return this
     */
    public Package addAllFunction(final Function... values) {
      initFunction();
      bitField0_ |= 0x00000004;
      function.addAll(values);
      return this;
    }

    private void initProperty() {
      if (property == null) {
        property = RepeatedMessage.newEmptyInstance(Property.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 4;</code>
     * @return whether the property field is set
     */
    public boolean hasProperty() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 4;</code>
     * @return this
     */
    public Package clearProperty() {
      bitField0_ &= ~0x00000008;
      if (property != null) {
        property.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableProperty()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Property> getProperty() {
      initProperty();
      return property;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Property> getMutableProperty() {
      initProperty();
      bitField0_ |= 0x00000008;
      return property;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 4;</code>
     * @param value the property to add
     * @return this
     */
    public Package addProperty(final Property value) {
      initProperty();
      bitField0_ |= 0x00000008;
      property.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Property property = 4;</code>
     * @param values the property to add
     * @return this
     */
    public Package addAllProperty(final Property... values) {
      initProperty();
      bitField0_ |= 0x00000008;
      property.addAll(values);
      return this;
    }

    private void initTypeAlias() {
      if (typeAlias == null) {
        typeAlias = RepeatedMessage.newEmptyInstance(TypeAlias.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 5;</code>
     * @return whether the typeAlias field is set
     */
    public boolean hasTypeAlias() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 5;</code>
     * @return this
     */
    public Package clearTypeAlias() {
      bitField0_ &= ~0x00000010;
      if (typeAlias != null) {
        typeAlias.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypeAlias()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<TypeAlias> getTypeAlias() {
      initTypeAlias();
      return typeAlias;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<TypeAlias> getMutableTypeAlias() {
      initTypeAlias();
      bitField0_ |= 0x00000010;
      return typeAlias;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 5;</code>
     * @param value the typeAlias to add
     * @return this
     */
    public Package addTypeAlias(final TypeAlias value) {
      initTypeAlias();
      bitField0_ |= 0x00000010;
      typeAlias.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeAlias type_alias = 5;</code>
     * @param values the typeAlias to add
     * @return this
     */
    public Package addAllTypeAlias(final TypeAlias... values) {
      initTypeAlias();
      bitField0_ |= 0x00000010;
      typeAlias.addAll(values);
      return this;
    }

    @Override
    public Package copyFrom(final Package other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasTypeTable()) {
          initTypeTable();
          typeTable.copyFrom(other.typeTable);
        } else {
          clearTypeTable();
        }
        if (other.hasVersionRequirementTable()) {
          initVersionRequirementTable();
          versionRequirementTable.copyFrom(other.versionRequirementTable);
        } else {
          clearVersionRequirementTable();
        }
        if (other.hasFunction()) {
          initFunction();
          function.copyFrom(other.function);
        } else {
          clearFunction();
        }
        if (other.hasProperty()) {
          initProperty();
          property.copyFrom(other.property);
        } else {
          clearProperty();
        }
        if (other.hasTypeAlias()) {
          initTypeAlias();
          typeAlias.copyFrom(other.typeAlias);
        } else {
          clearTypeAlias();
        }
      }
      return this;
    }

    @Override
    public Package mergeFrom(final Package other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTypeTable()) {
        getMutableTypeTable().mergeFrom(other.typeTable);
      }
      if (other.hasVersionRequirementTable()) {
        getMutableVersionRequirementTable().mergeFrom(other.versionRequirementTable);
      }
      if (other.hasFunction()) {
        getMutableFunction().addAll(other.function);
      }
      if (other.hasProperty()) {
        getMutableProperty().addAll(other.property);
      }
      if (other.hasTypeAlias()) {
        getMutableTypeAlias().addAll(other.typeAlias);
      }
      return this;
    }

    @Override
    public Package clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (typeTable != null) {
        typeTable.clear();
      }
      if (versionRequirementTable != null) {
        versionRequirementTable.clear();
      }
      if (function != null) {
        function.clear();
      }
      if (property != null) {
        property.clear();
      }
      if (typeAlias != null) {
        typeAlias.clear();
      }
      return this;
    }

    @Override
    public Package clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (typeTable != null) {
        typeTable.clearQuick();
      }
      if (versionRequirementTable != null) {
        versionRequirementTable.clearQuick();
      }
      if (function != null) {
        function.clearQuick();
      }
      if (property != null) {
        property.clearQuick();
      }
      if (typeAlias != null) {
        typeAlias.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Package)) {
        return false;
      }
      Package other = (Package) o;
      return bitField0_ == other.bitField0_
        && (!hasTypeTable() || typeTable.equals(other.typeTable))
        && (!hasVersionRequirementTable() || versionRequirementTable.equals(other.versionRequirementTable))
        && (!hasFunction() || function.equals(other.function))
        && (!hasProperty() || property.equals(other.property))
        && (!hasTypeAlias() || typeAlias.equals(other.typeAlias));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      try {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawLittleEndian16((short) 498);
          output.writeMessageNoTag(typeTable);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawLittleEndian16((short) 642);
          output.writeMessageNoTag(versionRequirementTable);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          for (int i = 0; i < function.length(); i++) {
            output.writeRawByte((byte) 26);
            output.writeMessageNoTag(function.get(i));
          }
        }
        if ((bitField0_ & 0x00000008) != 0) {
          for (int i = 0; i < property.length(); i++) {
            output.writeRawByte((byte) 34);
            output.writeMessageNoTag(property.get(i));
          }
        }
        if ((bitField0_ & 0x00000010) != 0) {
          for (int i = 0; i < typeAlias.length(); i++) {
            output.writeRawByte((byte) 42);
            output.writeMessageNoTag(typeAlias.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      try {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 2 + ProtoSink.computeMessageSizeNoTag(typeTable);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 2 + ProtoSink.computeMessageSizeNoTag(versionRequirementTable);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += (1 * function.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(function);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += (1 * property.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(property);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += (1 * typeAlias.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(typeAlias);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Package mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 242: {
            // typeTable
            initTypeTable();
            input.readMessage(typeTable);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 258) {
              break;
            }
          }
          case 258: {
            // versionRequirementTable
            initVersionRequirementTable();
            input.readMessage(versionRequirementTable);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // function
            initFunction();
            tag = input.readRepeatedMessage(function, tag);
            bitField0_ |= 0x00000004;
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // property
            initProperty();
            tag = input.readRepeatedMessage(property, tag);
            bitField0_ |= 0x00000008;
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // typeAlias
            initTypeAlias();
            tag = input.readRepeatedMessage(typeAlias, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if (hasFunction() && !function.isInitialized()) {
        return false;
      }
      if (hasProperty() && !property.isInitialized()) {
        return false;
      }
      if (hasTypeAlias() && !typeAlias.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (hasFunction() && !function.isInitialized()) {
        getMissingFields(prefix, "function", function, results);
      }
      if (hasProperty() && !property.isInitialized()) {
        getMissingFields(prefix, "property", property, results);
      }
      if (hasTypeAlias() && !typeAlias.isInitialized()) {
        getMissingFields(prefix, "type_alias", typeAlias, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeMessage(FieldNames.typeTable, typeTable);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeMessage(FieldNames.versionRequirementTable, versionRequirementTable);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRepeatedMessage(FieldNames.function, function);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRepeatedMessage(FieldNames.property, property);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRepeatedMessage(FieldNames.typeAlias, typeAlias);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Package mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 508637364:
          case -1079682423: {
            if (input.isAtField(FieldNames.typeTable)) {
              if (!input.trySkipNullValue()) {
                initTypeTable();
                input.readMessage(typeTable);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 284643907:
          case 1372421419: {
            if (input.isAtField(FieldNames.versionRequirementTable)) {
              if (!input.trySkipNullValue()) {
                initVersionRequirementTable();
                input.readMessage(versionRequirementTable);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1380938712: {
            if (input.isAtField(FieldNames.function)) {
              if (!input.trySkipNullValue()) {
                initFunction();
                input.readRepeatedMessage(function);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -993141291: {
            if (input.isAtField(FieldNames.property)) {
              if (!input.trySkipNullValue()) {
                initProperty();
                input.readRepeatedMessage(property);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 491424566:
          case -1096895221: {
            if (input.isAtField(FieldNames.typeAlias)) {
              if (!input.trySkipNullValue()) {
                initTypeAlias();
                input.readRepeatedMessage(typeAlias);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Package clone() {
      return new Package().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Package parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Package(), data).checkInitialized();
    }

    public static Package parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Package(), input).checkInitialized();
    }

    public static Package parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Package(), input).checkInitialized();
    }

    /**
     * @return factory for creating Package messages
     */
    public static MessageFactory<Package> getFactory() {
      return PackageFactory.INSTANCE;
    }

    private enum PackageFactory implements MessageFactory<Package> {
      INSTANCE;

      @Override
      public Package create() {
        return Package.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName typeTable = FieldName.forField("typeTable", "type_table");

      static final FieldName versionRequirementTable = FieldName.forField("versionRequirementTable", "version_requirement_table");

      static final FieldName function = FieldName.forField("function");

      static final FieldName property = FieldName.forField("property");

      static final FieldName typeAlias = FieldName.forField("typeAlias", "type_alias");
    }
  }

  /**
   * Protobuf type {@code TypeTable}
   */
  public static final class TypeTable extends ProtoMessage<TypeTable> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <pre>
     *  Index starting from which all types are nullable, or nothing if all types in this table are non-null.
     *  Note that the 'nullable' field of Type messages is ignored and shouldn't be written because it wastes too much space
     * </pre>
     *
     * <code>optional int32 first_nullable = 2 [default = -1];</code>
     */
    private int firstNullable = -1;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type type = 1;</code>
     */
    private RepeatedMessage<Type> type = null;

    private TypeTable() {
    }

    /**
     * @return a new empty instance of {@code TypeTable}
     */
    public static TypeTable newInstance() {
      return new TypeTable();
    }

    /**
     * <pre>
     *  Index starting from which all types are nullable, or nothing if all types in this table are non-null.
     *  Note that the 'nullable' field of Type messages is ignored and shouldn't be written because it wastes too much space
     * </pre>
     *
     * <code>optional int32 first_nullable = 2 [default = -1];</code>
     * @return whether the firstNullable field is set
     */
    public boolean hasFirstNullable() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <pre>
     *  Index starting from which all types are nullable, or nothing if all types in this table are non-null.
     *  Note that the 'nullable' field of Type messages is ignored and shouldn't be written because it wastes too much space
     * </pre>
     *
     * <code>optional int32 first_nullable = 2 [default = -1];</code>
     * @return this
     */
    public TypeTable clearFirstNullable() {
      bitField0_ &= ~0x00000001;
      firstNullable = -1;
      return this;
    }

    /**
     * <pre>
     *  Index starting from which all types are nullable, or nothing if all types in this table are non-null.
     *  Note that the 'nullable' field of Type messages is ignored and shouldn't be written because it wastes too much space
     * </pre>
     *
     * <code>optional int32 first_nullable = 2 [default = -1];</code>
     * @return the firstNullable
     */
    public int getFirstNullable() {
      return firstNullable;
    }

    /**
     * <pre>
     *  Index starting from which all types are nullable, or nothing if all types in this table are non-null.
     *  Note that the 'nullable' field of Type messages is ignored and shouldn't be written because it wastes too much space
     * </pre>
     *
     * <code>optional int32 first_nullable = 2 [default = -1];</code>
     * @param value the firstNullable to set
     * @return this
     */
    public TypeTable setFirstNullable(final int value) {
      bitField0_ |= 0x00000001;
      firstNullable = value;
      return this;
    }

    private void initType() {
      if (type == null) {
        type = RepeatedMessage.newEmptyInstance(Type.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type type = 1;</code>
     * @return whether the type field is set
     */
    public boolean hasType() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type type = 1;</code>
     * @return this
     */
    public TypeTable clearType() {
      bitField0_ &= ~0x00000002;
      if (type != null) {
        type.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type type = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Type> getType() {
      initType();
      return type;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type type = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Type> getMutableType() {
      initType();
      bitField0_ |= 0x00000002;
      return type;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type type = 1;</code>
     * @param value the type to add
     * @return this
     */
    public TypeTable addType(final Type value) {
      initType();
      bitField0_ |= 0x00000002;
      type.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type type = 1;</code>
     * @param values the type to add
     * @return this
     */
    public TypeTable addAllType(final Type... values) {
      initType();
      bitField0_ |= 0x00000002;
      type.addAll(values);
      return this;
    }

    @Override
    public TypeTable copyFrom(final TypeTable other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        firstNullable = other.firstNullable;
        if (other.hasType()) {
          initType();
          type.copyFrom(other.type);
        } else {
          clearType();
        }
      }
      return this;
    }

    @Override
    public TypeTable mergeFrom(final TypeTable other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFirstNullable()) {
        setFirstNullable(other.firstNullable);
      }
      if (other.hasType()) {
        getMutableType().addAll(other.type);
      }
      return this;
    }

    @Override
    public TypeTable clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      firstNullable = -1;
      if (type != null) {
        type.clear();
      }
      return this;
    }

    @Override
    public TypeTable clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (type != null) {
        type.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TypeTable)) {
        return false;
      }
      TypeTable other = (TypeTable) o;
      return bitField0_ == other.bitField0_
        && (!hasFirstNullable() || firstNullable == other.firstNullable)
        && (!hasType() || type.equals(other.type));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(firstNullable);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < type.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(type.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(firstNullable);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * type.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(type);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TypeTable mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // firstNullable
            firstNullable = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // type
            initType();
            tag = input.readRepeatedMessage(type, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.firstNullable, firstNullable);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.type, type);
      }
      output.endObject();
    }

    @Override
    public TypeTable mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -64436687:
          case 1728422928: {
            if (input.isAtField(FieldNames.firstNullable)) {
              if (!input.trySkipNullValue()) {
                firstNullable = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3575610: {
            if (input.isAtField(FieldNames.type)) {
              if (!input.trySkipNullValue()) {
                initType();
                input.readRepeatedMessage(type);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TypeTable clone() {
      return new TypeTable().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TypeTable parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TypeTable(), data).checkInitialized();
    }

    public static TypeTable parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TypeTable(), input).checkInitialized();
    }

    public static TypeTable parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TypeTable(), input).checkInitialized();
    }

    /**
     * @return factory for creating TypeTable messages
     */
    public static MessageFactory<TypeTable> getFactory() {
      return TypeTableFactory.INSTANCE;
    }

    private enum TypeTableFactory implements MessageFactory<TypeTable> {
      INSTANCE;

      @Override
      public TypeTable create() {
        return TypeTable.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName firstNullable = FieldName.forField("firstNullable", "first_nullable");

      static final FieldName type = FieldName.forField("type");
    }
  }

  /**
   * Protobuf type {@code Constructor}
   */
  public static final class Constructor extends ProtoMessage<Constructor> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     */
    private int flags = 6;

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     */
    private RepeatedInt versionRequirement = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 2;</code>
     */
    private RepeatedMessage<ValueParameter> valueParameter = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 3;</code>
     */
    private RepeatedMessage<Annotation> annotation = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     */
    private RepeatedMessage<CompilerPluginData> compilerPluginData = null;

    private Constructor() {
    }

    /**
     * @return a new empty instance of {@code Constructor}
     */
    public static Constructor newInstance() {
      return new Constructor();
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @return whether the flags field is set
     */
    public boolean hasFlags() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @return this
     */
    public Constructor clearFlags() {
      bitField0_ &= ~0x00000001;
      flags = 6;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @return the flags
     */
    public int getFlags() {
      return flags;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @param value the flags to set
     * @return this
     */
    public Constructor setFlags(final int value) {
      bitField0_ |= 0x00000001;
      flags = value;
      return this;
    }

    private void initVersionRequirement() {
      if (versionRequirement == null) {
        versionRequirement = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return whether the versionRequirement field is set
     */
    public boolean hasVersionRequirement() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return this
     */
    public Constructor clearVersionRequirement() {
      bitField0_ &= ~0x00000002;
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVersionRequirement()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getVersionRequirement() {
      initVersionRequirement();
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableVersionRequirement() {
      initVersionRequirement();
      bitField0_ |= 0x00000002;
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param value the versionRequirement to add
     * @return this
     */
    public Constructor addVersionRequirement(final int value) {
      initVersionRequirement();
      bitField0_ |= 0x00000002;
      versionRequirement.add(value);
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param values the versionRequirement to add
     * @return this
     */
    public Constructor addAllVersionRequirement(final int... values) {
      initVersionRequirement();
      bitField0_ |= 0x00000002;
      versionRequirement.addAll(values);
      return this;
    }

    private void initValueParameter() {
      if (valueParameter == null) {
        valueParameter = RepeatedMessage.newEmptyInstance(ValueParameter.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 2;</code>
     * @return whether the valueParameter field is set
     */
    public boolean hasValueParameter() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 2;</code>
     * @return this
     */
    public Constructor clearValueParameter() {
      bitField0_ &= ~0x00000004;
      if (valueParameter != null) {
        valueParameter.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableValueParameter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ValueParameter> getValueParameter() {
      initValueParameter();
      return valueParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ValueParameter> getMutableValueParameter() {
      initValueParameter();
      bitField0_ |= 0x00000004;
      return valueParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 2;</code>
     * @param value the valueParameter to add
     * @return this
     */
    public Constructor addValueParameter(final ValueParameter value) {
      initValueParameter();
      bitField0_ |= 0x00000004;
      valueParameter.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 2;</code>
     * @param values the valueParameter to add
     * @return this
     */
    public Constructor addAllValueParameter(final ValueParameter... values) {
      initValueParameter();
      bitField0_ |= 0x00000004;
      valueParameter.addAll(values);
      return this;
    }

    private void initAnnotation() {
      if (annotation == null) {
        annotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 3;</code>
     * @return whether the annotation field is set
     */
    public boolean hasAnnotation() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 3;</code>
     * @return this
     */
    public Constructor clearAnnotation() {
      bitField0_ &= ~0x00000008;
      if (annotation != null) {
        annotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getAnnotation() {
      initAnnotation();
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableAnnotation() {
      initAnnotation();
      bitField0_ |= 0x00000008;
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 3;</code>
     * @param value the annotation to add
     * @return this
     */
    public Constructor addAnnotation(final Annotation value) {
      initAnnotation();
      bitField0_ |= 0x00000008;
      annotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 3;</code>
     * @param values the annotation to add
     * @return this
     */
    public Constructor addAllAnnotation(final Annotation... values) {
      initAnnotation();
      bitField0_ |= 0x00000008;
      annotation.addAll(values);
      return this;
    }

    private void initCompilerPluginData() {
      if (compilerPluginData == null) {
        compilerPluginData = RepeatedMessage.newEmptyInstance(CompilerPluginData.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @return whether the compilerPluginData field is set
     */
    public boolean hasCompilerPluginData() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @return this
     */
    public Constructor clearCompilerPluginData() {
      bitField0_ &= ~0x00000010;
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCompilerPluginData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CompilerPluginData> getCompilerPluginData() {
      initCompilerPluginData();
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CompilerPluginData> getMutableCompilerPluginData() {
      initCompilerPluginData();
      bitField0_ |= 0x00000010;
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @param value the compilerPluginData to add
     * @return this
     */
    public Constructor addCompilerPluginData(final CompilerPluginData value) {
      initCompilerPluginData();
      bitField0_ |= 0x00000010;
      compilerPluginData.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @param values the compilerPluginData to add
     * @return this
     */
    public Constructor addAllCompilerPluginData(final CompilerPluginData... values) {
      initCompilerPluginData();
      bitField0_ |= 0x00000010;
      compilerPluginData.addAll(values);
      return this;
    }

    @Override
    public Constructor copyFrom(final Constructor other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        flags = other.flags;
        if (other.hasVersionRequirement()) {
          initVersionRequirement();
          versionRequirement.copyFrom(other.versionRequirement);
        } else {
          clearVersionRequirement();
        }
        if (other.hasValueParameter()) {
          initValueParameter();
          valueParameter.copyFrom(other.valueParameter);
        } else {
          clearValueParameter();
        }
        if (other.hasAnnotation()) {
          initAnnotation();
          annotation.copyFrom(other.annotation);
        } else {
          clearAnnotation();
        }
        if (other.hasCompilerPluginData()) {
          initCompilerPluginData();
          compilerPluginData.copyFrom(other.compilerPluginData);
        } else {
          clearCompilerPluginData();
        }
      }
      return this;
    }

    @Override
    public Constructor mergeFrom(final Constructor other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFlags()) {
        setFlags(other.flags);
      }
      if (other.hasVersionRequirement()) {
        getMutableVersionRequirement().addAll(other.versionRequirement);
      }
      if (other.hasValueParameter()) {
        getMutableValueParameter().addAll(other.valueParameter);
      }
      if (other.hasAnnotation()) {
        getMutableAnnotation().addAll(other.annotation);
      }
      if (other.hasCompilerPluginData()) {
        getMutableCompilerPluginData().addAll(other.compilerPluginData);
      }
      return this;
    }

    @Override
    public Constructor clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flags = 6;
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (valueParameter != null) {
        valueParameter.clear();
      }
      if (annotation != null) {
        annotation.clear();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      return this;
    }

    @Override
    public Constructor clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (valueParameter != null) {
        valueParameter.clearQuick();
      }
      if (annotation != null) {
        annotation.clearQuick();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Constructor)) {
        return false;
      }
      Constructor other = (Constructor) o;
      return bitField0_ == other.bitField0_
        && (!hasFlags() || flags == other.flags)
        && (!hasVersionRequirement() || versionRequirement.equals(other.versionRequirement))
        && (!hasValueParameter() || valueParameter.equals(other.valueParameter))
        && (!hasAnnotation() || annotation.equals(other.annotation))
        && (!hasCompilerPluginData() || compilerPluginData.equals(other.compilerPluginData));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      try {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 8);
          output.writeInt32NoTag(flags);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          for (int i = 0; i < versionRequirement.length(); i++) {
            output.writeRawLittleEndian16((short) 504);
            output.writeInt32NoTag(versionRequirement.array()[i]);
          }
        }
        if ((bitField0_ & 0x00000004) != 0) {
          for (int i = 0; i < valueParameter.length(); i++) {
            output.writeRawByte((byte) 18);
            output.writeMessageNoTag(valueParameter.get(i));
          }
        }
        if ((bitField0_ & 0x00000008) != 0) {
          for (int i = 0; i < annotation.length(); i++) {
            output.writeRawByte((byte) 26);
            output.writeMessageNoTag(annotation.get(i));
          }
        }
        if ((bitField0_ & 0x00000010) != 0) {
          for (int i = 0; i < compilerPluginData.length(); i++) {
            output.writeRawLittleEndian16((short) 642);
            output.writeMessageNoTag(compilerPluginData.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      try {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(flags);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += (2 * versionRequirement.length()) + ProtoSink.computeRepeatedInt32SizeNoTag(versionRequirement);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += (1 * valueParameter.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(valueParameter);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += (1 * annotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(annotation);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += (2 * compilerPluginData.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(compilerPluginData);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Constructor mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // flags
            flags = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 250) {
              break;
            }
          }
          case 250: {
            // versionRequirement [packed=true]
            initVersionRequirement();
            input.readPackedInt32(versionRequirement, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // valueParameter
            initValueParameter();
            tag = input.readRepeatedMessage(valueParameter, tag);
            bitField0_ |= 0x00000004;
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // annotation
            initAnnotation();
            tag = input.readRepeatedMessage(annotation, tag);
            bitField0_ |= 0x00000008;
            if (tag != 258) {
              break;
            }
          }
          case 258: {
            // compilerPluginData
            initCompilerPluginData();
            tag = input.readRepeatedMessage(compilerPluginData, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 248: {
            // versionRequirement [packed=false]
            initVersionRequirement();
            tag = input.readRepeatedInt32(versionRequirement, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if (hasValueParameter() && !valueParameter.isInitialized()) {
        return false;
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        return false;
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (hasValueParameter() && !valueParameter.isInitialized()) {
        getMissingFields(prefix, "value_parameter", valueParameter, results);
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        getMissingFields(prefix, "annotation", annotation, results);
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        getMissingFields(prefix, "compiler_plugin_data", compilerPluginData, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt32(FieldNames.flags, flags);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRepeatedInt32(FieldNames.versionRequirement, versionRequirement);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRepeatedMessage(FieldNames.valueParameter, valueParameter);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRepeatedMessage(FieldNames.annotation, annotation);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRepeatedMessage(FieldNames.compilerPluginData, compilerPluginData);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Constructor mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 97513095: {
            if (input.isAtField(FieldNames.flags)) {
              if (!input.trySkipNullValue()) {
                flags = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 351760459:
          case -783428772: {
            if (input.isAtField(FieldNames.versionRequirement)) {
              if (!input.trySkipNullValue()) {
                initVersionRequirement();
                input.readRepeatedInt32(versionRequirement);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 339890488:
          case -39983525: {
            if (input.isAtField(FieldNames.valueParameter)) {
              if (!input.trySkipNullValue()) {
                initValueParameter();
                input.readRepeatedMessage(valueParameter);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1555043537: {
            if (input.isAtField(FieldNames.annotation)) {
              if (!input.trySkipNullValue()) {
                initAnnotation();
                input.readRepeatedMessage(annotation);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1393610620:
          case -1920592490: {
            if (input.isAtField(FieldNames.compilerPluginData)) {
              if (!input.trySkipNullValue()) {
                initCompilerPluginData();
                input.readRepeatedMessage(compilerPluginData);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Constructor clone() {
      return new Constructor().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Constructor parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Constructor(), data).checkInitialized();
    }

    public static Constructor parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Constructor(), input).checkInitialized();
    }

    public static Constructor parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Constructor(), input).checkInitialized();
    }

    /**
     * @return factory for creating Constructor messages
     */
    public static MessageFactory<Constructor> getFactory() {
      return ConstructorFactory.INSTANCE;
    }

    private enum ConstructorFactory implements MessageFactory<Constructor> {
      INSTANCE;

      @Override
      public Constructor create() {
        return Constructor.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName flags = FieldName.forField("flags");

      static final FieldName versionRequirement = FieldName.forField("versionRequirement", "version_requirement");

      static final FieldName valueParameter = FieldName.forField("valueParameter", "value_parameter");

      static final FieldName annotation = FieldName.forField("annotation");

      static final FieldName compilerPluginData = FieldName.forField("compilerPluginData", "compiler_plugin_data");
    }
  }

  /**
   * Protobuf type {@code Function}
   */
  public static final class Function extends ProtoMessage<Function> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 old_flags = 1 [default = 6];</code>
     */
    private int oldFlags = 6;

    /**
     * <code>required int32 name = 2;</code>
     */
    private int name;

    /**
     * <code>optional int32 return_type_id = 7;</code>
     */
    private int returnTypeId;

    /**
     * <code>optional int32 receiver_type_id = 8;</code>
     */
    private int receiverTypeId;

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isOperator
     * isInfix
     * isInline
     * isTailrec
     * isExternal
     * isSuspend
     * isExpect
     * hasNonStableParameterNames
     * </pre>
     *
     * <code>optional int32 flags = 9 [default = 6];</code>
     */
    private int flags = 6;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     */
    private Type returnType = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     */
    private Type receiverType = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     */
    private TypeTable typeTable = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Contract contract = 32;</code>
     */
    private Contract contract = null;

    /**
     * <code>repeated int32 context_receiver_type_id = 11 [packed = true];</code>
     */
    private RepeatedInt contextReceiverTypeId = null;

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     */
    private RepeatedInt versionRequirement = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     */
    private RepeatedMessage<TypeParameter> typeParameter = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 6;</code>
     */
    private RepeatedMessage<ValueParameter> valueParameter = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 10;</code>
     */
    private RepeatedMessage<Type> contextReceiverType = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 12;</code>
     */
    private RepeatedMessage<Annotation> annotation = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 13;</code>
     */
    private RepeatedMessage<ValueParameter> contextParameter = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     */
    private RepeatedMessage<CompilerPluginData> compilerPluginData = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 34;</code>
     */
    private RepeatedMessage<Annotation> extensionReceiverAnnotation = null;

    private Function() {
    }

    /**
     * @return a new empty instance of {@code Function}
     */
    public static Function newInstance() {
      return new Function();
    }

    /**
     * <code>optional int32 old_flags = 1 [default = 6];</code>
     * @return whether the oldFlags field is set
     */
    public boolean hasOldFlags() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional int32 old_flags = 1 [default = 6];</code>
     * @return this
     */
    public Function clearOldFlags() {
      bitField0_ &= ~0x00000400;
      oldFlags = 6;
      return this;
    }

    /**
     * <code>optional int32 old_flags = 1 [default = 6];</code>
     * @return the oldFlags
     */
    public int getOldFlags() {
      return oldFlags;
    }

    /**
     * <code>optional int32 old_flags = 1 [default = 6];</code>
     * @param value the oldFlags to set
     * @return this
     */
    public Function setOldFlags(final int value) {
      bitField0_ |= 0x00000400;
      oldFlags = value;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return this
     */
    public Function clearName() {
      bitField0_ &= ~0x00000200;
      name = 0;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return the name
     */
    public int getName() {
      return name;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @param value the name to set
     * @return this
     */
    public Function setName(final int value) {
      bitField0_ |= 0x00000200;
      name = value;
      return this;
    }

    /**
     * <code>optional int32 return_type_id = 7;</code>
     * @return whether the returnTypeId field is set
     */
    public boolean hasReturnTypeId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 return_type_id = 7;</code>
     * @return this
     */
    public Function clearReturnTypeId() {
      bitField0_ &= ~0x00000001;
      returnTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 return_type_id = 7;</code>
     * @return the returnTypeId
     */
    public int getReturnTypeId() {
      return returnTypeId;
    }

    /**
     * <code>optional int32 return_type_id = 7;</code>
     * @param value the returnTypeId to set
     * @return this
     */
    public Function setReturnTypeId(final int value) {
      bitField0_ |= 0x00000001;
      returnTypeId = value;
      return this;
    }

    /**
     * <code>optional int32 receiver_type_id = 8;</code>
     * @return whether the receiverTypeId field is set
     */
    public boolean hasReceiverTypeId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int32 receiver_type_id = 8;</code>
     * @return this
     */
    public Function clearReceiverTypeId() {
      bitField0_ &= ~0x00000002;
      receiverTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 receiver_type_id = 8;</code>
     * @return the receiverTypeId
     */
    public int getReceiverTypeId() {
      return receiverTypeId;
    }

    /**
     * <code>optional int32 receiver_type_id = 8;</code>
     * @param value the receiverTypeId to set
     * @return this
     */
    public Function setReceiverTypeId(final int value) {
      bitField0_ |= 0x00000002;
      receiverTypeId = value;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isOperator
     * isInfix
     * isInline
     * isTailrec
     * isExternal
     * isSuspend
     * isExpect
     * hasNonStableParameterNames
     * </pre>
     *
     * <code>optional int32 flags = 9 [default = 6];</code>
     * @return whether the flags field is set
     */
    public boolean hasFlags() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isOperator
     * isInfix
     * isInline
     * isTailrec
     * isExternal
     * isSuspend
     * isExpect
     * hasNonStableParameterNames
     * </pre>
     *
     * <code>optional int32 flags = 9 [default = 6];</code>
     * @return this
     */
    public Function clearFlags() {
      bitField0_ &= ~0x00000004;
      flags = 6;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isOperator
     * isInfix
     * isInline
     * isTailrec
     * isExternal
     * isSuspend
     * isExpect
     * hasNonStableParameterNames
     * </pre>
     *
     * <code>optional int32 flags = 9 [default = 6];</code>
     * @return the flags
     */
    public int getFlags() {
      return flags;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isOperator
     * isInfix
     * isInline
     * isTailrec
     * isExternal
     * isSuspend
     * isExpect
     * hasNonStableParameterNames
     * </pre>
     *
     * <code>optional int32 flags = 9 [default = 6];</code>
     * @param value the flags to set
     * @return this
     */
    public Function setFlags(final int value) {
      bitField0_ |= 0x00000004;
      flags = value;
      return this;
    }

    private void initReturnType() {
      if (returnType == null) {
        returnType = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     * @return whether the returnType field is set
     */
    public boolean hasReturnType() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     * @return this
     */
    public Function clearReturnType() {
      bitField0_ &= ~0x00000800;
      if (returnType != null) {
        returnType.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableReturnType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getReturnType() {
      initReturnType();
      return returnType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableReturnType() {
      initReturnType();
      bitField0_ |= 0x00000800;
      return returnType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     * @param value the returnType to set
     * @return this
     */
    public Function setReturnType(final Type value) {
      initReturnType();
      bitField0_ |= 0x00000800;
      returnType.copyFrom(value);
      return this;
    }

    private void initReceiverType() {
      if (receiverType == null) {
        receiverType = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     * @return whether the receiverType field is set
     */
    public boolean hasReceiverType() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     * @return this
     */
    public Function clearReceiverType() {
      bitField0_ &= ~0x00000008;
      if (receiverType != null) {
        receiverType.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableReceiverType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getReceiverType() {
      initReceiverType();
      return receiverType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableReceiverType() {
      initReceiverType();
      bitField0_ |= 0x00000008;
      return receiverType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     * @param value the receiverType to set
     * @return this
     */
    public Function setReceiverType(final Type value) {
      initReceiverType();
      bitField0_ |= 0x00000008;
      receiverType.copyFrom(value);
      return this;
    }

    private void initTypeTable() {
      if (typeTable == null) {
        typeTable = TypeTable.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     * @return whether the typeTable field is set
     */
    public boolean hasTypeTable() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     * @return this
     */
    public Function clearTypeTable() {
      bitField0_ &= ~0x00001000;
      if (typeTable != null) {
        typeTable.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypeTable()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public TypeTable getTypeTable() {
      initTypeTable();
      return typeTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public TypeTable getMutableTypeTable() {
      initTypeTable();
      bitField0_ |= 0x00001000;
      return typeTable;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.TypeTable type_table = 30;</code>
     * @param value the typeTable to set
     * @return this
     */
    public Function setTypeTable(final TypeTable value) {
      initTypeTable();
      bitField0_ |= 0x00001000;
      typeTable.copyFrom(value);
      return this;
    }

    private void initContract() {
      if (contract == null) {
        contract = Contract.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Contract contract = 32;</code>
     * @return whether the contract field is set
     */
    public boolean hasContract() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Contract contract = 32;</code>
     * @return this
     */
    public Function clearContract() {
      bitField0_ &= ~0x00000010;
      if (contract != null) {
        contract.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Contract contract = 32;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContract()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Contract getContract() {
      initContract();
      return contract;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Contract contract = 32;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Contract getMutableContract() {
      initContract();
      bitField0_ |= 0x00000010;
      return contract;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Contract contract = 32;</code>
     * @param value the contract to set
     * @return this
     */
    public Function setContract(final Contract value) {
      initContract();
      bitField0_ |= 0x00000010;
      contract.copyFrom(value);
      return this;
    }

    private void initContextReceiverTypeId() {
      if (contextReceiverTypeId == null) {
        contextReceiverTypeId = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 11 [packed = true];</code>
     * @return whether the contextReceiverTypeId field is set
     */
    public boolean hasContextReceiverTypeId() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 11 [packed = true];</code>
     * @return this
     */
    public Function clearContextReceiverTypeId() {
      bitField0_ &= ~0x00002000;
      if (contextReceiverTypeId != null) {
        contextReceiverTypeId.clear();
      }
      return this;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 11 [packed = true];</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContextReceiverTypeId()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getContextReceiverTypeId() {
      initContextReceiverTypeId();
      return contextReceiverTypeId;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 11 [packed = true];</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableContextReceiverTypeId() {
      initContextReceiverTypeId();
      bitField0_ |= 0x00002000;
      return contextReceiverTypeId;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 11 [packed = true];</code>
     * @param value the contextReceiverTypeId to add
     * @return this
     */
    public Function addContextReceiverTypeId(final int value) {
      initContextReceiverTypeId();
      bitField0_ |= 0x00002000;
      contextReceiverTypeId.add(value);
      return this;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 11 [packed = true];</code>
     * @param values the contextReceiverTypeId to add
     * @return this
     */
    public Function addAllContextReceiverTypeId(final int... values) {
      initContextReceiverTypeId();
      bitField0_ |= 0x00002000;
      contextReceiverTypeId.addAll(values);
      return this;
    }

    private void initVersionRequirement() {
      if (versionRequirement == null) {
        versionRequirement = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return whether the versionRequirement field is set
     */
    public boolean hasVersionRequirement() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return this
     */
    public Function clearVersionRequirement() {
      bitField0_ &= ~0x00000020;
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVersionRequirement()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getVersionRequirement() {
      initVersionRequirement();
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableVersionRequirement() {
      initVersionRequirement();
      bitField0_ |= 0x00000020;
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param value the versionRequirement to add
     * @return this
     */
    public Function addVersionRequirement(final int value) {
      initVersionRequirement();
      bitField0_ |= 0x00000020;
      versionRequirement.add(value);
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param values the versionRequirement to add
     * @return this
     */
    public Function addAllVersionRequirement(final int... values) {
      initVersionRequirement();
      bitField0_ |= 0x00000020;
      versionRequirement.addAll(values);
      return this;
    }

    private void initTypeParameter() {
      if (typeParameter == null) {
        typeParameter = RepeatedMessage.newEmptyInstance(TypeParameter.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     * @return whether the typeParameter field is set
     */
    public boolean hasTypeParameter() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     * @return this
     */
    public Function clearTypeParameter() {
      bitField0_ &= ~0x00004000;
      if (typeParameter != null) {
        typeParameter.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypeParameter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<TypeParameter> getTypeParameter() {
      initTypeParameter();
      return typeParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<TypeParameter> getMutableTypeParameter() {
      initTypeParameter();
      bitField0_ |= 0x00004000;
      return typeParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     * @param value the typeParameter to add
     * @return this
     */
    public Function addTypeParameter(final TypeParameter value) {
      initTypeParameter();
      bitField0_ |= 0x00004000;
      typeParameter.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     * @param values the typeParameter to add
     * @return this
     */
    public Function addAllTypeParameter(final TypeParameter... values) {
      initTypeParameter();
      bitField0_ |= 0x00004000;
      typeParameter.addAll(values);
      return this;
    }

    private void initValueParameter() {
      if (valueParameter == null) {
        valueParameter = RepeatedMessage.newEmptyInstance(ValueParameter.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 6;</code>
     * @return whether the valueParameter field is set
     */
    public boolean hasValueParameter() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 6;</code>
     * @return this
     */
    public Function clearValueParameter() {
      bitField0_ &= ~0x00000040;
      if (valueParameter != null) {
        valueParameter.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableValueParameter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ValueParameter> getValueParameter() {
      initValueParameter();
      return valueParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ValueParameter> getMutableValueParameter() {
      initValueParameter();
      bitField0_ |= 0x00000040;
      return valueParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 6;</code>
     * @param value the valueParameter to add
     * @return this
     */
    public Function addValueParameter(final ValueParameter value) {
      initValueParameter();
      bitField0_ |= 0x00000040;
      valueParameter.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter value_parameter = 6;</code>
     * @param values the valueParameter to add
     * @return this
     */
    public Function addAllValueParameter(final ValueParameter... values) {
      initValueParameter();
      bitField0_ |= 0x00000040;
      valueParameter.addAll(values);
      return this;
    }

    private void initContextReceiverType() {
      if (contextReceiverType == null) {
        contextReceiverType = RepeatedMessage.newEmptyInstance(Type.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 10;</code>
     * @return whether the contextReceiverType field is set
     */
    public boolean hasContextReceiverType() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 10;</code>
     * @return this
     */
    public Function clearContextReceiverType() {
      bitField0_ &= ~0x00008000;
      if (contextReceiverType != null) {
        contextReceiverType.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContextReceiverType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Type> getContextReceiverType() {
      initContextReceiverType();
      return contextReceiverType;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Type> getMutableContextReceiverType() {
      initContextReceiverType();
      bitField0_ |= 0x00008000;
      return contextReceiverType;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 10;</code>
     * @param value the contextReceiverType to add
     * @return this
     */
    public Function addContextReceiverType(final Type value) {
      initContextReceiverType();
      bitField0_ |= 0x00008000;
      contextReceiverType.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 10;</code>
     * @param values the contextReceiverType to add
     * @return this
     */
    public Function addAllContextReceiverType(final Type... values) {
      initContextReceiverType();
      bitField0_ |= 0x00008000;
      contextReceiverType.addAll(values);
      return this;
    }

    private void initAnnotation() {
      if (annotation == null) {
        annotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 12;</code>
     * @return whether the annotation field is set
     */
    public boolean hasAnnotation() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 12;</code>
     * @return this
     */
    public Function clearAnnotation() {
      bitField0_ &= ~0x00000080;
      if (annotation != null) {
        annotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getAnnotation() {
      initAnnotation();
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableAnnotation() {
      initAnnotation();
      bitField0_ |= 0x00000080;
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 12;</code>
     * @param value the annotation to add
     * @return this
     */
    public Function addAnnotation(final Annotation value) {
      initAnnotation();
      bitField0_ |= 0x00000080;
      annotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 12;</code>
     * @param values the annotation to add
     * @return this
     */
    public Function addAllAnnotation(final Annotation... values) {
      initAnnotation();
      bitField0_ |= 0x00000080;
      annotation.addAll(values);
      return this;
    }

    private void initContextParameter() {
      if (contextParameter == null) {
        contextParameter = RepeatedMessage.newEmptyInstance(ValueParameter.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 13;</code>
     * @return whether the contextParameter field is set
     */
    public boolean hasContextParameter() {
      return (bitField0_ & 0x00010000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 13;</code>
     * @return this
     */
    public Function clearContextParameter() {
      bitField0_ &= ~0x00010000;
      if (contextParameter != null) {
        contextParameter.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 13;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContextParameter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ValueParameter> getContextParameter() {
      initContextParameter();
      return contextParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 13;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ValueParameter> getMutableContextParameter() {
      initContextParameter();
      bitField0_ |= 0x00010000;
      return contextParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 13;</code>
     * @param value the contextParameter to add
     * @return this
     */
    public Function addContextParameter(final ValueParameter value) {
      initContextParameter();
      bitField0_ |= 0x00010000;
      contextParameter.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 13;</code>
     * @param values the contextParameter to add
     * @return this
     */
    public Function addAllContextParameter(final ValueParameter... values) {
      initContextParameter();
      bitField0_ |= 0x00010000;
      contextParameter.addAll(values);
      return this;
    }

    private void initCompilerPluginData() {
      if (compilerPluginData == null) {
        compilerPluginData = RepeatedMessage.newEmptyInstance(CompilerPluginData.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     * @return whether the compilerPluginData field is set
     */
    public boolean hasCompilerPluginData() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     * @return this
     */
    public Function clearCompilerPluginData() {
      bitField0_ &= ~0x00000100;
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCompilerPluginData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CompilerPluginData> getCompilerPluginData() {
      initCompilerPluginData();
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CompilerPluginData> getMutableCompilerPluginData() {
      initCompilerPluginData();
      bitField0_ |= 0x00000100;
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     * @param value the compilerPluginData to add
     * @return this
     */
    public Function addCompilerPluginData(final CompilerPluginData value) {
      initCompilerPluginData();
      bitField0_ |= 0x00000100;
      compilerPluginData.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 33;</code>
     * @param values the compilerPluginData to add
     * @return this
     */
    public Function addAllCompilerPluginData(final CompilerPluginData... values) {
      initCompilerPluginData();
      bitField0_ |= 0x00000100;
      compilerPluginData.addAll(values);
      return this;
    }

    private void initExtensionReceiverAnnotation() {
      if (extensionReceiverAnnotation == null) {
        extensionReceiverAnnotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 34;</code>
     * @return whether the extensionReceiverAnnotation field is set
     */
    public boolean hasExtensionReceiverAnnotation() {
      return (bitField0_ & 0x00020000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 34;</code>
     * @return this
     */
    public Function clearExtensionReceiverAnnotation() {
      bitField0_ &= ~0x00020000;
      if (extensionReceiverAnnotation != null) {
        extensionReceiverAnnotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 34;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableExtensionReceiverAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getExtensionReceiverAnnotation() {
      initExtensionReceiverAnnotation();
      return extensionReceiverAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 34;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableExtensionReceiverAnnotation() {
      initExtensionReceiverAnnotation();
      bitField0_ |= 0x00020000;
      return extensionReceiverAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 34;</code>
     * @param value the extensionReceiverAnnotation to add
     * @return this
     */
    public Function addExtensionReceiverAnnotation(final Annotation value) {
      initExtensionReceiverAnnotation();
      bitField0_ |= 0x00020000;
      extensionReceiverAnnotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 34;</code>
     * @param values the extensionReceiverAnnotation to add
     * @return this
     */
    public Function addAllExtensionReceiverAnnotation(final Annotation... values) {
      initExtensionReceiverAnnotation();
      bitField0_ |= 0x00020000;
      extensionReceiverAnnotation.addAll(values);
      return this;
    }

    @Override
    public Function copyFrom(final Function other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        oldFlags = other.oldFlags;
        name = other.name;
        returnTypeId = other.returnTypeId;
        receiverTypeId = other.receiverTypeId;
        flags = other.flags;
        if (other.hasReturnType()) {
          initReturnType();
          returnType.copyFrom(other.returnType);
        } else {
          clearReturnType();
        }
        if (other.hasReceiverType()) {
          initReceiverType();
          receiverType.copyFrom(other.receiverType);
        } else {
          clearReceiverType();
        }
        if (other.hasTypeTable()) {
          initTypeTable();
          typeTable.copyFrom(other.typeTable);
        } else {
          clearTypeTable();
        }
        if (other.hasContract()) {
          initContract();
          contract.copyFrom(other.contract);
        } else {
          clearContract();
        }
        if (other.hasContextReceiverTypeId()) {
          initContextReceiverTypeId();
          contextReceiverTypeId.copyFrom(other.contextReceiverTypeId);
        } else {
          clearContextReceiverTypeId();
        }
        if (other.hasVersionRequirement()) {
          initVersionRequirement();
          versionRequirement.copyFrom(other.versionRequirement);
        } else {
          clearVersionRequirement();
        }
        if (other.hasTypeParameter()) {
          initTypeParameter();
          typeParameter.copyFrom(other.typeParameter);
        } else {
          clearTypeParameter();
        }
        if (other.hasValueParameter()) {
          initValueParameter();
          valueParameter.copyFrom(other.valueParameter);
        } else {
          clearValueParameter();
        }
        if (other.hasContextReceiverType()) {
          initContextReceiverType();
          contextReceiverType.copyFrom(other.contextReceiverType);
        } else {
          clearContextReceiverType();
        }
        if (other.hasAnnotation()) {
          initAnnotation();
          annotation.copyFrom(other.annotation);
        } else {
          clearAnnotation();
        }
        if (other.hasContextParameter()) {
          initContextParameter();
          contextParameter.copyFrom(other.contextParameter);
        } else {
          clearContextParameter();
        }
        if (other.hasCompilerPluginData()) {
          initCompilerPluginData();
          compilerPluginData.copyFrom(other.compilerPluginData);
        } else {
          clearCompilerPluginData();
        }
        if (other.hasExtensionReceiverAnnotation()) {
          initExtensionReceiverAnnotation();
          extensionReceiverAnnotation.copyFrom(other.extensionReceiverAnnotation);
        } else {
          clearExtensionReceiverAnnotation();
        }
      }
      return this;
    }

    @Override
    public Function mergeFrom(final Function other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasOldFlags()) {
        setOldFlags(other.oldFlags);
      }
      if (other.hasName()) {
        setName(other.name);
      }
      if (other.hasReturnTypeId()) {
        setReturnTypeId(other.returnTypeId);
      }
      if (other.hasReceiverTypeId()) {
        setReceiverTypeId(other.receiverTypeId);
      }
      if (other.hasFlags()) {
        setFlags(other.flags);
      }
      if (other.hasReturnType()) {
        getMutableReturnType().mergeFrom(other.returnType);
      }
      if (other.hasReceiverType()) {
        getMutableReceiverType().mergeFrom(other.receiverType);
      }
      if (other.hasTypeTable()) {
        getMutableTypeTable().mergeFrom(other.typeTable);
      }
      if (other.hasContract()) {
        getMutableContract().mergeFrom(other.contract);
      }
      if (other.hasContextReceiverTypeId()) {
        getMutableContextReceiverTypeId().addAll(other.contextReceiverTypeId);
      }
      if (other.hasVersionRequirement()) {
        getMutableVersionRequirement().addAll(other.versionRequirement);
      }
      if (other.hasTypeParameter()) {
        getMutableTypeParameter().addAll(other.typeParameter);
      }
      if (other.hasValueParameter()) {
        getMutableValueParameter().addAll(other.valueParameter);
      }
      if (other.hasContextReceiverType()) {
        getMutableContextReceiverType().addAll(other.contextReceiverType);
      }
      if (other.hasAnnotation()) {
        getMutableAnnotation().addAll(other.annotation);
      }
      if (other.hasContextParameter()) {
        getMutableContextParameter().addAll(other.contextParameter);
      }
      if (other.hasCompilerPluginData()) {
        getMutableCompilerPluginData().addAll(other.compilerPluginData);
      }
      if (other.hasExtensionReceiverAnnotation()) {
        getMutableExtensionReceiverAnnotation().addAll(other.extensionReceiverAnnotation);
      }
      return this;
    }

    @Override
    public Function clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      oldFlags = 6;
      name = 0;
      returnTypeId = 0;
      receiverTypeId = 0;
      flags = 6;
      if (returnType != null) {
        returnType.clear();
      }
      if (receiverType != null) {
        receiverType.clear();
      }
      if (typeTable != null) {
        typeTable.clear();
      }
      if (contract != null) {
        contract.clear();
      }
      if (contextReceiverTypeId != null) {
        contextReceiverTypeId.clear();
      }
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (typeParameter != null) {
        typeParameter.clear();
      }
      if (valueParameter != null) {
        valueParameter.clear();
      }
      if (contextReceiverType != null) {
        contextReceiverType.clear();
      }
      if (annotation != null) {
        annotation.clear();
      }
      if (contextParameter != null) {
        contextParameter.clear();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      if (extensionReceiverAnnotation != null) {
        extensionReceiverAnnotation.clear();
      }
      return this;
    }

    @Override
    public Function clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (returnType != null) {
        returnType.clearQuick();
      }
      if (receiverType != null) {
        receiverType.clearQuick();
      }
      if (typeTable != null) {
        typeTable.clearQuick();
      }
      if (contract != null) {
        contract.clearQuick();
      }
      if (contextReceiverTypeId != null) {
        contextReceiverTypeId.clear();
      }
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (typeParameter != null) {
        typeParameter.clearQuick();
      }
      if (valueParameter != null) {
        valueParameter.clearQuick();
      }
      if (contextReceiverType != null) {
        contextReceiverType.clearQuick();
      }
      if (annotation != null) {
        annotation.clearQuick();
      }
      if (contextParameter != null) {
        contextParameter.clearQuick();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clearQuick();
      }
      if (extensionReceiverAnnotation != null) {
        extensionReceiverAnnotation.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Function)) {
        return false;
      }
      Function other = (Function) o;
      return bitField0_ == other.bitField0_
        && (!hasOldFlags() || oldFlags == other.oldFlags)
        && (!hasName() || name == other.name)
        && (!hasReturnTypeId() || returnTypeId == other.returnTypeId)
        && (!hasReceiverTypeId() || receiverTypeId == other.receiverTypeId)
        && (!hasFlags() || flags == other.flags)
        && (!hasReturnType() || returnType.equals(other.returnType))
        && (!hasReceiverType() || receiverType.equals(other.receiverType))
        && (!hasTypeTable() || typeTable.equals(other.typeTable))
        && (!hasContract() || contract.equals(other.contract))
        && (!hasContextReceiverTypeId() || contextReceiverTypeId.equals(other.contextReceiverTypeId))
        && (!hasVersionRequirement() || versionRequirement.equals(other.versionRequirement))
        && (!hasTypeParameter() || typeParameter.equals(other.typeParameter))
        && (!hasValueParameter() || valueParameter.equals(other.valueParameter))
        && (!hasContextReceiverType() || contextReceiverType.equals(other.contextReceiverType))
        && (!hasAnnotation() || annotation.equals(other.annotation))
        && (!hasContextParameter() || contextParameter.equals(other.contextParameter))
        && (!hasCompilerPluginData() || compilerPluginData.equals(other.compilerPluginData))
        && (!hasExtensionReceiverAnnotation() || extensionReceiverAnnotation.equals(other.extensionReceiverAnnotation));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000200) != 0x00000200))) {
        throw new UninitializedMessageException(this);
      }
      try {
        if ((bitField0_ & 0x00000400) != 0) {
          output.writeRawByte((byte) 8);
          output.writeInt32NoTag(oldFlags);
        }
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 56);
          output.writeInt32NoTag(returnTypeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 64);
          output.writeInt32NoTag(receiverTypeId);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 72);
          output.writeInt32NoTag(flags);
        }
        if ((bitField0_ & 0x00000800) != 0) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(returnType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRawByte((byte) 42);
          output.writeMessageNoTag(receiverType);
        }
        if ((bitField0_ & 0x00001000) != 0) {
          output.writeRawLittleEndian16((short) 498);
          output.writeMessageNoTag(typeTable);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRawLittleEndian16((short) 642);
          output.writeMessageNoTag(contract);
        }
        if ((bitField0_ & 0x00002000) != 0) {
          output.writeRawByte((byte) 90);
          output.writePackedInt32NoTag(contextReceiverTypeId);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          for (int i = 0; i < versionRequirement.length(); i++) {
            output.writeRawLittleEndian16((short) 504);
            output.writeInt32NoTag(versionRequirement.array()[i]);
          }
        }
        if ((bitField0_ & 0x00004000) != 0) {
          for (int i = 0; i < typeParameter.length(); i++) {
            output.writeRawByte((byte) 34);
            output.writeMessageNoTag(typeParameter.get(i));
          }
        }
        if ((bitField0_ & 0x00000040) != 0) {
          for (int i = 0; i < valueParameter.length(); i++) {
            output.writeRawByte((byte) 50);
            output.writeMessageNoTag(valueParameter.get(i));
          }
        }
        if ((bitField0_ & 0x00008000) != 0) {
          for (int i = 0; i < contextReceiverType.length(); i++) {
            output.writeRawByte((byte) 82);
            output.writeMessageNoTag(contextReceiverType.get(i));
          }
        }
        if ((bitField0_ & 0x00000080) != 0) {
          for (int i = 0; i < annotation.length(); i++) {
            output.writeRawByte((byte) 98);
            output.writeMessageNoTag(annotation.get(i));
          }
        }
        if ((bitField0_ & 0x00010000) != 0) {
          for (int i = 0; i < contextParameter.length(); i++) {
            output.writeRawByte((byte) 106);
            output.writeMessageNoTag(contextParameter.get(i));
          }
        }
        if ((bitField0_ & 0x00000100) != 0) {
          for (int i = 0; i < compilerPluginData.length(); i++) {
            output.writeRawLittleEndian16((short) 650);
            output.writeMessageNoTag(compilerPluginData.get(i));
          }
        }
        if ((bitField0_ & 0x00020000) != 0) {
          for (int i = 0; i < extensionReceiverAnnotation.length(); i++) {
            output.writeRawLittleEndian16((short) 658);
            output.writeMessageNoTag(extensionReceiverAnnotation.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000200) != 0x00000200))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        if ((bitField0_ & 0x00000400) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(oldFlags);
        }
        size += 1 + ProtoSink.computeInt32SizeNoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(returnTypeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(receiverTypeId);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(flags);
        }
        if ((bitField0_ & 0x00000800) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(returnType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(receiverType);
        }
        if ((bitField0_ & 0x00001000) != 0) {
          size += 2 + ProtoSink.computeMessageSizeNoTag(typeTable);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += 2 + ProtoSink.computeMessageSizeNoTag(contract);
        }
        if ((bitField0_ & 0x00002000) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(contextReceiverTypeId);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          size += (2 * versionRequirement.length()) + ProtoSink.computeRepeatedInt32SizeNoTag(versionRequirement);
        }
        if ((bitField0_ & 0x00004000) != 0) {
          size += (1 * typeParameter.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(typeParameter);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          size += (1 * valueParameter.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(valueParameter);
        }
        if ((bitField0_ & 0x00008000) != 0) {
          size += (1 * contextReceiverType.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(contextReceiverType);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          size += (1 * annotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(annotation);
        }
        if ((bitField0_ & 0x00010000) != 0) {
          size += (1 * contextParameter.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(contextParameter);
        }
        if ((bitField0_ & 0x00000100) != 0) {
          size += (2 * compilerPluginData.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(compilerPluginData);
        }
        if ((bitField0_ & 0x00020000) != 0) {
          size += (2 * extensionReceiverAnnotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(extensionReceiverAnnotation);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Function mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // oldFlags
            oldFlags = input.readInt32();
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // name
            name = input.readInt32();
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // returnTypeId
            returnTypeId = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // receiverTypeId
            receiverTypeId = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // flags
            flags = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // returnType
            initReturnType();
            input.readMessage(returnType);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // receiverType
            initReceiverType();
            input.readMessage(receiverType);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 242) {
              break;
            }
          }
          case 242: {
            // typeTable
            initTypeTable();
            input.readMessage(typeTable);
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 258) {
              break;
            }
          }
          case 258: {
            // contract
            initContract();
            input.readMessage(contract);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // contextReceiverTypeId [packed=true]
            initContextReceiverTypeId();
            input.readPackedInt32(contextReceiverTypeId, tag);
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 250) {
              break;
            }
          }
          case 250: {
            // versionRequirement [packed=true]
            initVersionRequirement();
            input.readPackedInt32(versionRequirement, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // typeParameter
            initTypeParameter();
            tag = input.readRepeatedMessage(typeParameter, tag);
            bitField0_ |= 0x00004000;
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // valueParameter
            initValueParameter();
            tag = input.readRepeatedMessage(valueParameter, tag);
            bitField0_ |= 0x00000040;
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // contextReceiverType
            initContextReceiverType();
            tag = input.readRepeatedMessage(contextReceiverType, tag);
            bitField0_ |= 0x00008000;
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // annotation
            initAnnotation();
            tag = input.readRepeatedMessage(annotation, tag);
            bitField0_ |= 0x00000080;
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // contextParameter
            initContextParameter();
            tag = input.readRepeatedMessage(contextParameter, tag);
            bitField0_ |= 0x00010000;
            if (tag != 266) {
              break;
            }
          }
          case 266: {
            // compilerPluginData
            initCompilerPluginData();
            tag = input.readRepeatedMessage(compilerPluginData, tag);
            bitField0_ |= 0x00000100;
            if (tag != 274) {
              break;
            }
          }
          case 274: {
            // extensionReceiverAnnotation
            initExtensionReceiverAnnotation();
            tag = input.readRepeatedMessage(extensionReceiverAnnotation, tag);
            bitField0_ |= 0x00020000;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 88: {
            // contextReceiverTypeId [packed=false]
            initContextReceiverTypeId();
            tag = input.readRepeatedInt32(contextReceiverTypeId, tag);
            bitField0_ |= 0x00002000;
            break;
          }
          case 248: {
            // versionRequirement [packed=false]
            initVersionRequirement();
            tag = input.readRepeatedInt32(versionRequirement, tag);
            bitField0_ |= 0x00000020;
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000200) != 0x00000200))) {
        return false;
      }
      if (hasTypeParameter() && !typeParameter.isInitialized()) {
        return false;
      }
      if (hasValueParameter() && !valueParameter.isInitialized()) {
        return false;
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        return false;
      }
      if (hasContextParameter() && !contextParameter.isInitialized()) {
        return false;
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        return false;
      }
      if (hasExtensionReceiverAnnotation() && !extensionReceiverAnnotation.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasName()) {
        results.add(prefix + "name");
      }
      if (hasTypeParameter() && !typeParameter.isInitialized()) {
        getMissingFields(prefix, "type_parameter", typeParameter, results);
      }
      if (hasValueParameter() && !valueParameter.isInitialized()) {
        getMissingFields(prefix, "value_parameter", valueParameter, results);
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        getMissingFields(prefix, "annotation", annotation, results);
      }
      if (hasContextParameter() && !contextParameter.isInitialized()) {
        getMissingFields(prefix, "context_parameter", contextParameter, results);
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        getMissingFields(prefix, "compiler_plugin_data", compilerPluginData, results);
      }
      if (hasExtensionReceiverAnnotation() && !extensionReceiverAnnotation.isInitialized()) {
        getMissingFields(prefix, "extension_receiver_annotation", extensionReceiverAnnotation, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000200) != 0x00000200))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000400) != 0) {
          output.writeInt32(FieldNames.oldFlags, oldFlags);
        }
        output.writeInt32(FieldNames.name, name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt32(FieldNames.returnTypeId, returnTypeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeInt32(FieldNames.receiverTypeId, receiverTypeId);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeInt32(FieldNames.flags, flags);
        }
        if ((bitField0_ & 0x00000800) != 0) {
          output.writeMessage(FieldNames.returnType, returnType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeMessage(FieldNames.receiverType, receiverType);
        }
        if ((bitField0_ & 0x00001000) != 0) {
          output.writeMessage(FieldNames.typeTable, typeTable);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeMessage(FieldNames.contract, contract);
        }
        if ((bitField0_ & 0x00002000) != 0) {
          output.writeRepeatedInt32(FieldNames.contextReceiverTypeId, contextReceiverTypeId);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRepeatedInt32(FieldNames.versionRequirement, versionRequirement);
        }
        if ((bitField0_ & 0x00004000) != 0) {
          output.writeRepeatedMessage(FieldNames.typeParameter, typeParameter);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          output.writeRepeatedMessage(FieldNames.valueParameter, valueParameter);
        }
        if ((bitField0_ & 0x00008000) != 0) {
          output.writeRepeatedMessage(FieldNames.contextReceiverType, contextReceiverType);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          output.writeRepeatedMessage(FieldNames.annotation, annotation);
        }
        if ((bitField0_ & 0x00010000) != 0) {
          output.writeRepeatedMessage(FieldNames.contextParameter, contextParameter);
        }
        if ((bitField0_ & 0x00000100) != 0) {
          output.writeRepeatedMessage(FieldNames.compilerPluginData, compilerPluginData);
        }
        if ((bitField0_ & 0x00020000) != 0) {
          output.writeRepeatedMessage(FieldNames.extensionReceiverAnnotation, extensionReceiverAnnotation);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Function mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 175444128:
          case 1854309999: {
            if (input.isAtField(FieldNames.oldFlags)) {
              if (!input.trySkipNullValue()) {
                oldFlags = input.readInt32();
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3373707: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                name = input.readInt32();
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 860632901:
          case 256676913: {
            if (input.isAtField(FieldNames.returnTypeId)) {
              if (!input.trySkipNullValue()) {
                returnTypeId = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 278862020:
          case -479391248: {
            if (input.isAtField(FieldNames.receiverTypeId)) {
              if (!input.trySkipNullValue()) {
                receiverTypeId = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 97513095: {
            if (input.isAtField(FieldNames.flags)) {
              if (!input.trySkipNullValue()) {
                flags = input.readInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1337206922:
          case -1486239511: {
            if (input.isAtField(FieldNames.returnType)) {
              if (!input.trySkipNullValue()) {
                initReturnType();
                input.readMessage(returnType);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -755016247:
          case -1920648310: {
            if (input.isAtField(FieldNames.receiverType)) {
              if (!input.trySkipNullValue()) {
                initReceiverType();
                input.readMessage(receiverType);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 508637364:
          case -1079682423: {
            if (input.isAtField(FieldNames.typeTable)) {
              if (!input.trySkipNullValue()) {
                initTypeTable();
                input.readMessage(typeTable);
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -566947566: {
            if (input.isAtField(FieldNames.contract)) {
              if (!input.trySkipNullValue()) {
                initContract();
                input.readMessage(contract);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -614859693:
          case -769035648: {
            if (input.isAtField(FieldNames.contextReceiverTypeId)) {
              if (!input.trySkipNullValue()) {
                initContextReceiverTypeId();
                input.readRepeatedInt32(contextReceiverTypeId);
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 351760459:
          case -783428772: {
            if (input.isAtField(FieldNames.versionRequirement)) {
              if (!input.trySkipNullValue()) {
                initVersionRequirement();
                input.readRepeatedInt32(versionRequirement);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 659473807:
          case 1277164772: {
            if (input.isAtField(FieldNames.typeParameter)) {
              if (!input.trySkipNullValue()) {
                initTypeParameter();
                input.readRepeatedMessage(typeParameter);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 339890488:
          case -39983525: {
            if (input.isAtField(FieldNames.valueParameter)) {
              if (!input.trySkipNullValue()) {
                initValueParameter();
                input.readRepeatedMessage(valueParameter);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -420751080:
          case 1699161338: {
            if (input.isAtField(FieldNames.contextReceiverType)) {
              if (!input.trySkipNullValue()) {
                initContextReceiverType();
                input.readRepeatedMessage(contextReceiverType);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1555043537: {
            if (input.isAtField(FieldNames.annotation)) {
              if (!input.trySkipNullValue()) {
                initAnnotation();
                input.readRepeatedMessage(annotation);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1011248454:
          case 1024382233: {
            if (input.isAtField(FieldNames.contextParameter)) {
              if (!input.trySkipNullValue()) {
                initContextParameter();
                input.readRepeatedMessage(contextParameter);
                bitField0_ |= 0x00010000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1393610620:
          case -1920592490: {
            if (input.isAtField(FieldNames.compilerPluginData)) {
              if (!input.trySkipNullValue()) {
                initCompilerPluginData();
                input.readRepeatedMessage(compilerPluginData);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1811859171:
          case -1167446145: {
            if (input.isAtField(FieldNames.extensionReceiverAnnotation)) {
              if (!input.trySkipNullValue()) {
                initExtensionReceiverAnnotation();
                input.readRepeatedMessage(extensionReceiverAnnotation);
                bitField0_ |= 0x00020000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Function clone() {
      return new Function().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Function parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Function(), data).checkInitialized();
    }

    public static Function parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Function(), input).checkInitialized();
    }

    public static Function parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Function(), input).checkInitialized();
    }

    /**
     * @return factory for creating Function messages
     */
    public static MessageFactory<Function> getFactory() {
      return FunctionFactory.INSTANCE;
    }

    private enum FunctionFactory implements MessageFactory<Function> {
      INSTANCE;

      @Override
      public Function create() {
        return Function.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName oldFlags = FieldName.forField("oldFlags", "old_flags");

      static final FieldName name = FieldName.forField("name");

      static final FieldName returnTypeId = FieldName.forField("returnTypeId", "return_type_id");

      static final FieldName receiverTypeId = FieldName.forField("receiverTypeId", "receiver_type_id");

      static final FieldName flags = FieldName.forField("flags");

      static final FieldName returnType = FieldName.forField("returnType", "return_type");

      static final FieldName receiverType = FieldName.forField("receiverType", "receiver_type");

      static final FieldName typeTable = FieldName.forField("typeTable", "type_table");

      static final FieldName contract = FieldName.forField("contract");

      static final FieldName contextReceiverTypeId = FieldName.forField("contextReceiverTypeId", "context_receiver_type_id");

      static final FieldName versionRequirement = FieldName.forField("versionRequirement", "version_requirement");

      static final FieldName typeParameter = FieldName.forField("typeParameter", "type_parameter");

      static final FieldName valueParameter = FieldName.forField("valueParameter", "value_parameter");

      static final FieldName contextReceiverType = FieldName.forField("contextReceiverType", "context_receiver_type");

      static final FieldName annotation = FieldName.forField("annotation");

      static final FieldName contextParameter = FieldName.forField("contextParameter", "context_parameter");

      static final FieldName compilerPluginData = FieldName.forField("compilerPluginData", "compiler_plugin_data");

      static final FieldName extensionReceiverAnnotation = FieldName.forField("extensionReceiverAnnotation", "extension_receiver_annotation");
    }
  }

  /**
   * Protobuf type {@code Property}
   */
  public static final class Property extends ProtoMessage<Property> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 old_flags = 1 [default = 2054];</code>
     */
    private int oldFlags = 2054;

    /**
     * <code>required int32 name = 2;</code>
     */
    private int name;

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * isNotDefault
     * isExternal
     * isInline
     *
     * If getter_flags or setter_flags are absent, their value should be computed as follows:
     * - hasAnnotations, Visibility, Modality have the same value as in the property flags
     * - all other flags are false
     * </pre>
     *
     * <code>optional int32 getter_flags = 7;</code>
     */
    private int getterFlags;

    /**
     * <code>optional int32 setter_flags = 8;</code>
     */
    private int setterFlags;

    /**
     * <code>optional int32 return_type_id = 9;</code>
     */
    private int returnTypeId;

    /**
     * <code>optional int32 receiver_type_id = 10;</code>
     */
    private int receiverTypeId;

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isVar
     * hasGetter
     * hasSetter
     * isConst
     * isLateinit
     * hasConstant
     * isExternal
     * isDelegated
     * isExpect
     * </pre>
     *
     * <code>optional int32 flags = 11 [default = 518];</code>
     */
    private int flags = 518;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     */
    private Type returnType = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     */
    private Type receiverType = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.ValueParameter setter_value_parameter = 6;</code>
     */
    private ValueParameter setterValueParameter = null;

    /**
     * <code>repeated int32 context_receiver_type_id = 13 [packed = true];</code>
     */
    private RepeatedInt contextReceiverTypeId = null;

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     */
    private RepeatedInt versionRequirement = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     */
    private RepeatedMessage<TypeParameter> typeParameter = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 12;</code>
     */
    private RepeatedMessage<Type> contextReceiverType = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 14;</code>
     */
    private RepeatedMessage<Annotation> annotation = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation getter_annotation = 15;</code>
     */
    private RepeatedMessage<Annotation> getterAnnotation = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation setter_annotation = 16;</code>
     */
    private RepeatedMessage<Annotation> setterAnnotation = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 17;</code>
     */
    private RepeatedMessage<ValueParameter> contextParameter = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     */
    private RepeatedMessage<CompilerPluginData> compilerPluginData = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 33;</code>
     */
    private RepeatedMessage<Annotation> extensionReceiverAnnotation = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation backing_field_annotation = 34;</code>
     */
    private RepeatedMessage<Annotation> backingFieldAnnotation = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation delegate_field_annotation = 35;</code>
     */
    private RepeatedMessage<Annotation> delegateFieldAnnotation = null;

    private Property() {
    }

    /**
     * @return a new empty instance of {@code Property}
     */
    public static Property newInstance() {
      return new Property();
    }

    /**
     * <code>optional int32 old_flags = 1 [default = 2054];</code>
     * @return whether the oldFlags field is set
     */
    public boolean hasOldFlags() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional int32 old_flags = 1 [default = 2054];</code>
     * @return this
     */
    public Property clearOldFlags() {
      bitField0_ &= ~0x00001000;
      oldFlags = 2054;
      return this;
    }

    /**
     * <code>optional int32 old_flags = 1 [default = 2054];</code>
     * @return the oldFlags
     */
    public int getOldFlags() {
      return oldFlags;
    }

    /**
     * <code>optional int32 old_flags = 1 [default = 2054];</code>
     * @param value the oldFlags to set
     * @return this
     */
    public Property setOldFlags(final int value) {
      bitField0_ |= 0x00001000;
      oldFlags = value;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return this
     */
    public Property clearName() {
      bitField0_ &= ~0x00000800;
      name = 0;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return the name
     */
    public int getName() {
      return name;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @param value the name to set
     * @return this
     */
    public Property setName(final int value) {
      bitField0_ |= 0x00000800;
      name = value;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * isNotDefault
     * isExternal
     * isInline
     *
     * If getter_flags or setter_flags are absent, their value should be computed as follows:
     * - hasAnnotations, Visibility, Modality have the same value as in the property flags
     * - all other flags are false
     * </pre>
     *
     * <code>optional int32 getter_flags = 7;</code>
     * @return whether the getterFlags field is set
     */
    public boolean hasGetterFlags() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * isNotDefault
     * isExternal
     * isInline
     *
     * If getter_flags or setter_flags are absent, their value should be computed as follows:
     * - hasAnnotations, Visibility, Modality have the same value as in the property flags
     * - all other flags are false
     * </pre>
     *
     * <code>optional int32 getter_flags = 7;</code>
     * @return this
     */
    public Property clearGetterFlags() {
      bitField0_ &= ~0x00000001;
      getterFlags = 0;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * isNotDefault
     * isExternal
     * isInline
     *
     * If getter_flags or setter_flags are absent, their value should be computed as follows:
     * - hasAnnotations, Visibility, Modality have the same value as in the property flags
     * - all other flags are false
     * </pre>
     *
     * <code>optional int32 getter_flags = 7;</code>
     * @return the getterFlags
     */
    public int getGetterFlags() {
      return getterFlags;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * isNotDefault
     * isExternal
     * isInline
     *
     * If getter_flags or setter_flags are absent, their value should be computed as follows:
     * - hasAnnotations, Visibility, Modality have the same value as in the property flags
     * - all other flags are false
     * </pre>
     *
     * <code>optional int32 getter_flags = 7;</code>
     * @param value the getterFlags to set
     * @return this
     */
    public Property setGetterFlags(final int value) {
      bitField0_ |= 0x00000001;
      getterFlags = value;
      return this;
    }

    /**
     * <code>optional int32 setter_flags = 8;</code>
     * @return whether the setterFlags field is set
     */
    public boolean hasSetterFlags() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int32 setter_flags = 8;</code>
     * @return this
     */
    public Property clearSetterFlags() {
      bitField0_ &= ~0x00000002;
      setterFlags = 0;
      return this;
    }

    /**
     * <code>optional int32 setter_flags = 8;</code>
     * @return the setterFlags
     */
    public int getSetterFlags() {
      return setterFlags;
    }

    /**
     * <code>optional int32 setter_flags = 8;</code>
     * @param value the setterFlags to set
     * @return this
     */
    public Property setSetterFlags(final int value) {
      bitField0_ |= 0x00000002;
      setterFlags = value;
      return this;
    }

    /**
     * <code>optional int32 return_type_id = 9;</code>
     * @return whether the returnTypeId field is set
     */
    public boolean hasReturnTypeId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional int32 return_type_id = 9;</code>
     * @return this
     */
    public Property clearReturnTypeId() {
      bitField0_ &= ~0x00000004;
      returnTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 return_type_id = 9;</code>
     * @return the returnTypeId
     */
    public int getReturnTypeId() {
      return returnTypeId;
    }

    /**
     * <code>optional int32 return_type_id = 9;</code>
     * @param value the returnTypeId to set
     * @return this
     */
    public Property setReturnTypeId(final int value) {
      bitField0_ |= 0x00000004;
      returnTypeId = value;
      return this;
    }

    /**
     * <code>optional int32 receiver_type_id = 10;</code>
     * @return whether the receiverTypeId field is set
     */
    public boolean hasReceiverTypeId() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>optional int32 receiver_type_id = 10;</code>
     * @return this
     */
    public Property clearReceiverTypeId() {
      bitField0_ &= ~0x00002000;
      receiverTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 receiver_type_id = 10;</code>
     * @return the receiverTypeId
     */
    public int getReceiverTypeId() {
      return receiverTypeId;
    }

    /**
     * <code>optional int32 receiver_type_id = 10;</code>
     * @param value the receiverTypeId to set
     * @return this
     */
    public Property setReceiverTypeId(final int value) {
      bitField0_ |= 0x00002000;
      receiverTypeId = value;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isVar
     * hasGetter
     * hasSetter
     * isConst
     * isLateinit
     * hasConstant
     * isExternal
     * isDelegated
     * isExpect
     * </pre>
     *
     * <code>optional int32 flags = 11 [default = 518];</code>
     * @return whether the flags field is set
     */
    public boolean hasFlags() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isVar
     * hasGetter
     * hasSetter
     * isConst
     * isLateinit
     * hasConstant
     * isExternal
     * isDelegated
     * isExpect
     * </pre>
     *
     * <code>optional int32 flags = 11 [default = 518];</code>
     * @return this
     */
    public Property clearFlags() {
      bitField0_ &= ~0x00000008;
      flags = 518;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isVar
     * hasGetter
     * hasSetter
     * isConst
     * isLateinit
     * hasConstant
     * isExternal
     * isDelegated
     * isExpect
     * </pre>
     *
     * <code>optional int32 flags = 11 [default = 518];</code>
     * @return the flags
     */
    public int getFlags() {
      return flags;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * MemberKind
     * isVar
     * hasGetter
     * hasSetter
     * isConst
     * isLateinit
     * hasConstant
     * isExternal
     * isDelegated
     * isExpect
     * </pre>
     *
     * <code>optional int32 flags = 11 [default = 518];</code>
     * @param value the flags to set
     * @return this
     */
    public Property setFlags(final int value) {
      bitField0_ |= 0x00000008;
      flags = value;
      return this;
    }

    private void initReturnType() {
      if (returnType == null) {
        returnType = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     * @return whether the returnType field is set
     */
    public boolean hasReturnType() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     * @return this
     */
    public Property clearReturnType() {
      bitField0_ &= ~0x00004000;
      if (returnType != null) {
        returnType.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableReturnType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getReturnType() {
      initReturnType();
      return returnType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableReturnType() {
      initReturnType();
      bitField0_ |= 0x00004000;
      return returnType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type return_type = 3;</code>
     * @param value the returnType to set
     * @return this
     */
    public Property setReturnType(final Type value) {
      initReturnType();
      bitField0_ |= 0x00004000;
      returnType.copyFrom(value);
      return this;
    }

    private void initReceiverType() {
      if (receiverType == null) {
        receiverType = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     * @return whether the receiverType field is set
     */
    public boolean hasReceiverType() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     * @return this
     */
    public Property clearReceiverType() {
      bitField0_ &= ~0x00000010;
      if (receiverType != null) {
        receiverType.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableReceiverType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getReceiverType() {
      initReceiverType();
      return receiverType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableReceiverType() {
      initReceiverType();
      bitField0_ |= 0x00000010;
      return receiverType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type receiver_type = 5;</code>
     * @param value the receiverType to set
     * @return this
     */
    public Property setReceiverType(final Type value) {
      initReceiverType();
      bitField0_ |= 0x00000010;
      receiverType.copyFrom(value);
      return this;
    }

    private void initSetterValueParameter() {
      if (setterValueParameter == null) {
        setterValueParameter = ValueParameter.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.ValueParameter setter_value_parameter = 6;</code>
     * @return whether the setterValueParameter field is set
     */
    public boolean hasSetterValueParameter() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.ValueParameter setter_value_parameter = 6;</code>
     * @return this
     */
    public Property clearSetterValueParameter() {
      bitField0_ &= ~0x00008000;
      if (setterValueParameter != null) {
        setterValueParameter.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.ValueParameter setter_value_parameter = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSetterValueParameter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ValueParameter getSetterValueParameter() {
      initSetterValueParameter();
      return setterValueParameter;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.ValueParameter setter_value_parameter = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ValueParameter getMutableSetterValueParameter() {
      initSetterValueParameter();
      bitField0_ |= 0x00008000;
      return setterValueParameter;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.ValueParameter setter_value_parameter = 6;</code>
     * @param value the setterValueParameter to set
     * @return this
     */
    public Property setSetterValueParameter(final ValueParameter value) {
      initSetterValueParameter();
      bitField0_ |= 0x00008000;
      setterValueParameter.copyFrom(value);
      return this;
    }

    private void initContextReceiverTypeId() {
      if (contextReceiverTypeId == null) {
        contextReceiverTypeId = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 13 [packed = true];</code>
     * @return whether the contextReceiverTypeId field is set
     */
    public boolean hasContextReceiverTypeId() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 13 [packed = true];</code>
     * @return this
     */
    public Property clearContextReceiverTypeId() {
      bitField0_ &= ~0x00000020;
      if (contextReceiverTypeId != null) {
        contextReceiverTypeId.clear();
      }
      return this;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 13 [packed = true];</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContextReceiverTypeId()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getContextReceiverTypeId() {
      initContextReceiverTypeId();
      return contextReceiverTypeId;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 13 [packed = true];</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableContextReceiverTypeId() {
      initContextReceiverTypeId();
      bitField0_ |= 0x00000020;
      return contextReceiverTypeId;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 13 [packed = true];</code>
     * @param value the contextReceiverTypeId to add
     * @return this
     */
    public Property addContextReceiverTypeId(final int value) {
      initContextReceiverTypeId();
      bitField0_ |= 0x00000020;
      contextReceiverTypeId.add(value);
      return this;
    }

    /**
     * <code>repeated int32 context_receiver_type_id = 13 [packed = true];</code>
     * @param values the contextReceiverTypeId to add
     * @return this
     */
    public Property addAllContextReceiverTypeId(final int... values) {
      initContextReceiverTypeId();
      bitField0_ |= 0x00000020;
      contextReceiverTypeId.addAll(values);
      return this;
    }

    private void initVersionRequirement() {
      if (versionRequirement == null) {
        versionRequirement = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return whether the versionRequirement field is set
     */
    public boolean hasVersionRequirement() {
      return (bitField0_ & 0x00010000) != 0;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return this
     */
    public Property clearVersionRequirement() {
      bitField0_ &= ~0x00010000;
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVersionRequirement()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getVersionRequirement() {
      initVersionRequirement();
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableVersionRequirement() {
      initVersionRequirement();
      bitField0_ |= 0x00010000;
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param value the versionRequirement to add
     * @return this
     */
    public Property addVersionRequirement(final int value) {
      initVersionRequirement();
      bitField0_ |= 0x00010000;
      versionRequirement.add(value);
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param values the versionRequirement to add
     * @return this
     */
    public Property addAllVersionRequirement(final int... values) {
      initVersionRequirement();
      bitField0_ |= 0x00010000;
      versionRequirement.addAll(values);
      return this;
    }

    private void initTypeParameter() {
      if (typeParameter == null) {
        typeParameter = RepeatedMessage.newEmptyInstance(TypeParameter.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     * @return whether the typeParameter field is set
     */
    public boolean hasTypeParameter() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     * @return this
     */
    public Property clearTypeParameter() {
      bitField0_ &= ~0x00000040;
      if (typeParameter != null) {
        typeParameter.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypeParameter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<TypeParameter> getTypeParameter() {
      initTypeParameter();
      return typeParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<TypeParameter> getMutableTypeParameter() {
      initTypeParameter();
      bitField0_ |= 0x00000040;
      return typeParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     * @param value the typeParameter to add
     * @return this
     */
    public Property addTypeParameter(final TypeParameter value) {
      initTypeParameter();
      bitField0_ |= 0x00000040;
      typeParameter.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 4;</code>
     * @param values the typeParameter to add
     * @return this
     */
    public Property addAllTypeParameter(final TypeParameter... values) {
      initTypeParameter();
      bitField0_ |= 0x00000040;
      typeParameter.addAll(values);
      return this;
    }

    private void initContextReceiverType() {
      if (contextReceiverType == null) {
        contextReceiverType = RepeatedMessage.newEmptyInstance(Type.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 12;</code>
     * @return whether the contextReceiverType field is set
     */
    public boolean hasContextReceiverType() {
      return (bitField0_ & 0x00020000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 12;</code>
     * @return this
     */
    public Property clearContextReceiverType() {
      bitField0_ &= ~0x00020000;
      if (contextReceiverType != null) {
        contextReceiverType.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContextReceiverType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Type> getContextReceiverType() {
      initContextReceiverType();
      return contextReceiverType;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Type> getMutableContextReceiverType() {
      initContextReceiverType();
      bitField0_ |= 0x00020000;
      return contextReceiverType;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 12;</code>
     * @param value the contextReceiverType to add
     * @return this
     */
    public Property addContextReceiverType(final Type value) {
      initContextReceiverType();
      bitField0_ |= 0x00020000;
      contextReceiverType.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Type context_receiver_type = 12;</code>
     * @param values the contextReceiverType to add
     * @return this
     */
    public Property addAllContextReceiverType(final Type... values) {
      initContextReceiverType();
      bitField0_ |= 0x00020000;
      contextReceiverType.addAll(values);
      return this;
    }

    private void initAnnotation() {
      if (annotation == null) {
        annotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 14;</code>
     * @return whether the annotation field is set
     */
    public boolean hasAnnotation() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 14;</code>
     * @return this
     */
    public Property clearAnnotation() {
      bitField0_ &= ~0x00000080;
      if (annotation != null) {
        annotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 14;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getAnnotation() {
      initAnnotation();
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 14;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableAnnotation() {
      initAnnotation();
      bitField0_ |= 0x00000080;
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 14;</code>
     * @param value the annotation to add
     * @return this
     */
    public Property addAnnotation(final Annotation value) {
      initAnnotation();
      bitField0_ |= 0x00000080;
      annotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 14;</code>
     * @param values the annotation to add
     * @return this
     */
    public Property addAllAnnotation(final Annotation... values) {
      initAnnotation();
      bitField0_ |= 0x00000080;
      annotation.addAll(values);
      return this;
    }

    private void initGetterAnnotation() {
      if (getterAnnotation == null) {
        getterAnnotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation getter_annotation = 15;</code>
     * @return whether the getterAnnotation field is set
     */
    public boolean hasGetterAnnotation() {
      return (bitField0_ & 0x00040000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation getter_annotation = 15;</code>
     * @return this
     */
    public Property clearGetterAnnotation() {
      bitField0_ &= ~0x00040000;
      if (getterAnnotation != null) {
        getterAnnotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation getter_annotation = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGetterAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getGetterAnnotation() {
      initGetterAnnotation();
      return getterAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation getter_annotation = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableGetterAnnotation() {
      initGetterAnnotation();
      bitField0_ |= 0x00040000;
      return getterAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation getter_annotation = 15;</code>
     * @param value the getterAnnotation to add
     * @return this
     */
    public Property addGetterAnnotation(final Annotation value) {
      initGetterAnnotation();
      bitField0_ |= 0x00040000;
      getterAnnotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation getter_annotation = 15;</code>
     * @param values the getterAnnotation to add
     * @return this
     */
    public Property addAllGetterAnnotation(final Annotation... values) {
      initGetterAnnotation();
      bitField0_ |= 0x00040000;
      getterAnnotation.addAll(values);
      return this;
    }

    private void initSetterAnnotation() {
      if (setterAnnotation == null) {
        setterAnnotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation setter_annotation = 16;</code>
     * @return whether the setterAnnotation field is set
     */
    public boolean hasSetterAnnotation() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation setter_annotation = 16;</code>
     * @return this
     */
    public Property clearSetterAnnotation() {
      bitField0_ &= ~0x00000100;
      if (setterAnnotation != null) {
        setterAnnotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation setter_annotation = 16;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSetterAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getSetterAnnotation() {
      initSetterAnnotation();
      return setterAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation setter_annotation = 16;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableSetterAnnotation() {
      initSetterAnnotation();
      bitField0_ |= 0x00000100;
      return setterAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation setter_annotation = 16;</code>
     * @param value the setterAnnotation to add
     * @return this
     */
    public Property addSetterAnnotation(final Annotation value) {
      initSetterAnnotation();
      bitField0_ |= 0x00000100;
      setterAnnotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation setter_annotation = 16;</code>
     * @param values the setterAnnotation to add
     * @return this
     */
    public Property addAllSetterAnnotation(final Annotation... values) {
      initSetterAnnotation();
      bitField0_ |= 0x00000100;
      setterAnnotation.addAll(values);
      return this;
    }

    private void initContextParameter() {
      if (contextParameter == null) {
        contextParameter = RepeatedMessage.newEmptyInstance(ValueParameter.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 17;</code>
     * @return whether the contextParameter field is set
     */
    public boolean hasContextParameter() {
      return (bitField0_ & 0x00080000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 17;</code>
     * @return this
     */
    public Property clearContextParameter() {
      bitField0_ &= ~0x00080000;
      if (contextParameter != null) {
        contextParameter.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 17;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContextParameter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ValueParameter> getContextParameter() {
      initContextParameter();
      return contextParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 17;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ValueParameter> getMutableContextParameter() {
      initContextParameter();
      bitField0_ |= 0x00080000;
      return contextParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 17;</code>
     * @param value the contextParameter to add
     * @return this
     */
    public Property addContextParameter(final ValueParameter value) {
      initContextParameter();
      bitField0_ |= 0x00080000;
      contextParameter.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.ValueParameter context_parameter = 17;</code>
     * @param values the contextParameter to add
     * @return this
     */
    public Property addAllContextParameter(final ValueParameter... values) {
      initContextParameter();
      bitField0_ |= 0x00080000;
      contextParameter.addAll(values);
      return this;
    }

    private void initCompilerPluginData() {
      if (compilerPluginData == null) {
        compilerPluginData = RepeatedMessage.newEmptyInstance(CompilerPluginData.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @return whether the compilerPluginData field is set
     */
    public boolean hasCompilerPluginData() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @return this
     */
    public Property clearCompilerPluginData() {
      bitField0_ &= ~0x00000200;
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCompilerPluginData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CompilerPluginData> getCompilerPluginData() {
      initCompilerPluginData();
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CompilerPluginData> getMutableCompilerPluginData() {
      initCompilerPluginData();
      bitField0_ |= 0x00000200;
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @param value the compilerPluginData to add
     * @return this
     */
    public Property addCompilerPluginData(final CompilerPluginData value) {
      initCompilerPluginData();
      bitField0_ |= 0x00000200;
      compilerPluginData.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @param values the compilerPluginData to add
     * @return this
     */
    public Property addAllCompilerPluginData(final CompilerPluginData... values) {
      initCompilerPluginData();
      bitField0_ |= 0x00000200;
      compilerPluginData.addAll(values);
      return this;
    }

    private void initExtensionReceiverAnnotation() {
      if (extensionReceiverAnnotation == null) {
        extensionReceiverAnnotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 33;</code>
     * @return whether the extensionReceiverAnnotation field is set
     */
    public boolean hasExtensionReceiverAnnotation() {
      return (bitField0_ & 0x00100000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 33;</code>
     * @return this
     */
    public Property clearExtensionReceiverAnnotation() {
      bitField0_ &= ~0x00100000;
      if (extensionReceiverAnnotation != null) {
        extensionReceiverAnnotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 33;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableExtensionReceiverAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getExtensionReceiverAnnotation() {
      initExtensionReceiverAnnotation();
      return extensionReceiverAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 33;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableExtensionReceiverAnnotation() {
      initExtensionReceiverAnnotation();
      bitField0_ |= 0x00100000;
      return extensionReceiverAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 33;</code>
     * @param value the extensionReceiverAnnotation to add
     * @return this
     */
    public Property addExtensionReceiverAnnotation(final Annotation value) {
      initExtensionReceiverAnnotation();
      bitField0_ |= 0x00100000;
      extensionReceiverAnnotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation extension_receiver_annotation = 33;</code>
     * @param values the extensionReceiverAnnotation to add
     * @return this
     */
    public Property addAllExtensionReceiverAnnotation(final Annotation... values) {
      initExtensionReceiverAnnotation();
      bitField0_ |= 0x00100000;
      extensionReceiverAnnotation.addAll(values);
      return this;
    }

    private void initBackingFieldAnnotation() {
      if (backingFieldAnnotation == null) {
        backingFieldAnnotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation backing_field_annotation = 34;</code>
     * @return whether the backingFieldAnnotation field is set
     */
    public boolean hasBackingFieldAnnotation() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation backing_field_annotation = 34;</code>
     * @return this
     */
    public Property clearBackingFieldAnnotation() {
      bitField0_ &= ~0x00000400;
      if (backingFieldAnnotation != null) {
        backingFieldAnnotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation backing_field_annotation = 34;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBackingFieldAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getBackingFieldAnnotation() {
      initBackingFieldAnnotation();
      return backingFieldAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation backing_field_annotation = 34;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableBackingFieldAnnotation() {
      initBackingFieldAnnotation();
      bitField0_ |= 0x00000400;
      return backingFieldAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation backing_field_annotation = 34;</code>
     * @param value the backingFieldAnnotation to add
     * @return this
     */
    public Property addBackingFieldAnnotation(final Annotation value) {
      initBackingFieldAnnotation();
      bitField0_ |= 0x00000400;
      backingFieldAnnotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation backing_field_annotation = 34;</code>
     * @param values the backingFieldAnnotation to add
     * @return this
     */
    public Property addAllBackingFieldAnnotation(final Annotation... values) {
      initBackingFieldAnnotation();
      bitField0_ |= 0x00000400;
      backingFieldAnnotation.addAll(values);
      return this;
    }

    private void initDelegateFieldAnnotation() {
      if (delegateFieldAnnotation == null) {
        delegateFieldAnnotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation delegate_field_annotation = 35;</code>
     * @return whether the delegateFieldAnnotation field is set
     */
    public boolean hasDelegateFieldAnnotation() {
      return (bitField0_ & 0x00200000) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation delegate_field_annotation = 35;</code>
     * @return this
     */
    public Property clearDelegateFieldAnnotation() {
      bitField0_ &= ~0x00200000;
      if (delegateFieldAnnotation != null) {
        delegateFieldAnnotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation delegate_field_annotation = 35;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDelegateFieldAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getDelegateFieldAnnotation() {
      initDelegateFieldAnnotation();
      return delegateFieldAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation delegate_field_annotation = 35;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableDelegateFieldAnnotation() {
      initDelegateFieldAnnotation();
      bitField0_ |= 0x00200000;
      return delegateFieldAnnotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation delegate_field_annotation = 35;</code>
     * @param value the delegateFieldAnnotation to add
     * @return this
     */
    public Property addDelegateFieldAnnotation(final Annotation value) {
      initDelegateFieldAnnotation();
      bitField0_ |= 0x00200000;
      delegateFieldAnnotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation delegate_field_annotation = 35;</code>
     * @param values the delegateFieldAnnotation to add
     * @return this
     */
    public Property addAllDelegateFieldAnnotation(final Annotation... values) {
      initDelegateFieldAnnotation();
      bitField0_ |= 0x00200000;
      delegateFieldAnnotation.addAll(values);
      return this;
    }

    @Override
    public Property copyFrom(final Property other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        oldFlags = other.oldFlags;
        name = other.name;
        getterFlags = other.getterFlags;
        setterFlags = other.setterFlags;
        returnTypeId = other.returnTypeId;
        receiverTypeId = other.receiverTypeId;
        flags = other.flags;
        if (other.hasReturnType()) {
          initReturnType();
          returnType.copyFrom(other.returnType);
        } else {
          clearReturnType();
        }
        if (other.hasReceiverType()) {
          initReceiverType();
          receiverType.copyFrom(other.receiverType);
        } else {
          clearReceiverType();
        }
        if (other.hasSetterValueParameter()) {
          initSetterValueParameter();
          setterValueParameter.copyFrom(other.setterValueParameter);
        } else {
          clearSetterValueParameter();
        }
        if (other.hasContextReceiverTypeId()) {
          initContextReceiverTypeId();
          contextReceiverTypeId.copyFrom(other.contextReceiverTypeId);
        } else {
          clearContextReceiverTypeId();
        }
        if (other.hasVersionRequirement()) {
          initVersionRequirement();
          versionRequirement.copyFrom(other.versionRequirement);
        } else {
          clearVersionRequirement();
        }
        if (other.hasTypeParameter()) {
          initTypeParameter();
          typeParameter.copyFrom(other.typeParameter);
        } else {
          clearTypeParameter();
        }
        if (other.hasContextReceiverType()) {
          initContextReceiverType();
          contextReceiverType.copyFrom(other.contextReceiverType);
        } else {
          clearContextReceiverType();
        }
        if (other.hasAnnotation()) {
          initAnnotation();
          annotation.copyFrom(other.annotation);
        } else {
          clearAnnotation();
        }
        if (other.hasGetterAnnotation()) {
          initGetterAnnotation();
          getterAnnotation.copyFrom(other.getterAnnotation);
        } else {
          clearGetterAnnotation();
        }
        if (other.hasSetterAnnotation()) {
          initSetterAnnotation();
          setterAnnotation.copyFrom(other.setterAnnotation);
        } else {
          clearSetterAnnotation();
        }
        if (other.hasContextParameter()) {
          initContextParameter();
          contextParameter.copyFrom(other.contextParameter);
        } else {
          clearContextParameter();
        }
        if (other.hasCompilerPluginData()) {
          initCompilerPluginData();
          compilerPluginData.copyFrom(other.compilerPluginData);
        } else {
          clearCompilerPluginData();
        }
        if (other.hasExtensionReceiverAnnotation()) {
          initExtensionReceiverAnnotation();
          extensionReceiverAnnotation.copyFrom(other.extensionReceiverAnnotation);
        } else {
          clearExtensionReceiverAnnotation();
        }
        if (other.hasBackingFieldAnnotation()) {
          initBackingFieldAnnotation();
          backingFieldAnnotation.copyFrom(other.backingFieldAnnotation);
        } else {
          clearBackingFieldAnnotation();
        }
        if (other.hasDelegateFieldAnnotation()) {
          initDelegateFieldAnnotation();
          delegateFieldAnnotation.copyFrom(other.delegateFieldAnnotation);
        } else {
          clearDelegateFieldAnnotation();
        }
      }
      return this;
    }

    @Override
    public Property mergeFrom(final Property other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasOldFlags()) {
        setOldFlags(other.oldFlags);
      }
      if (other.hasName()) {
        setName(other.name);
      }
      if (other.hasGetterFlags()) {
        setGetterFlags(other.getterFlags);
      }
      if (other.hasSetterFlags()) {
        setSetterFlags(other.setterFlags);
      }
      if (other.hasReturnTypeId()) {
        setReturnTypeId(other.returnTypeId);
      }
      if (other.hasReceiverTypeId()) {
        setReceiverTypeId(other.receiverTypeId);
      }
      if (other.hasFlags()) {
        setFlags(other.flags);
      }
      if (other.hasReturnType()) {
        getMutableReturnType().mergeFrom(other.returnType);
      }
      if (other.hasReceiverType()) {
        getMutableReceiverType().mergeFrom(other.receiverType);
      }
      if (other.hasSetterValueParameter()) {
        getMutableSetterValueParameter().mergeFrom(other.setterValueParameter);
      }
      if (other.hasContextReceiverTypeId()) {
        getMutableContextReceiverTypeId().addAll(other.contextReceiverTypeId);
      }
      if (other.hasVersionRequirement()) {
        getMutableVersionRequirement().addAll(other.versionRequirement);
      }
      if (other.hasTypeParameter()) {
        getMutableTypeParameter().addAll(other.typeParameter);
      }
      if (other.hasContextReceiverType()) {
        getMutableContextReceiverType().addAll(other.contextReceiverType);
      }
      if (other.hasAnnotation()) {
        getMutableAnnotation().addAll(other.annotation);
      }
      if (other.hasGetterAnnotation()) {
        getMutableGetterAnnotation().addAll(other.getterAnnotation);
      }
      if (other.hasSetterAnnotation()) {
        getMutableSetterAnnotation().addAll(other.setterAnnotation);
      }
      if (other.hasContextParameter()) {
        getMutableContextParameter().addAll(other.contextParameter);
      }
      if (other.hasCompilerPluginData()) {
        getMutableCompilerPluginData().addAll(other.compilerPluginData);
      }
      if (other.hasExtensionReceiverAnnotation()) {
        getMutableExtensionReceiverAnnotation().addAll(other.extensionReceiverAnnotation);
      }
      if (other.hasBackingFieldAnnotation()) {
        getMutableBackingFieldAnnotation().addAll(other.backingFieldAnnotation);
      }
      if (other.hasDelegateFieldAnnotation()) {
        getMutableDelegateFieldAnnotation().addAll(other.delegateFieldAnnotation);
      }
      return this;
    }

    @Override
    public Property clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      oldFlags = 2054;
      name = 0;
      getterFlags = 0;
      setterFlags = 0;
      returnTypeId = 0;
      receiverTypeId = 0;
      flags = 518;
      if (returnType != null) {
        returnType.clear();
      }
      if (receiverType != null) {
        receiverType.clear();
      }
      if (setterValueParameter != null) {
        setterValueParameter.clear();
      }
      if (contextReceiverTypeId != null) {
        contextReceiverTypeId.clear();
      }
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (typeParameter != null) {
        typeParameter.clear();
      }
      if (contextReceiverType != null) {
        contextReceiverType.clear();
      }
      if (annotation != null) {
        annotation.clear();
      }
      if (getterAnnotation != null) {
        getterAnnotation.clear();
      }
      if (setterAnnotation != null) {
        setterAnnotation.clear();
      }
      if (contextParameter != null) {
        contextParameter.clear();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      if (extensionReceiverAnnotation != null) {
        extensionReceiverAnnotation.clear();
      }
      if (backingFieldAnnotation != null) {
        backingFieldAnnotation.clear();
      }
      if (delegateFieldAnnotation != null) {
        delegateFieldAnnotation.clear();
      }
      return this;
    }

    @Override
    public Property clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (returnType != null) {
        returnType.clearQuick();
      }
      if (receiverType != null) {
        receiverType.clearQuick();
      }
      if (setterValueParameter != null) {
        setterValueParameter.clearQuick();
      }
      if (contextReceiverTypeId != null) {
        contextReceiverTypeId.clear();
      }
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (typeParameter != null) {
        typeParameter.clearQuick();
      }
      if (contextReceiverType != null) {
        contextReceiverType.clearQuick();
      }
      if (annotation != null) {
        annotation.clearQuick();
      }
      if (getterAnnotation != null) {
        getterAnnotation.clearQuick();
      }
      if (setterAnnotation != null) {
        setterAnnotation.clearQuick();
      }
      if (contextParameter != null) {
        contextParameter.clearQuick();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clearQuick();
      }
      if (extensionReceiverAnnotation != null) {
        extensionReceiverAnnotation.clearQuick();
      }
      if (backingFieldAnnotation != null) {
        backingFieldAnnotation.clearQuick();
      }
      if (delegateFieldAnnotation != null) {
        delegateFieldAnnotation.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Property)) {
        return false;
      }
      Property other = (Property) o;
      return bitField0_ == other.bitField0_
        && (!hasOldFlags() || oldFlags == other.oldFlags)
        && (!hasName() || name == other.name)
        && (!hasGetterFlags() || getterFlags == other.getterFlags)
        && (!hasSetterFlags() || setterFlags == other.setterFlags)
        && (!hasReturnTypeId() || returnTypeId == other.returnTypeId)
        && (!hasReceiverTypeId() || receiverTypeId == other.receiverTypeId)
        && (!hasFlags() || flags == other.flags)
        && (!hasReturnType() || returnType.equals(other.returnType))
        && (!hasReceiverType() || receiverType.equals(other.receiverType))
        && (!hasSetterValueParameter() || setterValueParameter.equals(other.setterValueParameter))
        && (!hasContextReceiverTypeId() || contextReceiverTypeId.equals(other.contextReceiverTypeId))
        && (!hasVersionRequirement() || versionRequirement.equals(other.versionRequirement))
        && (!hasTypeParameter() || typeParameter.equals(other.typeParameter))
        && (!hasContextReceiverType() || contextReceiverType.equals(other.contextReceiverType))
        && (!hasAnnotation() || annotation.equals(other.annotation))
        && (!hasGetterAnnotation() || getterAnnotation.equals(other.getterAnnotation))
        && (!hasSetterAnnotation() || setterAnnotation.equals(other.setterAnnotation))
        && (!hasContextParameter() || contextParameter.equals(other.contextParameter))
        && (!hasCompilerPluginData() || compilerPluginData.equals(other.compilerPluginData))
        && (!hasExtensionReceiverAnnotation() || extensionReceiverAnnotation.equals(other.extensionReceiverAnnotation))
        && (!hasBackingFieldAnnotation() || backingFieldAnnotation.equals(other.backingFieldAnnotation))
        && (!hasDelegateFieldAnnotation() || delegateFieldAnnotation.equals(other.delegateFieldAnnotation));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000800) != 0x00000800))) {
        throw new UninitializedMessageException(this);
      }
      try {
        if ((bitField0_ & 0x00001000) != 0) {
          output.writeRawByte((byte) 8);
          output.writeInt32NoTag(oldFlags);
        }
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 56);
          output.writeInt32NoTag(getterFlags);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 64);
          output.writeInt32NoTag(setterFlags);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 72);
          output.writeInt32NoTag(returnTypeId);
        }
        if ((bitField0_ & 0x00002000) != 0) {
          output.writeRawByte((byte) 80);
          output.writeInt32NoTag(receiverTypeId);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRawByte((byte) 88);
          output.writeInt32NoTag(flags);
        }
        if ((bitField0_ & 0x00004000) != 0) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(returnType);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRawByte((byte) 42);
          output.writeMessageNoTag(receiverType);
        }
        if ((bitField0_ & 0x00008000) != 0) {
          output.writeRawByte((byte) 50);
          output.writeMessageNoTag(setterValueParameter);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRawByte((byte) 106);
          output.writePackedInt32NoTag(contextReceiverTypeId);
        }
        if ((bitField0_ & 0x00010000) != 0) {
          for (int i = 0; i < versionRequirement.length(); i++) {
            output.writeRawLittleEndian16((short) 504);
            output.writeInt32NoTag(versionRequirement.array()[i]);
          }
        }
        if ((bitField0_ & 0x00000040) != 0) {
          for (int i = 0; i < typeParameter.length(); i++) {
            output.writeRawByte((byte) 34);
            output.writeMessageNoTag(typeParameter.get(i));
          }
        }
        if ((bitField0_ & 0x00020000) != 0) {
          for (int i = 0; i < contextReceiverType.length(); i++) {
            output.writeRawByte((byte) 98);
            output.writeMessageNoTag(contextReceiverType.get(i));
          }
        }
        if ((bitField0_ & 0x00000080) != 0) {
          for (int i = 0; i < annotation.length(); i++) {
            output.writeRawByte((byte) 114);
            output.writeMessageNoTag(annotation.get(i));
          }
        }
        if ((bitField0_ & 0x00040000) != 0) {
          for (int i = 0; i < getterAnnotation.length(); i++) {
            output.writeRawByte((byte) 122);
            output.writeMessageNoTag(getterAnnotation.get(i));
          }
        }
        if ((bitField0_ & 0x00000100) != 0) {
          for (int i = 0; i < setterAnnotation.length(); i++) {
            output.writeRawLittleEndian16((short) 386);
            output.writeMessageNoTag(setterAnnotation.get(i));
          }
        }
        if ((bitField0_ & 0x00080000) != 0) {
          for (int i = 0; i < contextParameter.length(); i++) {
            output.writeRawLittleEndian16((short) 394);
            output.writeMessageNoTag(contextParameter.get(i));
          }
        }
        if ((bitField0_ & 0x00000200) != 0) {
          for (int i = 0; i < compilerPluginData.length(); i++) {
            output.writeRawLittleEndian16((short) 642);
            output.writeMessageNoTag(compilerPluginData.get(i));
          }
        }
        if ((bitField0_ & 0x00100000) != 0) {
          for (int i = 0; i < extensionReceiverAnnotation.length(); i++) {
            output.writeRawLittleEndian16((short) 650);
            output.writeMessageNoTag(extensionReceiverAnnotation.get(i));
          }
        }
        if ((bitField0_ & 0x00000400) != 0) {
          for (int i = 0; i < backingFieldAnnotation.length(); i++) {
            output.writeRawLittleEndian16((short) 658);
            output.writeMessageNoTag(backingFieldAnnotation.get(i));
          }
        }
        if ((bitField0_ & 0x00200000) != 0) {
          for (int i = 0; i < delegateFieldAnnotation.length(); i++) {
            output.writeRawLittleEndian16((short) 666);
            output.writeMessageNoTag(delegateFieldAnnotation.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000800) != 0x00000800))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        if ((bitField0_ & 0x00001000) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(oldFlags);
        }
        size += 1 + ProtoSink.computeInt32SizeNoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(getterFlags);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(setterFlags);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(returnTypeId);
        }
        if ((bitField0_ & 0x00002000) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(receiverTypeId);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(flags);
        }
        if ((bitField0_ & 0x00004000) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(returnType);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(receiverType);
        }
        if ((bitField0_ & 0x00008000) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(setterValueParameter);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(contextReceiverTypeId);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00010000) != 0) {
          size += (2 * versionRequirement.length()) + ProtoSink.computeRepeatedInt32SizeNoTag(versionRequirement);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          size += (1 * typeParameter.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(typeParameter);
        }
        if ((bitField0_ & 0x00020000) != 0) {
          size += (1 * contextReceiverType.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(contextReceiverType);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          size += (1 * annotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(annotation);
        }
        if ((bitField0_ & 0x00040000) != 0) {
          size += (1 * getterAnnotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(getterAnnotation);
        }
        if ((bitField0_ & 0x00000100) != 0) {
          size += (2 * setterAnnotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(setterAnnotation);
        }
        if ((bitField0_ & 0x00080000) != 0) {
          size += (2 * contextParameter.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(contextParameter);
        }
        if ((bitField0_ & 0x00000200) != 0) {
          size += (2 * compilerPluginData.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(compilerPluginData);
        }
        if ((bitField0_ & 0x00100000) != 0) {
          size += (2 * extensionReceiverAnnotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(extensionReceiverAnnotation);
        }
        if ((bitField0_ & 0x00000400) != 0) {
          size += (2 * backingFieldAnnotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(backingFieldAnnotation);
        }
        if ((bitField0_ & 0x00200000) != 0) {
          size += (2 * delegateFieldAnnotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(delegateFieldAnnotation);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Property mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // oldFlags
            oldFlags = input.readInt32();
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // name
            name = input.readInt32();
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // getterFlags
            getterFlags = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // setterFlags
            setterFlags = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // returnTypeId
            returnTypeId = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 80) {
              break;
            }
          }
          case 80: {
            // receiverTypeId
            receiverTypeId = input.readInt32();
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 88) {
              break;
            }
          }
          case 88: {
            // flags
            flags = input.readInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // returnType
            initReturnType();
            input.readMessage(returnType);
            bitField0_ |= 0x00004000;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // receiverType
            initReceiverType();
            input.readMessage(receiverType);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // setterValueParameter
            initSetterValueParameter();
            input.readMessage(setterValueParameter);
            bitField0_ |= 0x00008000;
            tag = input.readTag();
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // contextReceiverTypeId [packed=true]
            initContextReceiverTypeId();
            input.readPackedInt32(contextReceiverTypeId, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 250) {
              break;
            }
          }
          case 250: {
            // versionRequirement [packed=true]
            initVersionRequirement();
            input.readPackedInt32(versionRequirement, tag);
            bitField0_ |= 0x00010000;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // typeParameter
            initTypeParameter();
            tag = input.readRepeatedMessage(typeParameter, tag);
            bitField0_ |= 0x00000040;
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // contextReceiverType
            initContextReceiverType();
            tag = input.readRepeatedMessage(contextReceiverType, tag);
            bitField0_ |= 0x00020000;
            if (tag != 114) {
              break;
            }
          }
          case 114: {
            // annotation
            initAnnotation();
            tag = input.readRepeatedMessage(annotation, tag);
            bitField0_ |= 0x00000080;
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // getterAnnotation
            initGetterAnnotation();
            tag = input.readRepeatedMessage(getterAnnotation, tag);
            bitField0_ |= 0x00040000;
            if (tag != 130) {
              break;
            }
          }
          case 130: {
            // setterAnnotation
            initSetterAnnotation();
            tag = input.readRepeatedMessage(setterAnnotation, tag);
            bitField0_ |= 0x00000100;
            if (tag != 138) {
              break;
            }
          }
          case 138: {
            // contextParameter
            initContextParameter();
            tag = input.readRepeatedMessage(contextParameter, tag);
            bitField0_ |= 0x00080000;
            if (tag != 258) {
              break;
            }
          }
          case 258: {
            // compilerPluginData
            initCompilerPluginData();
            tag = input.readRepeatedMessage(compilerPluginData, tag);
            bitField0_ |= 0x00000200;
            if (tag != 266) {
              break;
            }
          }
          case 266: {
            // extensionReceiverAnnotation
            initExtensionReceiverAnnotation();
            tag = input.readRepeatedMessage(extensionReceiverAnnotation, tag);
            bitField0_ |= 0x00100000;
            if (tag != 274) {
              break;
            }
          }
          case 274: {
            // backingFieldAnnotation
            initBackingFieldAnnotation();
            tag = input.readRepeatedMessage(backingFieldAnnotation, tag);
            bitField0_ |= 0x00000400;
            if (tag != 282) {
              break;
            }
          }
          case 282: {
            // delegateFieldAnnotation
            initDelegateFieldAnnotation();
            tag = input.readRepeatedMessage(delegateFieldAnnotation, tag);
            bitField0_ |= 0x00200000;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 104: {
            // contextReceiverTypeId [packed=false]
            initContextReceiverTypeId();
            tag = input.readRepeatedInt32(contextReceiverTypeId, tag);
            bitField0_ |= 0x00000020;
            break;
          }
          case 248: {
            // versionRequirement [packed=false]
            initVersionRequirement();
            tag = input.readRepeatedInt32(versionRequirement, tag);
            bitField0_ |= 0x00010000;
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000800) != 0x00000800))) {
        return false;
      }
      if (hasSetterValueParameter() && !setterValueParameter.isInitialized()) {
        return false;
      }
      if (hasTypeParameter() && !typeParameter.isInitialized()) {
        return false;
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        return false;
      }
      if (hasGetterAnnotation() && !getterAnnotation.isInitialized()) {
        return false;
      }
      if (hasSetterAnnotation() && !setterAnnotation.isInitialized()) {
        return false;
      }
      if (hasContextParameter() && !contextParameter.isInitialized()) {
        return false;
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        return false;
      }
      if (hasExtensionReceiverAnnotation() && !extensionReceiverAnnotation.isInitialized()) {
        return false;
      }
      if (hasBackingFieldAnnotation() && !backingFieldAnnotation.isInitialized()) {
        return false;
      }
      if (hasDelegateFieldAnnotation() && !delegateFieldAnnotation.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasName()) {
        results.add(prefix + "name");
      }
      if (hasSetterValueParameter() && !setterValueParameter.isInitialized()) {
        getMissingFields(prefix, "setter_value_parameter", setterValueParameter, results);
      }
      if (hasTypeParameter() && !typeParameter.isInitialized()) {
        getMissingFields(prefix, "type_parameter", typeParameter, results);
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        getMissingFields(prefix, "annotation", annotation, results);
      }
      if (hasGetterAnnotation() && !getterAnnotation.isInitialized()) {
        getMissingFields(prefix, "getter_annotation", getterAnnotation, results);
      }
      if (hasSetterAnnotation() && !setterAnnotation.isInitialized()) {
        getMissingFields(prefix, "setter_annotation", setterAnnotation, results);
      }
      if (hasContextParameter() && !contextParameter.isInitialized()) {
        getMissingFields(prefix, "context_parameter", contextParameter, results);
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        getMissingFields(prefix, "compiler_plugin_data", compilerPluginData, results);
      }
      if (hasExtensionReceiverAnnotation() && !extensionReceiverAnnotation.isInitialized()) {
        getMissingFields(prefix, "extension_receiver_annotation", extensionReceiverAnnotation, results);
      }
      if (hasBackingFieldAnnotation() && !backingFieldAnnotation.isInitialized()) {
        getMissingFields(prefix, "backing_field_annotation", backingFieldAnnotation, results);
      }
      if (hasDelegateFieldAnnotation() && !delegateFieldAnnotation.isInitialized()) {
        getMissingFields(prefix, "delegate_field_annotation", delegateFieldAnnotation, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000800) != 0x00000800))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        if ((bitField0_ & 0x00001000) != 0) {
          output.writeInt32(FieldNames.oldFlags, oldFlags);
        }
        output.writeInt32(FieldNames.name, name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt32(FieldNames.getterFlags, getterFlags);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeInt32(FieldNames.setterFlags, setterFlags);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeInt32(FieldNames.returnTypeId, returnTypeId);
        }
        if ((bitField0_ & 0x00002000) != 0) {
          output.writeInt32(FieldNames.receiverTypeId, receiverTypeId);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeInt32(FieldNames.flags, flags);
        }
        if ((bitField0_ & 0x00004000) != 0) {
          output.writeMessage(FieldNames.returnType, returnType);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeMessage(FieldNames.receiverType, receiverType);
        }
        if ((bitField0_ & 0x00008000) != 0) {
          output.writeMessage(FieldNames.setterValueParameter, setterValueParameter);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRepeatedInt32(FieldNames.contextReceiverTypeId, contextReceiverTypeId);
        }
        if ((bitField0_ & 0x00010000) != 0) {
          output.writeRepeatedInt32(FieldNames.versionRequirement, versionRequirement);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          output.writeRepeatedMessage(FieldNames.typeParameter, typeParameter);
        }
        if ((bitField0_ & 0x00020000) != 0) {
          output.writeRepeatedMessage(FieldNames.contextReceiverType, contextReceiverType);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          output.writeRepeatedMessage(FieldNames.annotation, annotation);
        }
        if ((bitField0_ & 0x00040000) != 0) {
          output.writeRepeatedMessage(FieldNames.getterAnnotation, getterAnnotation);
        }
        if ((bitField0_ & 0x00000100) != 0) {
          output.writeRepeatedMessage(FieldNames.setterAnnotation, setterAnnotation);
        }
        if ((bitField0_ & 0x00080000) != 0) {
          output.writeRepeatedMessage(FieldNames.contextParameter, contextParameter);
        }
        if ((bitField0_ & 0x00000200) != 0) {
          output.writeRepeatedMessage(FieldNames.compilerPluginData, compilerPluginData);
        }
        if ((bitField0_ & 0x00100000) != 0) {
          output.writeRepeatedMessage(FieldNames.extensionReceiverAnnotation, extensionReceiverAnnotation);
        }
        if ((bitField0_ & 0x00000400) != 0) {
          output.writeRepeatedMessage(FieldNames.backingFieldAnnotation, backingFieldAnnotation);
        }
        if ((bitField0_ & 0x00200000) != 0) {
          output.writeRepeatedMessage(FieldNames.delegateFieldAnnotation, delegateFieldAnnotation);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Property mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 175444128:
          case 1854309999: {
            if (input.isAtField(FieldNames.oldFlags)) {
              if (!input.trySkipNullValue()) {
                oldFlags = input.readInt32();
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3373707: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                name = input.readInt32();
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 796066876:
          case -381221293: {
            if (input.isAtField(FieldNames.getterFlags)) {
              if (!input.trySkipNullValue()) {
                getterFlags = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 707487048:
          case 1167771335: {
            if (input.isAtField(FieldNames.setterFlags)) {
              if (!input.trySkipNullValue()) {
                setterFlags = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 860632901:
          case 256676913: {
            if (input.isAtField(FieldNames.returnTypeId)) {
              if (!input.trySkipNullValue()) {
                returnTypeId = input.readInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 278862020:
          case -479391248: {
            if (input.isAtField(FieldNames.receiverTypeId)) {
              if (!input.trySkipNullValue()) {
                receiverTypeId = input.readInt32();
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 97513095: {
            if (input.isAtField(FieldNames.flags)) {
              if (!input.trySkipNullValue()) {
                flags = input.readInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1337206922:
          case -1486239511: {
            if (input.isAtField(FieldNames.returnType)) {
              if (!input.trySkipNullValue()) {
                initReturnType();
                input.readMessage(returnType);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -755016247:
          case -1920648310: {
            if (input.isAtField(FieldNames.receiverType)) {
              if (!input.trySkipNullValue()) {
                initReceiverType();
                input.readMessage(receiverType);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1412832361:
          case -1192792421: {
            if (input.isAtField(FieldNames.setterValueParameter)) {
              if (!input.trySkipNullValue()) {
                initSetterValueParameter();
                input.readMessage(setterValueParameter);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -614859693:
          case -769035648: {
            if (input.isAtField(FieldNames.contextReceiverTypeId)) {
              if (!input.trySkipNullValue()) {
                initContextReceiverTypeId();
                input.readRepeatedInt32(contextReceiverTypeId);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 351760459:
          case -783428772: {
            if (input.isAtField(FieldNames.versionRequirement)) {
              if (!input.trySkipNullValue()) {
                initVersionRequirement();
                input.readRepeatedInt32(versionRequirement);
                bitField0_ |= 0x00010000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 659473807:
          case 1277164772: {
            if (input.isAtField(FieldNames.typeParameter)) {
              if (!input.trySkipNullValue()) {
                initTypeParameter();
                input.readRepeatedMessage(typeParameter);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -420751080:
          case 1699161338: {
            if (input.isAtField(FieldNames.contextReceiverType)) {
              if (!input.trySkipNullValue()) {
                initContextReceiverType();
                input.readRepeatedMessage(contextReceiverType);
                bitField0_ |= 0x00020000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1555043537: {
            if (input.isAtField(FieldNames.annotation)) {
              if (!input.trySkipNullValue()) {
                initAnnotation();
                input.readRepeatedMessage(annotation);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 305077914:
          case -305409309: {
            if (input.isAtField(FieldNames.getterAnnotation)) {
              if (!input.trySkipNullValue()) {
                initGetterAnnotation();
                input.readRepeatedMessage(getterAnnotation);
                bitField0_ |= 0x00040000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1526364914:
          case -1245562129: {
            if (input.isAtField(FieldNames.setterAnnotation)) {
              if (!input.trySkipNullValue()) {
                initSetterAnnotation();
                input.readRepeatedMessage(setterAnnotation);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1011248454:
          case 1024382233: {
            if (input.isAtField(FieldNames.contextParameter)) {
              if (!input.trySkipNullValue()) {
                initContextParameter();
                input.readRepeatedMessage(contextParameter);
                bitField0_ |= 0x00080000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1393610620:
          case -1920592490: {
            if (input.isAtField(FieldNames.compilerPluginData)) {
              if (!input.trySkipNullValue()) {
                initCompilerPluginData();
                input.readRepeatedMessage(compilerPluginData);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1811859171:
          case -1167446145: {
            if (input.isAtField(FieldNames.extensionReceiverAnnotation)) {
              if (!input.trySkipNullValue()) {
                initExtensionReceiverAnnotation();
                input.readRepeatedMessage(extensionReceiverAnnotation);
                bitField0_ |= 0x00100000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1417129810:
          case -1580010056: {
            if (input.isAtField(FieldNames.backingFieldAnnotation)) {
              if (!input.trySkipNullValue()) {
                initBackingFieldAnnotation();
                input.readRepeatedMessage(backingFieldAnnotation);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1508800388:
          case 1330298638: {
            if (input.isAtField(FieldNames.delegateFieldAnnotation)) {
              if (!input.trySkipNullValue()) {
                initDelegateFieldAnnotation();
                input.readRepeatedMessage(delegateFieldAnnotation);
                bitField0_ |= 0x00200000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Property clone() {
      return new Property().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Property parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Property(), data).checkInitialized();
    }

    public static Property parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Property(), input).checkInitialized();
    }

    public static Property parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Property(), input).checkInitialized();
    }

    /**
     * @return factory for creating Property messages
     */
    public static MessageFactory<Property> getFactory() {
      return PropertyFactory.INSTANCE;
    }

    private enum PropertyFactory implements MessageFactory<Property> {
      INSTANCE;

      @Override
      public Property create() {
        return Property.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName oldFlags = FieldName.forField("oldFlags", "old_flags");

      static final FieldName name = FieldName.forField("name");

      static final FieldName getterFlags = FieldName.forField("getterFlags", "getter_flags");

      static final FieldName setterFlags = FieldName.forField("setterFlags", "setter_flags");

      static final FieldName returnTypeId = FieldName.forField("returnTypeId", "return_type_id");

      static final FieldName receiverTypeId = FieldName.forField("receiverTypeId", "receiver_type_id");

      static final FieldName flags = FieldName.forField("flags");

      static final FieldName returnType = FieldName.forField("returnType", "return_type");

      static final FieldName receiverType = FieldName.forField("receiverType", "receiver_type");

      static final FieldName setterValueParameter = FieldName.forField("setterValueParameter", "setter_value_parameter");

      static final FieldName contextReceiverTypeId = FieldName.forField("contextReceiverTypeId", "context_receiver_type_id");

      static final FieldName versionRequirement = FieldName.forField("versionRequirement", "version_requirement");

      static final FieldName typeParameter = FieldName.forField("typeParameter", "type_parameter");

      static final FieldName contextReceiverType = FieldName.forField("contextReceiverType", "context_receiver_type");

      static final FieldName annotation = FieldName.forField("annotation");

      static final FieldName getterAnnotation = FieldName.forField("getterAnnotation", "getter_annotation");

      static final FieldName setterAnnotation = FieldName.forField("setterAnnotation", "setter_annotation");

      static final FieldName contextParameter = FieldName.forField("contextParameter", "context_parameter");

      static final FieldName compilerPluginData = FieldName.forField("compilerPluginData", "compiler_plugin_data");

      static final FieldName extensionReceiverAnnotation = FieldName.forField("extensionReceiverAnnotation", "extension_receiver_annotation");

      static final FieldName backingFieldAnnotation = FieldName.forField("backingFieldAnnotation", "backing_field_annotation");

      static final FieldName delegateFieldAnnotation = FieldName.forField("delegateFieldAnnotation", "delegate_field_annotation");
    }
  }

  /**
   * Protobuf type {@code ValueParameter}
   */
  public static final class ValueParameter extends ProtoMessage<ValueParameter> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     */
    private int flags = 0;

    /**
     * <code>required int32 name = 2;</code>
     */
    private int name;

    /**
     * <code>optional int32 type_id = 5;</code>
     */
    private int typeId;

    /**
     * <code>optional int32 vararg_element_type_id = 6;</code>
     */
    private int varargElementTypeId;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type type = 3;</code>
     */
    private Type type = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type vararg_element_type = 4;</code>
     */
    private Type varargElementType = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value annotation_parameter_default_value = 8;</code>
     */
    private Annotation.Argument.Value annotationParameterDefaultValue = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 7;</code>
     */
    private RepeatedMessage<Annotation> annotation = null;

    private ValueParameter() {
    }

    /**
     * @return a new empty instance of {@code ValueParameter}
     */
    public static ValueParameter newInstance() {
      return new ValueParameter();
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     * @return whether the flags field is set
     */
    public boolean hasFlags() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     * @return this
     */
    public ValueParameter clearFlags() {
      bitField0_ &= ~0x00000020;
      flags = 0;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     * @return the flags
     */
    public int getFlags() {
      return flags;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     * @param value the flags to set
     * @return this
     */
    public ValueParameter setFlags(final int value) {
      bitField0_ |= 0x00000020;
      flags = value;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return this
     */
    public ValueParameter clearName() {
      bitField0_ &= ~0x00000010;
      name = 0;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return the name
     */
    public int getName() {
      return name;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @param value the name to set
     * @return this
     */
    public ValueParameter setName(final int value) {
      bitField0_ |= 0x00000010;
      name = value;
      return this;
    }

    /**
     * <code>optional int32 type_id = 5;</code>
     * @return whether the typeId field is set
     */
    public boolean hasTypeId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 type_id = 5;</code>
     * @return this
     */
    public ValueParameter clearTypeId() {
      bitField0_ &= ~0x00000001;
      typeId = 0;
      return this;
    }

    /**
     * <code>optional int32 type_id = 5;</code>
     * @return the typeId
     */
    public int getTypeId() {
      return typeId;
    }

    /**
     * <code>optional int32 type_id = 5;</code>
     * @param value the typeId to set
     * @return this
     */
    public ValueParameter setTypeId(final int value) {
      bitField0_ |= 0x00000001;
      typeId = value;
      return this;
    }

    /**
     * <code>optional int32 vararg_element_type_id = 6;</code>
     * @return whether the varargElementTypeId field is set
     */
    public boolean hasVarargElementTypeId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int32 vararg_element_type_id = 6;</code>
     * @return this
     */
    public ValueParameter clearVarargElementTypeId() {
      bitField0_ &= ~0x00000002;
      varargElementTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 vararg_element_type_id = 6;</code>
     * @return the varargElementTypeId
     */
    public int getVarargElementTypeId() {
      return varargElementTypeId;
    }

    /**
     * <code>optional int32 vararg_element_type_id = 6;</code>
     * @param value the varargElementTypeId to set
     * @return this
     */
    public ValueParameter setVarargElementTypeId(final int value) {
      bitField0_ |= 0x00000002;
      varargElementTypeId = value;
      return this;
    }

    private void initType() {
      if (type == null) {
        type = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type type = 3;</code>
     * @return whether the type field is set
     */
    public boolean hasType() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type type = 3;</code>
     * @return this
     */
    public ValueParameter clearType() {
      bitField0_ &= ~0x00000004;
      if (type != null) {
        type.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type type = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getType() {
      initType();
      return type;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type type = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableType() {
      initType();
      bitField0_ |= 0x00000004;
      return type;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type type = 3;</code>
     * @param value the type to set
     * @return this
     */
    public ValueParameter setType(final Type value) {
      initType();
      bitField0_ |= 0x00000004;
      type.copyFrom(value);
      return this;
    }

    private void initVarargElementType() {
      if (varargElementType == null) {
        varargElementType = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type vararg_element_type = 4;</code>
     * @return whether the varargElementType field is set
     */
    public boolean hasVarargElementType() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type vararg_element_type = 4;</code>
     * @return this
     */
    public ValueParameter clearVarargElementType() {
      bitField0_ &= ~0x00000040;
      if (varargElementType != null) {
        varargElementType.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type vararg_element_type = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVarargElementType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getVarargElementType() {
      initVarargElementType();
      return varargElementType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type vararg_element_type = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableVarargElementType() {
      initVarargElementType();
      bitField0_ |= 0x00000040;
      return varargElementType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type vararg_element_type = 4;</code>
     * @param value the varargElementType to set
     * @return this
     */
    public ValueParameter setVarargElementType(final Type value) {
      initVarargElementType();
      bitField0_ |= 0x00000040;
      varargElementType.copyFrom(value);
      return this;
    }

    private void initAnnotationParameterDefaultValue() {
      if (annotationParameterDefaultValue == null) {
        annotationParameterDefaultValue = Annotation.Argument.Value.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value annotation_parameter_default_value = 8;</code>
     * @return whether the annotationParameterDefaultValue field is set
     */
    public boolean hasAnnotationParameterDefaultValue() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value annotation_parameter_default_value = 8;</code>
     * @return this
     */
    public ValueParameter clearAnnotationParameterDefaultValue() {
      bitField0_ &= ~0x00000008;
      if (annotationParameterDefaultValue != null) {
        annotationParameterDefaultValue.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value annotation_parameter_default_value = 8;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAnnotationParameterDefaultValue()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Annotation.Argument.Value getAnnotationParameterDefaultValue() {
      initAnnotationParameterDefaultValue();
      return annotationParameterDefaultValue;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value annotation_parameter_default_value = 8;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Annotation.Argument.Value getMutableAnnotationParameterDefaultValue() {
      initAnnotationParameterDefaultValue();
      bitField0_ |= 0x00000008;
      return annotationParameterDefaultValue;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Annotation.Argument.Value annotation_parameter_default_value = 8;</code>
     * @param value the annotationParameterDefaultValue to set
     * @return this
     */
    public ValueParameter setAnnotationParameterDefaultValue(
        final Annotation.Argument.Value value) {
      initAnnotationParameterDefaultValue();
      bitField0_ |= 0x00000008;
      annotationParameterDefaultValue.copyFrom(value);
      return this;
    }

    private void initAnnotation() {
      if (annotation == null) {
        annotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 7;</code>
     * @return whether the annotation field is set
     */
    public boolean hasAnnotation() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 7;</code>
     * @return this
     */
    public ValueParameter clearAnnotation() {
      bitField0_ &= ~0x00000080;
      if (annotation != null) {
        annotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getAnnotation() {
      initAnnotation();
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableAnnotation() {
      initAnnotation();
      bitField0_ |= 0x00000080;
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 7;</code>
     * @param value the annotation to add
     * @return this
     */
    public ValueParameter addAnnotation(final Annotation value) {
      initAnnotation();
      bitField0_ |= 0x00000080;
      annotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 7;</code>
     * @param values the annotation to add
     * @return this
     */
    public ValueParameter addAllAnnotation(final Annotation... values) {
      initAnnotation();
      bitField0_ |= 0x00000080;
      annotation.addAll(values);
      return this;
    }

    @Override
    public ValueParameter copyFrom(final ValueParameter other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        flags = other.flags;
        name = other.name;
        typeId = other.typeId;
        varargElementTypeId = other.varargElementTypeId;
        if (other.hasType()) {
          initType();
          type.copyFrom(other.type);
        } else {
          clearType();
        }
        if (other.hasVarargElementType()) {
          initVarargElementType();
          varargElementType.copyFrom(other.varargElementType);
        } else {
          clearVarargElementType();
        }
        if (other.hasAnnotationParameterDefaultValue()) {
          initAnnotationParameterDefaultValue();
          annotationParameterDefaultValue.copyFrom(other.annotationParameterDefaultValue);
        } else {
          clearAnnotationParameterDefaultValue();
        }
        if (other.hasAnnotation()) {
          initAnnotation();
          annotation.copyFrom(other.annotation);
        } else {
          clearAnnotation();
        }
      }
      return this;
    }

    @Override
    public ValueParameter mergeFrom(final ValueParameter other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFlags()) {
        setFlags(other.flags);
      }
      if (other.hasName()) {
        setName(other.name);
      }
      if (other.hasTypeId()) {
        setTypeId(other.typeId);
      }
      if (other.hasVarargElementTypeId()) {
        setVarargElementTypeId(other.varargElementTypeId);
      }
      if (other.hasType()) {
        getMutableType().mergeFrom(other.type);
      }
      if (other.hasVarargElementType()) {
        getMutableVarargElementType().mergeFrom(other.varargElementType);
      }
      if (other.hasAnnotationParameterDefaultValue()) {
        getMutableAnnotationParameterDefaultValue().mergeFrom(other.annotationParameterDefaultValue);
      }
      if (other.hasAnnotation()) {
        getMutableAnnotation().addAll(other.annotation);
      }
      return this;
    }

    @Override
    public ValueParameter clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flags = 0;
      name = 0;
      typeId = 0;
      varargElementTypeId = 0;
      if (type != null) {
        type.clear();
      }
      if (varargElementType != null) {
        varargElementType.clear();
      }
      if (annotationParameterDefaultValue != null) {
        annotationParameterDefaultValue.clear();
      }
      if (annotation != null) {
        annotation.clear();
      }
      return this;
    }

    @Override
    public ValueParameter clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (type != null) {
        type.clearQuick();
      }
      if (varargElementType != null) {
        varargElementType.clearQuick();
      }
      if (annotationParameterDefaultValue != null) {
        annotationParameterDefaultValue.clearQuick();
      }
      if (annotation != null) {
        annotation.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ValueParameter)) {
        return false;
      }
      ValueParameter other = (ValueParameter) o;
      return bitField0_ == other.bitField0_
        && (!hasFlags() || flags == other.flags)
        && (!hasName() || name == other.name)
        && (!hasTypeId() || typeId == other.typeId)
        && (!hasVarargElementTypeId() || varargElementTypeId == other.varargElementTypeId)
        && (!hasType() || type.equals(other.type))
        && (!hasVarargElementType() || varargElementType.equals(other.varargElementType))
        && (!hasAnnotationParameterDefaultValue() || annotationParameterDefaultValue.equals(other.annotationParameterDefaultValue))
        && (!hasAnnotation() || annotation.equals(other.annotation));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000010) != 0x00000010))) {
        throw new UninitializedMessageException(this);
      }
      try {
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRawByte((byte) 8);
          output.writeInt32NoTag(flags);
        }
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 40);
          output.writeInt32NoTag(typeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 48);
          output.writeInt32NoTag(varargElementTypeId);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(type);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(varargElementType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRawByte((byte) 66);
          output.writeMessageNoTag(annotationParameterDefaultValue);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          for (int i = 0; i < annotation.length(); i++) {
            output.writeRawByte((byte) 58);
            output.writeMessageNoTag(annotation.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000010) != 0x00000010))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        if ((bitField0_ & 0x00000020) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(flags);
        }
        size += 1 + ProtoSink.computeInt32SizeNoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(typeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(varargElementTypeId);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(type);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(varargElementType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(annotationParameterDefaultValue);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          size += (1 * annotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(annotation);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ValueParameter mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // flags
            flags = input.readInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // name
            name = input.readInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // typeId
            typeId = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // varargElementTypeId
            varargElementTypeId = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // type
            initType();
            input.readMessage(type);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // varargElementType
            initVarargElementType();
            input.readMessage(varargElementType);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            // annotationParameterDefaultValue
            initAnnotationParameterDefaultValue();
            input.readMessage(annotationParameterDefaultValue);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // annotation
            initAnnotation();
            tag = input.readRepeatedMessage(annotation, tag);
            bitField0_ |= 0x00000080;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000010) != 0x00000010))) {
        return false;
      }
      if (hasAnnotationParameterDefaultValue() && !annotationParameterDefaultValue.isInitialized()) {
        return false;
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasName()) {
        results.add(prefix + "name");
      }
      if (hasAnnotationParameterDefaultValue() && !annotationParameterDefaultValue.isInitialized()) {
        getMissingFields(prefix, "annotation_parameter_default_value", annotationParameterDefaultValue, results);
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        getMissingFields(prefix, "annotation", annotation, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000010) != 0x00000010))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeInt32(FieldNames.flags, flags);
        }
        output.writeInt32(FieldNames.name, name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt32(FieldNames.typeId, typeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeInt32(FieldNames.varargElementTypeId, varargElementTypeId);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeMessage(FieldNames.type, type);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          output.writeMessage(FieldNames.varargElementType, varargElementType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeMessage(FieldNames.annotationParameterDefaultValue, annotationParameterDefaultValue);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          output.writeRepeatedMessage(FieldNames.annotation, annotation);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public ValueParameter mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 97513095: {
            if (input.isAtField(FieldNames.flags)) {
              if (!input.trySkipNullValue()) {
                flags = input.readInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3373707: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                name = input.readInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -858803723:
          case -853090240: {
            if (input.isAtField(FieldNames.typeId)) {
              if (!input.trySkipNullValue()) {
                typeId = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1984570750:
          case -375206003: {
            if (input.isAtField(FieldNames.varargElementTypeId)) {
              if (!input.trySkipNullValue()) {
                varargElementTypeId = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3575610: {
            if (input.isAtField(FieldNames.type)) {
              if (!input.trySkipNullValue()) {
                initType();
                input.readMessage(type);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 431453959:
          case -266294515: {
            if (input.isAtField(FieldNames.varargElementType)) {
              if (!input.trySkipNullValue()) {
                initVarargElementType();
                input.readMessage(varargElementType);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1373300234:
          case 595251917: {
            if (input.isAtField(FieldNames.annotationParameterDefaultValue)) {
              if (!input.trySkipNullValue()) {
                initAnnotationParameterDefaultValue();
                input.readMessage(annotationParameterDefaultValue);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1555043537: {
            if (input.isAtField(FieldNames.annotation)) {
              if (!input.trySkipNullValue()) {
                initAnnotation();
                input.readRepeatedMessage(annotation);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ValueParameter clone() {
      return new ValueParameter().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ValueParameter parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ValueParameter(), data).checkInitialized();
    }

    public static ValueParameter parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ValueParameter(), input).checkInitialized();
    }

    public static ValueParameter parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ValueParameter(), input).checkInitialized();
    }

    /**
     * @return factory for creating ValueParameter messages
     */
    public static MessageFactory<ValueParameter> getFactory() {
      return ValueParameterFactory.INSTANCE;
    }

    private enum ValueParameterFactory implements MessageFactory<ValueParameter> {
      INSTANCE;

      @Override
      public ValueParameter create() {
        return ValueParameter.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName flags = FieldName.forField("flags");

      static final FieldName name = FieldName.forField("name");

      static final FieldName typeId = FieldName.forField("typeId", "type_id");

      static final FieldName varargElementTypeId = FieldName.forField("varargElementTypeId", "vararg_element_type_id");

      static final FieldName type = FieldName.forField("type");

      static final FieldName varargElementType = FieldName.forField("varargElementType", "vararg_element_type");

      static final FieldName annotationParameterDefaultValue = FieldName.forField("annotationParameterDefaultValue", "annotation_parameter_default_value");

      static final FieldName annotation = FieldName.forField("annotation");
    }
  }

  /**
   * Protobuf type {@code TypeAlias}
   */
  public static final class TypeAlias extends ProtoMessage<TypeAlias> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     */
    private int flags = 6;

    /**
     * <code>required int32 name = 2;</code>
     */
    private int name;

    /**
     * <code>optional int32 underlying_type_id = 5;</code>
     */
    private int underlyingTypeId;

    /**
     * <code>optional int32 expanded_type_id = 7;</code>
     */
    private int expandedTypeId;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type underlying_type = 4;</code>
     */
    private Type underlyingType = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type expanded_type = 6;</code>
     */
    private Type expandedType = null;

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     */
    private RepeatedInt versionRequirement = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 3;</code>
     */
    private RepeatedMessage<TypeParameter> typeParameter = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
     */
    private RepeatedMessage<Annotation> annotation = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     */
    private RepeatedMessage<CompilerPluginData> compilerPluginData = null;

    private TypeAlias() {
    }

    /**
     * @return a new empty instance of {@code TypeAlias}
     */
    public static TypeAlias newInstance() {
      return new TypeAlias();
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @return whether the flags field is set
     */
    public boolean hasFlags() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @return this
     */
    public TypeAlias clearFlags() {
      bitField0_ &= ~0x00000040;
      flags = 6;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @return the flags
     */
    public int getFlags() {
      return flags;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * Visibility
     * Modality
     * ClassKind
     * isInner
     * isData
     * isExternal
     * isExpect
     * isInline
     * isFun
     * hasEnumEntries
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 6];</code>
     * @param value the flags to set
     * @return this
     */
    public TypeAlias setFlags(final int value) {
      bitField0_ |= 0x00000040;
      flags = value;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return this
     */
    public TypeAlias clearName() {
      bitField0_ &= ~0x00000020;
      name = 0;
      return this;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @return the name
     */
    public int getName() {
      return name;
    }

    /**
     * <code>required int32 name = 2;</code>
     * @param value the name to set
     * @return this
     */
    public TypeAlias setName(final int value) {
      bitField0_ |= 0x00000020;
      name = value;
      return this;
    }

    /**
     * <code>optional int32 underlying_type_id = 5;</code>
     * @return whether the underlyingTypeId field is set
     */
    public boolean hasUnderlyingTypeId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 underlying_type_id = 5;</code>
     * @return this
     */
    public TypeAlias clearUnderlyingTypeId() {
      bitField0_ &= ~0x00000001;
      underlyingTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 underlying_type_id = 5;</code>
     * @return the underlyingTypeId
     */
    public int getUnderlyingTypeId() {
      return underlyingTypeId;
    }

    /**
     * <code>optional int32 underlying_type_id = 5;</code>
     * @param value the underlyingTypeId to set
     * @return this
     */
    public TypeAlias setUnderlyingTypeId(final int value) {
      bitField0_ |= 0x00000001;
      underlyingTypeId = value;
      return this;
    }

    /**
     * <code>optional int32 expanded_type_id = 7;</code>
     * @return whether the expandedTypeId field is set
     */
    public boolean hasExpandedTypeId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int32 expanded_type_id = 7;</code>
     * @return this
     */
    public TypeAlias clearExpandedTypeId() {
      bitField0_ &= ~0x00000002;
      expandedTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 expanded_type_id = 7;</code>
     * @return the expandedTypeId
     */
    public int getExpandedTypeId() {
      return expandedTypeId;
    }

    /**
     * <code>optional int32 expanded_type_id = 7;</code>
     * @param value the expandedTypeId to set
     * @return this
     */
    public TypeAlias setExpandedTypeId(final int value) {
      bitField0_ |= 0x00000002;
      expandedTypeId = value;
      return this;
    }

    private void initUnderlyingType() {
      if (underlyingType == null) {
        underlyingType = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type underlying_type = 4;</code>
     * @return whether the underlyingType field is set
     */
    public boolean hasUnderlyingType() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type underlying_type = 4;</code>
     * @return this
     */
    public TypeAlias clearUnderlyingType() {
      bitField0_ &= ~0x00000004;
      if (underlyingType != null) {
        underlyingType.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type underlying_type = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableUnderlyingType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getUnderlyingType() {
      initUnderlyingType();
      return underlyingType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type underlying_type = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableUnderlyingType() {
      initUnderlyingType();
      bitField0_ |= 0x00000004;
      return underlyingType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type underlying_type = 4;</code>
     * @param value the underlyingType to set
     * @return this
     */
    public TypeAlias setUnderlyingType(final Type value) {
      initUnderlyingType();
      bitField0_ |= 0x00000004;
      underlyingType.copyFrom(value);
      return this;
    }

    private void initExpandedType() {
      if (expandedType == null) {
        expandedType = Type.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type expanded_type = 6;</code>
     * @return whether the expandedType field is set
     */
    public boolean hasExpandedType() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type expanded_type = 6;</code>
     * @return this
     */
    public TypeAlias clearExpandedType() {
      bitField0_ &= ~0x00000080;
      if (expandedType != null) {
        expandedType.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type expanded_type = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableExpandedType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getExpandedType() {
      initExpandedType();
      return expandedType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type expanded_type = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableExpandedType() {
      initExpandedType();
      bitField0_ |= 0x00000080;
      return expandedType;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Type expanded_type = 6;</code>
     * @param value the expandedType to set
     * @return this
     */
    public TypeAlias setExpandedType(final Type value) {
      initExpandedType();
      bitField0_ |= 0x00000080;
      expandedType.copyFrom(value);
      return this;
    }

    private void initVersionRequirement() {
      if (versionRequirement == null) {
        versionRequirement = RepeatedInt.newEmptyInstance();
      }
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return whether the versionRequirement field is set
     */
    public boolean hasVersionRequirement() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @return this
     */
    public TypeAlias clearVersionRequirement() {
      bitField0_ &= ~0x00000008;
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVersionRequirement()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getVersionRequirement() {
      initVersionRequirement();
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableVersionRequirement() {
      initVersionRequirement();
      bitField0_ |= 0x00000008;
      return versionRequirement;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param value the versionRequirement to add
     * @return this
     */
    public TypeAlias addVersionRequirement(final int value) {
      initVersionRequirement();
      bitField0_ |= 0x00000008;
      versionRequirement.add(value);
      return this;
    }

    /**
     * <pre>
     *  Index into the VersionRequirementTable
     * </pre>
     *
     * <code>repeated int32 version_requirement = 31;</code>
     * @param values the versionRequirement to add
     * @return this
     */
    public TypeAlias addAllVersionRequirement(final int... values) {
      initVersionRequirement();
      bitField0_ |= 0x00000008;
      versionRequirement.addAll(values);
      return this;
    }

    private void initTypeParameter() {
      if (typeParameter == null) {
        typeParameter = RepeatedMessage.newEmptyInstance(TypeParameter.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 3;</code>
     * @return whether the typeParameter field is set
     */
    public boolean hasTypeParameter() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 3;</code>
     * @return this
     */
    public TypeAlias clearTypeParameter() {
      bitField0_ &= ~0x00000100;
      if (typeParameter != null) {
        typeParameter.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypeParameter()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<TypeParameter> getTypeParameter() {
      initTypeParameter();
      return typeParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<TypeParameter> getMutableTypeParameter() {
      initTypeParameter();
      bitField0_ |= 0x00000100;
      return typeParameter;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 3;</code>
     * @param value the typeParameter to add
     * @return this
     */
    public TypeAlias addTypeParameter(final TypeParameter value) {
      initTypeParameter();
      bitField0_ |= 0x00000100;
      typeParameter.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.TypeParameter type_parameter = 3;</code>
     * @param values the typeParameter to add
     * @return this
     */
    public TypeAlias addAllTypeParameter(final TypeParameter... values) {
      initTypeParameter();
      bitField0_ |= 0x00000100;
      typeParameter.addAll(values);
      return this;
    }

    private void initAnnotation() {
      if (annotation == null) {
        annotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
     * @return whether the annotation field is set
     */
    public boolean hasAnnotation() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
     * @return this
     */
    public TypeAlias clearAnnotation() {
      bitField0_ &= ~0x00000010;
      if (annotation != null) {
        annotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getAnnotation() {
      initAnnotation();
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableAnnotation() {
      initAnnotation();
      bitField0_ |= 0x00000010;
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
     * @param value the annotation to add
     * @return this
     */
    public TypeAlias addAnnotation(final Annotation value) {
      initAnnotation();
      bitField0_ |= 0x00000010;
      annotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 8;</code>
     * @param values the annotation to add
     * @return this
     */
    public TypeAlias addAllAnnotation(final Annotation... values) {
      initAnnotation();
      bitField0_ |= 0x00000010;
      annotation.addAll(values);
      return this;
    }

    private void initCompilerPluginData() {
      if (compilerPluginData == null) {
        compilerPluginData = RepeatedMessage.newEmptyInstance(CompilerPluginData.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @return whether the compilerPluginData field is set
     */
    public boolean hasCompilerPluginData() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @return this
     */
    public TypeAlias clearCompilerPluginData() {
      bitField0_ &= ~0x00000200;
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCompilerPluginData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CompilerPluginData> getCompilerPluginData() {
      initCompilerPluginData();
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CompilerPluginData> getMutableCompilerPluginData() {
      initCompilerPluginData();
      bitField0_ |= 0x00000200;
      return compilerPluginData;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @param value the compilerPluginData to add
     * @return this
     */
    public TypeAlias addCompilerPluginData(final CompilerPluginData value) {
      initCompilerPluginData();
      bitField0_ |= 0x00000200;
      compilerPluginData.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.CompilerPluginData compiler_plugin_data = 32;</code>
     * @param values the compilerPluginData to add
     * @return this
     */
    public TypeAlias addAllCompilerPluginData(final CompilerPluginData... values) {
      initCompilerPluginData();
      bitField0_ |= 0x00000200;
      compilerPluginData.addAll(values);
      return this;
    }

    @Override
    public TypeAlias copyFrom(final TypeAlias other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        flags = other.flags;
        name = other.name;
        underlyingTypeId = other.underlyingTypeId;
        expandedTypeId = other.expandedTypeId;
        if (other.hasUnderlyingType()) {
          initUnderlyingType();
          underlyingType.copyFrom(other.underlyingType);
        } else {
          clearUnderlyingType();
        }
        if (other.hasExpandedType()) {
          initExpandedType();
          expandedType.copyFrom(other.expandedType);
        } else {
          clearExpandedType();
        }
        if (other.hasVersionRequirement()) {
          initVersionRequirement();
          versionRequirement.copyFrom(other.versionRequirement);
        } else {
          clearVersionRequirement();
        }
        if (other.hasTypeParameter()) {
          initTypeParameter();
          typeParameter.copyFrom(other.typeParameter);
        } else {
          clearTypeParameter();
        }
        if (other.hasAnnotation()) {
          initAnnotation();
          annotation.copyFrom(other.annotation);
        } else {
          clearAnnotation();
        }
        if (other.hasCompilerPluginData()) {
          initCompilerPluginData();
          compilerPluginData.copyFrom(other.compilerPluginData);
        } else {
          clearCompilerPluginData();
        }
      }
      return this;
    }

    @Override
    public TypeAlias mergeFrom(final TypeAlias other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFlags()) {
        setFlags(other.flags);
      }
      if (other.hasName()) {
        setName(other.name);
      }
      if (other.hasUnderlyingTypeId()) {
        setUnderlyingTypeId(other.underlyingTypeId);
      }
      if (other.hasExpandedTypeId()) {
        setExpandedTypeId(other.expandedTypeId);
      }
      if (other.hasUnderlyingType()) {
        getMutableUnderlyingType().mergeFrom(other.underlyingType);
      }
      if (other.hasExpandedType()) {
        getMutableExpandedType().mergeFrom(other.expandedType);
      }
      if (other.hasVersionRequirement()) {
        getMutableVersionRequirement().addAll(other.versionRequirement);
      }
      if (other.hasTypeParameter()) {
        getMutableTypeParameter().addAll(other.typeParameter);
      }
      if (other.hasAnnotation()) {
        getMutableAnnotation().addAll(other.annotation);
      }
      if (other.hasCompilerPluginData()) {
        getMutableCompilerPluginData().addAll(other.compilerPluginData);
      }
      return this;
    }

    @Override
    public TypeAlias clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flags = 6;
      name = 0;
      underlyingTypeId = 0;
      expandedTypeId = 0;
      if (underlyingType != null) {
        underlyingType.clear();
      }
      if (expandedType != null) {
        expandedType.clear();
      }
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (typeParameter != null) {
        typeParameter.clear();
      }
      if (annotation != null) {
        annotation.clear();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clear();
      }
      return this;
    }

    @Override
    public TypeAlias clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (underlyingType != null) {
        underlyingType.clearQuick();
      }
      if (expandedType != null) {
        expandedType.clearQuick();
      }
      if (versionRequirement != null) {
        versionRequirement.clear();
      }
      if (typeParameter != null) {
        typeParameter.clearQuick();
      }
      if (annotation != null) {
        annotation.clearQuick();
      }
      if (compilerPluginData != null) {
        compilerPluginData.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TypeAlias)) {
        return false;
      }
      TypeAlias other = (TypeAlias) o;
      return bitField0_ == other.bitField0_
        && (!hasFlags() || flags == other.flags)
        && (!hasName() || name == other.name)
        && (!hasUnderlyingTypeId() || underlyingTypeId == other.underlyingTypeId)
        && (!hasExpandedTypeId() || expandedTypeId == other.expandedTypeId)
        && (!hasUnderlyingType() || underlyingType.equals(other.underlyingType))
        && (!hasExpandedType() || expandedType.equals(other.expandedType))
        && (!hasVersionRequirement() || versionRequirement.equals(other.versionRequirement))
        && (!hasTypeParameter() || typeParameter.equals(other.typeParameter))
        && (!hasAnnotation() || annotation.equals(other.annotation))
        && (!hasCompilerPluginData() || compilerPluginData.equals(other.compilerPluginData));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000020) != 0x00000020))) {
        throw new UninitializedMessageException(this);
      }
      try {
        if ((bitField0_ & 0x00000040) != 0) {
          output.writeRawByte((byte) 8);
          output.writeInt32NoTag(flags);
        }
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 40);
          output.writeInt32NoTag(underlyingTypeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 56);
          output.writeInt32NoTag(expandedTypeId);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(underlyingType);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          output.writeRawByte((byte) 50);
          output.writeMessageNoTag(expandedType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          for (int i = 0; i < versionRequirement.length(); i++) {
            output.writeRawLittleEndian16((short) 504);
            output.writeInt32NoTag(versionRequirement.array()[i]);
          }
        }
        if ((bitField0_ & 0x00000100) != 0) {
          for (int i = 0; i < typeParameter.length(); i++) {
            output.writeRawByte((byte) 26);
            output.writeMessageNoTag(typeParameter.get(i));
          }
        }
        if ((bitField0_ & 0x00000010) != 0) {
          for (int i = 0; i < annotation.length(); i++) {
            output.writeRawByte((byte) 66);
            output.writeMessageNoTag(annotation.get(i));
          }
        }
        if ((bitField0_ & 0x00000200) != 0) {
          for (int i = 0; i < compilerPluginData.length(); i++) {
            output.writeRawLittleEndian16((short) 642);
            output.writeMessageNoTag(compilerPluginData.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000020) != 0x00000020))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        if ((bitField0_ & 0x00000040) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(flags);
        }
        size += 1 + ProtoSink.computeInt32SizeNoTag(name);
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(underlyingTypeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(expandedTypeId);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(underlyingType);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(expandedType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += (2 * versionRequirement.length()) + ProtoSink.computeRepeatedInt32SizeNoTag(versionRequirement);
        }
        if ((bitField0_ & 0x00000100) != 0) {
          size += (1 * typeParameter.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(typeParameter);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += (1 * annotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(annotation);
        }
        if ((bitField0_ & 0x00000200) != 0) {
          size += (2 * compilerPluginData.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(compilerPluginData);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TypeAlias mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // flags
            flags = input.readInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // name
            name = input.readInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // underlyingTypeId
            underlyingTypeId = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // expandedTypeId
            expandedTypeId = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // underlyingType
            initUnderlyingType();
            input.readMessage(underlyingType);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // expandedType
            initExpandedType();
            input.readMessage(expandedType);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 250) {
              break;
            }
          }
          case 250: {
            // versionRequirement [packed=true]
            initVersionRequirement();
            input.readPackedInt32(versionRequirement, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // typeParameter
            initTypeParameter();
            tag = input.readRepeatedMessage(typeParameter, tag);
            bitField0_ |= 0x00000100;
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            // annotation
            initAnnotation();
            tag = input.readRepeatedMessage(annotation, tag);
            bitField0_ |= 0x00000010;
            if (tag != 258) {
              break;
            }
          }
          case 258: {
            // compilerPluginData
            initCompilerPluginData();
            tag = input.readRepeatedMessage(compilerPluginData, tag);
            bitField0_ |= 0x00000200;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 248: {
            // versionRequirement [packed=false]
            initVersionRequirement();
            tag = input.readRepeatedInt32(versionRequirement, tag);
            bitField0_ |= 0x00000008;
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000020) != 0x00000020))) {
        return false;
      }
      if (hasTypeParameter() && !typeParameter.isInitialized()) {
        return false;
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        return false;
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasName()) {
        results.add(prefix + "name");
      }
      if (hasTypeParameter() && !typeParameter.isInitialized()) {
        getMissingFields(prefix, "type_parameter", typeParameter, results);
      }
      if (hasAnnotation() && !annotation.isInitialized()) {
        getMissingFields(prefix, "annotation", annotation, results);
      }
      if (hasCompilerPluginData() && !compilerPluginData.isInitialized()) {
        getMissingFields(prefix, "compiler_plugin_data", compilerPluginData, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000020) != 0x00000020))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000040) != 0) {
          output.writeInt32(FieldNames.flags, flags);
        }
        output.writeInt32(FieldNames.name, name);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt32(FieldNames.underlyingTypeId, underlyingTypeId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeInt32(FieldNames.expandedTypeId, expandedTypeId);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeMessage(FieldNames.underlyingType, underlyingType);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          output.writeMessage(FieldNames.expandedType, expandedType);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRepeatedInt32(FieldNames.versionRequirement, versionRequirement);
        }
        if ((bitField0_ & 0x00000100) != 0) {
          output.writeRepeatedMessage(FieldNames.typeParameter, typeParameter);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRepeatedMessage(FieldNames.annotation, annotation);
        }
        if ((bitField0_ & 0x00000200) != 0) {
          output.writeRepeatedMessage(FieldNames.compilerPluginData, compilerPluginData);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public TypeAlias mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 97513095: {
            if (input.isAtField(FieldNames.flags)) {
              if (!input.trySkipNullValue()) {
                flags = input.readInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3373707: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                name = input.readInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 238889906:
          case -237887138: {
            if (input.isAtField(FieldNames.underlyingTypeId)) {
              if (!input.trySkipNullValue()) {
                underlyingTypeId = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -795862002:
          case 1797941946: {
            if (input.isAtField(FieldNames.expandedTypeId)) {
              if (!input.trySkipNullValue()) {
                expandedTypeId = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1497453623:
          case -813559076: {
            if (input.isAtField(FieldNames.underlyingType)) {
              if (!input.trySkipNullValue()) {
                initUnderlyingType();
                input.readMessage(underlyingType);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -519263341:
          case 1092724480: {
            if (input.isAtField(FieldNames.expandedType)) {
              if (!input.trySkipNullValue()) {
                initExpandedType();
                input.readMessage(expandedType);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 351760459:
          case -783428772: {
            if (input.isAtField(FieldNames.versionRequirement)) {
              if (!input.trySkipNullValue()) {
                initVersionRequirement();
                input.readRepeatedInt32(versionRequirement);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 659473807:
          case 1277164772: {
            if (input.isAtField(FieldNames.typeParameter)) {
              if (!input.trySkipNullValue()) {
                initTypeParameter();
                input.readRepeatedMessage(typeParameter);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1555043537: {
            if (input.isAtField(FieldNames.annotation)) {
              if (!input.trySkipNullValue()) {
                initAnnotation();
                input.readRepeatedMessage(annotation);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1393610620:
          case -1920592490: {
            if (input.isAtField(FieldNames.compilerPluginData)) {
              if (!input.trySkipNullValue()) {
                initCompilerPluginData();
                input.readRepeatedMessage(compilerPluginData);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TypeAlias clone() {
      return new TypeAlias().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TypeAlias parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TypeAlias(), data).checkInitialized();
    }

    public static TypeAlias parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TypeAlias(), input).checkInitialized();
    }

    public static TypeAlias parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TypeAlias(), input).checkInitialized();
    }

    /**
     * @return factory for creating TypeAlias messages
     */
    public static MessageFactory<TypeAlias> getFactory() {
      return TypeAliasFactory.INSTANCE;
    }

    private enum TypeAliasFactory implements MessageFactory<TypeAlias> {
      INSTANCE;

      @Override
      public TypeAlias create() {
        return TypeAlias.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName flags = FieldName.forField("flags");

      static final FieldName name = FieldName.forField("name");

      static final FieldName underlyingTypeId = FieldName.forField("underlyingTypeId", "underlying_type_id");

      static final FieldName expandedTypeId = FieldName.forField("expandedTypeId", "expanded_type_id");

      static final FieldName underlyingType = FieldName.forField("underlyingType", "underlying_type");

      static final FieldName expandedType = FieldName.forField("expandedType", "expanded_type");

      static final FieldName versionRequirement = FieldName.forField("versionRequirement", "version_requirement");

      static final FieldName typeParameter = FieldName.forField("typeParameter", "type_parameter");

      static final FieldName annotation = FieldName.forField("annotation");

      static final FieldName compilerPluginData = FieldName.forField("compilerPluginData", "compiler_plugin_data");
    }
  }

  /**
   * Protobuf type {@code EnumEntry}
   */
  public static final class EnumEntry extends ProtoMessage<EnumEntry> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 name = 1;</code>
     */
    private int name;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 2;</code>
     */
    private RepeatedMessage<Annotation> annotation = null;

    private EnumEntry() {
    }

    /**
     * @return a new empty instance of {@code EnumEntry}
     */
    public static EnumEntry newInstance() {
      return new EnumEntry();
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @return this
     */
    public EnumEntry clearName() {
      bitField0_ &= ~0x00000001;
      name = 0;
      return this;
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @return the name
     */
    public int getName() {
      return name;
    }

    /**
     * <code>optional int32 name = 1;</code>
     * @param value the name to set
     * @return this
     */
    public EnumEntry setName(final int value) {
      bitField0_ |= 0x00000001;
      name = value;
      return this;
    }

    private void initAnnotation() {
      if (annotation == null) {
        annotation = RepeatedMessage.newEmptyInstance(Annotation.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 2;</code>
     * @return whether the annotation field is set
     */
    public boolean hasAnnotation() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 2;</code>
     * @return this
     */
    public EnumEntry clearAnnotation() {
      bitField0_ &= ~0x00000002;
      if (annotation != null) {
        annotation.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAnnotation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Annotation> getAnnotation() {
      initAnnotation();
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Annotation> getMutableAnnotation() {
      initAnnotation();
      bitField0_ |= 0x00000002;
      return annotation;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 2;</code>
     * @param value the annotation to add
     * @return this
     */
    public EnumEntry addAnnotation(final Annotation value) {
      initAnnotation();
      bitField0_ |= 0x00000002;
      annotation.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Annotation annotation = 2;</code>
     * @param values the annotation to add
     * @return this
     */
    public EnumEntry addAllAnnotation(final Annotation... values) {
      initAnnotation();
      bitField0_ |= 0x00000002;
      annotation.addAll(values);
      return this;
    }

    @Override
    public EnumEntry copyFrom(final EnumEntry other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        name = other.name;
        if (other.hasAnnotation()) {
          initAnnotation();
          annotation.copyFrom(other.annotation);
        } else {
          clearAnnotation();
        }
      }
      return this;
    }

    @Override
    public EnumEntry mergeFrom(final EnumEntry other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasName()) {
        setName(other.name);
      }
      if (other.hasAnnotation()) {
        getMutableAnnotation().addAll(other.annotation);
      }
      return this;
    }

    @Override
    public EnumEntry clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      name = 0;
      if (annotation != null) {
        annotation.clear();
      }
      return this;
    }

    @Override
    public EnumEntry clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (annotation != null) {
        annotation.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof EnumEntry)) {
        return false;
      }
      EnumEntry other = (EnumEntry) o;
      return bitField0_ == other.bitField0_
        && (!hasName() || name == other.name)
        && (!hasAnnotation() || annotation.equals(other.annotation));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      try {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 8);
          output.writeInt32NoTag(name);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          for (int i = 0; i < annotation.length(); i++) {
            output.writeRawByte((byte) 18);
            output.writeMessageNoTag(annotation.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      try {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeInt32SizeNoTag(name);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += (1 * annotation.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(annotation);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public EnumEntry mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // name
            name = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // annotation
            initAnnotation();
            tag = input.readRepeatedMessage(annotation, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if (hasAnnotation() && !annotation.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (hasAnnotation() && !annotation.isInitialized()) {
        getMissingFields(prefix, "annotation", annotation, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt32(FieldNames.name, name);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRepeatedMessage(FieldNames.annotation, annotation);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public EnumEntry mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3373707: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                name = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1555043537: {
            if (input.isAtField(FieldNames.annotation)) {
              if (!input.trySkipNullValue()) {
                initAnnotation();
                input.readRepeatedMessage(annotation);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public EnumEntry clone() {
      return new EnumEntry().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static EnumEntry parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new EnumEntry(), data).checkInitialized();
    }

    public static EnumEntry parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EnumEntry(), input).checkInitialized();
    }

    public static EnumEntry parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EnumEntry(), input).checkInitialized();
    }

    /**
     * @return factory for creating EnumEntry messages
     */
    public static MessageFactory<EnumEntry> getFactory() {
      return EnumEntryFactory.INSTANCE;
    }

    private enum EnumEntryFactory implements MessageFactory<EnumEntry> {
      INSTANCE;

      @Override
      public EnumEntry create() {
        return EnumEntry.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName name = FieldName.forField("name");

      static final FieldName annotation = FieldName.forField("annotation");
    }
  }

  /**
   * Protobuf type {@code VersionRequirement}
   */
  public static final class VersionRequirement extends ProtoMessage<VersionRequirement> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <pre>
     *  Kotlin version, since which this declaration is accessible, in the following format (encoded version is "major.minor.patch"):
     *  (patch << 7) + (minor << 3) + major
     *  Compilers with version less than this value should report a diagnostic if this declaration is selected as the resolution result
     * </pre>
     *
     * <code>optional int32 version = 1;</code>
     */
    private int version;

    /**
     * <pre>
     *  Version in base 256, in case we run out of space to store the version in the optimized form. Has priority over 'version'.
     *  (patch << 16) + (minor << 8) + major
     * </pre>
     *
     * <code>optional int32 version_full = 2;</code>
     */
    private int versionFull;

    /**
     * <pre>
     *  Error code, to be looked up on the website
     * </pre>
     *
     * <code>optional int32 error_code = 4;</code>
     */
    private int errorCode;

    /**
     * <pre>
     *  Diagnostic message
     * </pre>
     *
     * <code>optional int32 message = 5;</code>
     */
    private int message;

    /**
     * <pre>
     *  Level of the reported diagnostic
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.Level level = 3 [default = ERROR];</code>
     */
    private int level = org.jetbrains.kotlin.metadata.QuickProtoBuf.VersionRequirement.Level.ERROR_VALUE;

    /**
     * <pre>
     *  Which version is this requirement for. For example, if version_kind = API_VERSION, this declaration requires the API version
     *  (the "-api-version" argument value when compiling the call site) to be of at least the specified value
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.VersionKind version_kind = 6 [default = LANGUAGE_VERSION];</code>
     */
    private int versionKind = org.jetbrains.kotlin.metadata.QuickProtoBuf.VersionRequirement.VersionKind.LANGUAGE_VERSION_VALUE;

    private VersionRequirement() {
    }

    /**
     * @return a new empty instance of {@code VersionRequirement}
     */
    public static VersionRequirement newInstance() {
      return new VersionRequirement();
    }

    /**
     * <pre>
     *  Kotlin version, since which this declaration is accessible, in the following format (encoded version is "major.minor.patch"):
     *  (patch << 7) + (minor << 3) + major
     *  Compilers with version less than this value should report a diagnostic if this declaration is selected as the resolution result
     * </pre>
     *
     * <code>optional int32 version = 1;</code>
     * @return whether the version field is set
     */
    public boolean hasVersion() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <pre>
     *  Kotlin version, since which this declaration is accessible, in the following format (encoded version is "major.minor.patch"):
     *  (patch << 7) + (minor << 3) + major
     *  Compilers with version less than this value should report a diagnostic if this declaration is selected as the resolution result
     * </pre>
     *
     * <code>optional int32 version = 1;</code>
     * @return this
     */
    public VersionRequirement clearVersion() {
      bitField0_ &= ~0x00000001;
      version = 0;
      return this;
    }

    /**
     * <pre>
     *  Kotlin version, since which this declaration is accessible, in the following format (encoded version is "major.minor.patch"):
     *  (patch << 7) + (minor << 3) + major
     *  Compilers with version less than this value should report a diagnostic if this declaration is selected as the resolution result
     * </pre>
     *
     * <code>optional int32 version = 1;</code>
     * @return the version
     */
    public int getVersion() {
      return version;
    }

    /**
     * <pre>
     *  Kotlin version, since which this declaration is accessible, in the following format (encoded version is "major.minor.patch"):
     *  (patch << 7) + (minor << 3) + major
     *  Compilers with version less than this value should report a diagnostic if this declaration is selected as the resolution result
     * </pre>
     *
     * <code>optional int32 version = 1;</code>
     * @param value the version to set
     * @return this
     */
    public VersionRequirement setVersion(final int value) {
      bitField0_ |= 0x00000001;
      version = value;
      return this;
    }

    /**
     * <pre>
     *  Version in base 256, in case we run out of space to store the version in the optimized form. Has priority over 'version'.
     *  (patch << 16) + (minor << 8) + major
     * </pre>
     *
     * <code>optional int32 version_full = 2;</code>
     * @return whether the versionFull field is set
     */
    public boolean hasVersionFull() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <pre>
     *  Version in base 256, in case we run out of space to store the version in the optimized form. Has priority over 'version'.
     *  (patch << 16) + (minor << 8) + major
     * </pre>
     *
     * <code>optional int32 version_full = 2;</code>
     * @return this
     */
    public VersionRequirement clearVersionFull() {
      bitField0_ &= ~0x00000002;
      versionFull = 0;
      return this;
    }

    /**
     * <pre>
     *  Version in base 256, in case we run out of space to store the version in the optimized form. Has priority over 'version'.
     *  (patch << 16) + (minor << 8) + major
     * </pre>
     *
     * <code>optional int32 version_full = 2;</code>
     * @return the versionFull
     */
    public int getVersionFull() {
      return versionFull;
    }

    /**
     * <pre>
     *  Version in base 256, in case we run out of space to store the version in the optimized form. Has priority over 'version'.
     *  (patch << 16) + (minor << 8) + major
     * </pre>
     *
     * <code>optional int32 version_full = 2;</code>
     * @param value the versionFull to set
     * @return this
     */
    public VersionRequirement setVersionFull(final int value) {
      bitField0_ |= 0x00000002;
      versionFull = value;
      return this;
    }

    /**
     * <pre>
     *  Error code, to be looked up on the website
     * </pre>
     *
     * <code>optional int32 error_code = 4;</code>
     * @return whether the errorCode field is set
     */
    public boolean hasErrorCode() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <pre>
     *  Error code, to be looked up on the website
     * </pre>
     *
     * <code>optional int32 error_code = 4;</code>
     * @return this
     */
    public VersionRequirement clearErrorCode() {
      bitField0_ &= ~0x00000004;
      errorCode = 0;
      return this;
    }

    /**
     * <pre>
     *  Error code, to be looked up on the website
     * </pre>
     *
     * <code>optional int32 error_code = 4;</code>
     * @return the errorCode
     */
    public int getErrorCode() {
      return errorCode;
    }

    /**
     * <pre>
     *  Error code, to be looked up on the website
     * </pre>
     *
     * <code>optional int32 error_code = 4;</code>
     * @param value the errorCode to set
     * @return this
     */
    public VersionRequirement setErrorCode(final int value) {
      bitField0_ |= 0x00000004;
      errorCode = value;
      return this;
    }

    /**
     * <pre>
     *  Diagnostic message
     * </pre>
     *
     * <code>optional int32 message = 5;</code>
     * @return whether the message field is set
     */
    public boolean hasMessage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <pre>
     *  Diagnostic message
     * </pre>
     *
     * <code>optional int32 message = 5;</code>
     * @return this
     */
    public VersionRequirement clearMessage() {
      bitField0_ &= ~0x00000008;
      message = 0;
      return this;
    }

    /**
     * <pre>
     *  Diagnostic message
     * </pre>
     *
     * <code>optional int32 message = 5;</code>
     * @return the message
     */
    public int getMessage() {
      return message;
    }

    /**
     * <pre>
     *  Diagnostic message
     * </pre>
     *
     * <code>optional int32 message = 5;</code>
     * @param value the message to set
     * @return this
     */
    public VersionRequirement setMessage(final int value) {
      bitField0_ |= 0x00000008;
      message = value;
      return this;
    }

    /**
     * <pre>
     *  Level of the reported diagnostic
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.Level level = 3 [default = ERROR];</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <pre>
     *  Level of the reported diagnostic
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.Level level = 3 [default = ERROR];</code>
     * @return this
     */
    public VersionRequirement clearLevel() {
      bitField0_ &= ~0x00000010;
      level = org.jetbrains.kotlin.metadata.QuickProtoBuf.VersionRequirement.Level.ERROR_VALUE;
      return this;
    }

    /**
     * <pre>
     *  Level of the reported diagnostic
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.Level level = 3 [default = ERROR];</code>
     * @return the level
     */
    public Level getLevel() {
      return Level.forNumberOr(level, org.jetbrains.kotlin.metadata.QuickProtoBuf.VersionRequirement.Level.ERROR);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link VersionRequirement#getLevel()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getLevelValue() {
      return level;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link Level}. Setting an invalid value
     * can cause {@link VersionRequirement#getLevel()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public VersionRequirement setLevelValue(final int value) {
      bitField0_ |= 0x00000010;
      level = value;
      return this;
    }

    /**
     * <pre>
     *  Level of the reported diagnostic
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.Level level = 3 [default = ERROR];</code>
     * @param value the level to set
     * @return this
     */
    public VersionRequirement setLevel(final Level value) {
      bitField0_ |= 0x00000010;
      level = value.getNumber();
      return this;
    }

    /**
     * <pre>
     *  Which version is this requirement for. For example, if version_kind = API_VERSION, this declaration requires the API version
     *  (the "-api-version" argument value when compiling the call site) to be of at least the specified value
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.VersionKind version_kind = 6 [default = LANGUAGE_VERSION];</code>
     * @return whether the versionKind field is set
     */
    public boolean hasVersionKind() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <pre>
     *  Which version is this requirement for. For example, if version_kind = API_VERSION, this declaration requires the API version
     *  (the "-api-version" argument value when compiling the call site) to be of at least the specified value
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.VersionKind version_kind = 6 [default = LANGUAGE_VERSION];</code>
     * @return this
     */
    public VersionRequirement clearVersionKind() {
      bitField0_ &= ~0x00000020;
      versionKind = org.jetbrains.kotlin.metadata.QuickProtoBuf.VersionRequirement.VersionKind.LANGUAGE_VERSION_VALUE;
      return this;
    }

    /**
     * <pre>
     *  Which version is this requirement for. For example, if version_kind = API_VERSION, this declaration requires the API version
     *  (the "-api-version" argument value when compiling the call site) to be of at least the specified value
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.VersionKind version_kind = 6 [default = LANGUAGE_VERSION];</code>
     * @return the versionKind
     */
    public VersionKind getVersionKind() {
      return VersionKind.forNumberOr(versionKind, org.jetbrains.kotlin.metadata.QuickProtoBuf.VersionRequirement.VersionKind.LANGUAGE_VERSION);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link VersionRequirement#getVersionKind()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getVersionKindValue() {
      return versionKind;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link VersionKind}. Setting an invalid value
     * can cause {@link VersionRequirement#getVersionKind()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public VersionRequirement setVersionKindValue(final int value) {
      bitField0_ |= 0x00000020;
      versionKind = value;
      return this;
    }

    /**
     * <pre>
     *  Which version is this requirement for. For example, if version_kind = API_VERSION, this declaration requires the API version
     *  (the "-api-version" argument value when compiling the call site) to be of at least the specified value
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.VersionRequirement.VersionKind version_kind = 6 [default = LANGUAGE_VERSION];</code>
     * @param value the versionKind to set
     * @return this
     */
    public VersionRequirement setVersionKind(final VersionKind value) {
      bitField0_ |= 0x00000020;
      versionKind = value.getNumber();
      return this;
    }

    @Override
    public VersionRequirement copyFrom(final VersionRequirement other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        version = other.version;
        versionFull = other.versionFull;
        errorCode = other.errorCode;
        message = other.message;
        level = other.level;
        versionKind = other.versionKind;
      }
      return this;
    }

    @Override
    public VersionRequirement mergeFrom(final VersionRequirement other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasVersion()) {
        setVersion(other.version);
      }
      if (other.hasVersionFull()) {
        setVersionFull(other.versionFull);
      }
      if (other.hasErrorCode()) {
        setErrorCode(other.errorCode);
      }
      if (other.hasMessage()) {
        setMessage(other.message);
      }
      if (other.hasLevel()) {
        setLevelValue(other.level);
      }
      if (other.hasVersionKind()) {
        setVersionKindValue(other.versionKind);
      }
      return this;
    }

    @Override
    public VersionRequirement clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      version = 0;
      versionFull = 0;
      errorCode = 0;
      message = 0;
      level = org.jetbrains.kotlin.metadata.QuickProtoBuf.VersionRequirement.Level.ERROR_VALUE;
      versionKind = org.jetbrains.kotlin.metadata.QuickProtoBuf.VersionRequirement.VersionKind.LANGUAGE_VERSION_VALUE;
      return this;
    }

    @Override
    public VersionRequirement clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof VersionRequirement)) {
        return false;
      }
      VersionRequirement other = (VersionRequirement) o;
      return bitField0_ == other.bitField0_
        && (!hasVersion() || version == other.version)
        && (!hasVersionFull() || versionFull == other.versionFull)
        && (!hasErrorCode() || errorCode == other.errorCode)
        && (!hasMessage() || message == other.message)
        && (!hasLevel() || level == other.level)
        && (!hasVersionKind() || versionKind == other.versionKind);
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(version);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(versionFull);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt32NoTag(errorCode);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 40);
        output.writeInt32NoTag(message);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 24);
        output.writeEnumNoTag(level);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 48);
        output.writeEnumNoTag(versionKind);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(version);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(versionFull);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(errorCode);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(message);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(level);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(versionKind);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public VersionRequirement mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // version
            version = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // versionFull
            versionFull = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // errorCode
            errorCode = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // message
            message = input.readInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // level
            final int value = input.readInt32();
            if (Level.forNumber(value) != null) {
              level = value;
              bitField0_ |= 0x00000010;
            }
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // versionKind
            final int value = input.readInt32();
            if (VersionKind.forNumber(value) != null) {
              versionKind = value;
              bitField0_ |= 0x00000020;
            }
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.version, version);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt32(FieldNames.versionFull, versionFull);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeInt32(FieldNames.errorCode, errorCode);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeInt32(FieldNames.message, message);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeEnum(FieldNames.level, level, Level.converter());
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeEnum(FieldNames.versionKind, versionKind, VersionKind.converter());
      }
      output.endObject();
    }

    @Override
    public VersionRequirement mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 351608024: {
            if (input.isAtField(FieldNames.version)) {
              if (!input.trySkipNullValue()) {
                version = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 688686983:
          case -102890090: {
            if (input.isAtField(FieldNames.versionFull)) {
              if (!input.trySkipNullValue()) {
                versionFull = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 329035797:
          case 1635686852: {
            if (input.isAtField(FieldNames.errorCode)) {
              if (!input.trySkipNullValue()) {
                errorCode = input.readInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 954925063: {
            if (input.isAtField(FieldNames.message)) {
              if (!input.trySkipNullValue()) {
                message = input.readInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 102865796: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                final Level value = input.readEnum(Level.converter());
                if (value != null) {
                  level = value.getNumber();
                  bitField0_ |= 0x00000010;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 688824460:
          case -102752613: {
            if (input.isAtField(FieldNames.versionKind)) {
              if (!input.trySkipNullValue()) {
                final VersionKind value = input.readEnum(VersionKind.converter());
                if (value != null) {
                  versionKind = value.getNumber();
                  bitField0_ |= 0x00000020;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public VersionRequirement clone() {
      return new VersionRequirement().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static VersionRequirement parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new VersionRequirement(), data).checkInitialized();
    }

    public static VersionRequirement parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VersionRequirement(), input).checkInitialized();
    }

    public static VersionRequirement parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VersionRequirement(), input).checkInitialized();
    }

    /**
     * @return factory for creating VersionRequirement messages
     */
    public static MessageFactory<VersionRequirement> getFactory() {
      return VersionRequirementFactory.INSTANCE;
    }

    /**
     * Protobuf enum {@code Level}
     */
    public enum Level implements ProtoEnum<Level> {
      /**
       * <code>WARNING = 0;</code>
       */
      WARNING("WARNING", 0),

      /**
       * <code>ERROR = 1;</code>
       */
      ERROR("ERROR", 1),

      /**
       * <code>HIDDEN = 2;</code>
       */
      HIDDEN("HIDDEN", 2);

      /**
       * <code>WARNING = 0;</code>
       */
      public static final int WARNING_VALUE = 0;

      /**
       * <code>ERROR = 1;</code>
       */
      public static final int ERROR_VALUE = 1;

      /**
       * <code>HIDDEN = 2;</code>
       */
      public static final int HIDDEN_VALUE = 2;

      private final String name;

      private final int number;

      private Level(String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<Level> converter() {
        return LevelConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static Level forNumber(int value) {
        return LevelConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static Level forNumberOr(int number, Level other) {
        Level value = forNumber(number);
        return value == null ? other : value;
      }

      enum LevelConverter implements ProtoEnum.EnumConverter<Level> {
        INSTANCE;

        private static final Level[] lookup = new Level[3];

        static {
          lookup[0] = WARNING;
          lookup[1] = ERROR;
          lookup[2] = HIDDEN;
        }

        @Override
        public final Level forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final Level forName(final CharSequence value) {
          if (value.length() == 5) {
            if (ProtoUtil.isEqual("ERROR", value)) {
              return ERROR;
            }
          }
          if (value.length() == 6) {
            if (ProtoUtil.isEqual("HIDDEN", value)) {
              return HIDDEN;
            }
          }
          if (value.length() == 7) {
            if (ProtoUtil.isEqual("WARNING", value)) {
              return WARNING;
            }
          }
          return null;
        }
      }
    }

    /**
     * Protobuf enum {@code VersionKind}
     */
    public enum VersionKind implements ProtoEnum<VersionKind> {
      /**
       * <code>LANGUAGE_VERSION = 0;</code>
       */
      LANGUAGE_VERSION("LANGUAGE_VERSION", 0),

      /**
       * <code>COMPILER_VERSION = 1;</code>
       */
      COMPILER_VERSION("COMPILER_VERSION", 1),

      /**
       * <code>API_VERSION = 2;</code>
       */
      API_VERSION("API_VERSION", 2);

      /**
       * <code>LANGUAGE_VERSION = 0;</code>
       */
      public static final int LANGUAGE_VERSION_VALUE = 0;

      /**
       * <code>COMPILER_VERSION = 1;</code>
       */
      public static final int COMPILER_VERSION_VALUE = 1;

      /**
       * <code>API_VERSION = 2;</code>
       */
      public static final int API_VERSION_VALUE = 2;

      private final String name;

      private final int number;

      private VersionKind(String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<VersionKind> converter() {
        return VersionKindConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static VersionKind forNumber(int value) {
        return VersionKindConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static VersionKind forNumberOr(int number, VersionKind other) {
        VersionKind value = forNumber(number);
        return value == null ? other : value;
      }

      enum VersionKindConverter implements ProtoEnum.EnumConverter<VersionKind> {
        INSTANCE;

        private static final VersionKind[] lookup = new VersionKind[3];

        static {
          lookup[0] = LANGUAGE_VERSION;
          lookup[1] = COMPILER_VERSION;
          lookup[2] = API_VERSION;
        }

        @Override
        public final VersionKind forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final VersionKind forName(final CharSequence value) {
          if (value.length() == 11) {
            if (ProtoUtil.isEqual("API_VERSION", value)) {
              return API_VERSION;
            }
          }
          if (value.length() == 16) {
            if (ProtoUtil.isEqual("LANGUAGE_VERSION", value)) {
              return LANGUAGE_VERSION;
            }
            if (ProtoUtil.isEqual("COMPILER_VERSION", value)) {
              return COMPILER_VERSION;
            }
          }
          return null;
        }
      }
    }

    private enum VersionRequirementFactory implements MessageFactory<VersionRequirement> {
      INSTANCE;

      @Override
      public VersionRequirement create() {
        return VersionRequirement.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName version = FieldName.forField("version");

      static final FieldName versionFull = FieldName.forField("versionFull", "version_full");

      static final FieldName errorCode = FieldName.forField("errorCode", "error_code");

      static final FieldName message = FieldName.forField("message");

      static final FieldName level = FieldName.forField("level");

      static final FieldName versionKind = FieldName.forField("versionKind", "version_kind");
    }
  }

  /**
   * Protobuf type {@code VersionRequirementTable}
   */
  public static final class VersionRequirementTable extends ProtoMessage<VersionRequirementTable> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.VersionRequirement requirement = 1;</code>
     */
    private RepeatedMessage<VersionRequirement> requirement = null;

    private VersionRequirementTable() {
    }

    /**
     * @return a new empty instance of {@code VersionRequirementTable}
     */
    public static VersionRequirementTable newInstance() {
      return new VersionRequirementTable();
    }

    private void initRequirement() {
      if (requirement == null) {
        requirement = RepeatedMessage.newEmptyInstance(VersionRequirement.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.VersionRequirement requirement = 1;</code>
     * @return whether the requirement field is set
     */
    public boolean hasRequirement() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.VersionRequirement requirement = 1;</code>
     * @return this
     */
    public VersionRequirementTable clearRequirement() {
      bitField0_ &= ~0x00000001;
      if (requirement != null) {
        requirement.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.VersionRequirement requirement = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRequirement()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<VersionRequirement> getRequirement() {
      initRequirement();
      return requirement;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.VersionRequirement requirement = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<VersionRequirement> getMutableRequirement() {
      initRequirement();
      bitField0_ |= 0x00000001;
      return requirement;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.VersionRequirement requirement = 1;</code>
     * @param value the requirement to add
     * @return this
     */
    public VersionRequirementTable addRequirement(final VersionRequirement value) {
      initRequirement();
      bitField0_ |= 0x00000001;
      requirement.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.VersionRequirement requirement = 1;</code>
     * @param values the requirement to add
     * @return this
     */
    public VersionRequirementTable addAllRequirement(final VersionRequirement... values) {
      initRequirement();
      bitField0_ |= 0x00000001;
      requirement.addAll(values);
      return this;
    }

    @Override
    public VersionRequirementTable copyFrom(final VersionRequirementTable other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasRequirement()) {
          initRequirement();
          requirement.copyFrom(other.requirement);
        } else {
          clearRequirement();
        }
      }
      return this;
    }

    @Override
    public VersionRequirementTable mergeFrom(final VersionRequirementTable other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasRequirement()) {
        getMutableRequirement().addAll(other.requirement);
      }
      return this;
    }

    @Override
    public VersionRequirementTable clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (requirement != null) {
        requirement.clear();
      }
      return this;
    }

    @Override
    public VersionRequirementTable clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (requirement != null) {
        requirement.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof VersionRequirementTable)) {
        return false;
      }
      VersionRequirementTable other = (VersionRequirementTable) o;
      return bitField0_ == other.bitField0_
        && (!hasRequirement() || requirement.equals(other.requirement));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        for (int i = 0; i < requirement.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(requirement.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += (1 * requirement.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(requirement);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public VersionRequirementTable mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // requirement
            initRequirement();
            tag = input.readRepeatedMessage(requirement, tag);
            bitField0_ |= 0x00000001;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRepeatedMessage(FieldNames.requirement, requirement);
      }
      output.endObject();
    }

    @Override
    public VersionRequirementTable mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 363387971: {
            if (input.isAtField(FieldNames.requirement)) {
              if (!input.trySkipNullValue()) {
                initRequirement();
                input.readRepeatedMessage(requirement);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public VersionRequirementTable clone() {
      return new VersionRequirementTable().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static VersionRequirementTable parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new VersionRequirementTable(), data).checkInitialized();
    }

    public static VersionRequirementTable parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VersionRequirementTable(), input).checkInitialized();
    }

    public static VersionRequirementTable parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VersionRequirementTable(), input).checkInitialized();
    }

    /**
     * @return factory for creating VersionRequirementTable messages
     */
    public static MessageFactory<VersionRequirementTable> getFactory() {
      return VersionRequirementTableFactory.INSTANCE;
    }

    private enum VersionRequirementTableFactory implements MessageFactory<VersionRequirementTable> {
      INSTANCE;

      @Override
      public VersionRequirementTable create() {
        return VersionRequirementTable.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName requirement = FieldName.forField("requirement");
    }
  }

  /**
   * <pre>
   *  A part of the package, which is used to serialize .kjsm/.meta.js, .kotlin_builtins and .kotlin_metadata files.
   *  Is not used in the JVM back-end
   * </pre>
   *
   * Protobuf type {@code PackageFragment}
   */
  public static final class PackageFragment extends ProtoMessage<PackageFragment> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.StringTable strings = 1;</code>
     */
    private StringTable strings = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable qualified_names = 2;</code>
     */
    private QualifiedNameTable qualifiedNames = null;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Package package = 3;</code>
     */
    private Package package_ = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Class class = 4;</code>
     */
    private RepeatedMessage<Class> class4 = null;

    private PackageFragment() {
    }

    /**
     * <pre>
     *  A part of the package, which is used to serialize .kjsm/.meta.js, .kotlin_builtins and .kotlin_metadata files.
     *  Is not used in the JVM back-end
     * </pre>
     *
     * @return a new empty instance of {@code PackageFragment}
     */
    public static PackageFragment newInstance() {
      return new PackageFragment();
    }

    private void initStrings() {
      if (strings == null) {
        strings = StringTable.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.StringTable strings = 1;</code>
     * @return whether the strings field is set
     */
    public boolean hasStrings() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.StringTable strings = 1;</code>
     * @return this
     */
    public PackageFragment clearStrings() {
      bitField0_ &= ~0x00000001;
      if (strings != null) {
        strings.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.StringTable strings = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableStrings()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StringTable getStrings() {
      initStrings();
      return strings;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.StringTable strings = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StringTable getMutableStrings() {
      initStrings();
      bitField0_ |= 0x00000001;
      return strings;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.StringTable strings = 1;</code>
     * @param value the strings to set
     * @return this
     */
    public PackageFragment setStrings(final StringTable value) {
      initStrings();
      bitField0_ |= 0x00000001;
      strings.copyFrom(value);
      return this;
    }

    private void initQualifiedNames() {
      if (qualifiedNames == null) {
        qualifiedNames = QualifiedNameTable.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable qualified_names = 2;</code>
     * @return whether the qualifiedNames field is set
     */
    public boolean hasQualifiedNames() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable qualified_names = 2;</code>
     * @return this
     */
    public PackageFragment clearQualifiedNames() {
      bitField0_ &= ~0x00000002;
      if (qualifiedNames != null) {
        qualifiedNames.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable qualified_names = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQualifiedNames()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public QualifiedNameTable getQualifiedNames() {
      initQualifiedNames();
      return qualifiedNames;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable qualified_names = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public QualifiedNameTable getMutableQualifiedNames() {
      initQualifiedNames();
      bitField0_ |= 0x00000002;
      return qualifiedNames;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.QualifiedNameTable qualified_names = 2;</code>
     * @param value the qualifiedNames to set
     * @return this
     */
    public PackageFragment setQualifiedNames(final QualifiedNameTable value) {
      initQualifiedNames();
      bitField0_ |= 0x00000002;
      qualifiedNames.copyFrom(value);
      return this;
    }

    private void initPackage() {
      if (package_ == null) {
        package_ = Package.newInstance();
      }
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Package package = 3;</code>
     * @return whether the package_ field is set
     */
    public boolean hasPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Package package = 3;</code>
     * @return this
     */
    public PackageFragment clearPackage() {
      bitField0_ &= ~0x00000004;
      if (package_ != null) {
        package_.clear();
      }
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Package package = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Package getPackage() {
      initPackage();
      return package_;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Package package = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Package getMutablePackage() {
      initPackage();
      bitField0_ |= 0x00000004;
      return package_;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Package package = 3;</code>
     * @param value the package_ to set
     * @return this
     */
    public PackageFragment setPackage(final Package value) {
      initPackage();
      bitField0_ |= 0x00000004;
      package_.copyFrom(value);
      return this;
    }

    private void initClass4() {
      if (class4 == null) {
        class4 = RepeatedMessage.newEmptyInstance(Class.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Class class = 4;</code>
     * @return whether the class4 field is set
     */
    public boolean hasClass4() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Class class = 4;</code>
     * @return this
     */
    public PackageFragment clearClass4() {
      bitField0_ &= ~0x00000008;
      if (class4 != null) {
        class4.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Class class = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableClass4()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Class> getClass4() {
      initClass4();
      return class4;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Class class = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Class> getMutableClass4() {
      initClass4();
      bitField0_ |= 0x00000008;
      return class4;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Class class = 4;</code>
     * @param value the class4 to add
     * @return this
     */
    public PackageFragment addClass4(final Class value) {
      initClass4();
      bitField0_ |= 0x00000008;
      class4.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Class class = 4;</code>
     * @param values the class4 to add
     * @return this
     */
    public PackageFragment addAllClass4(final Class... values) {
      initClass4();
      bitField0_ |= 0x00000008;
      class4.addAll(values);
      return this;
    }

    @Override
    public PackageFragment copyFrom(final PackageFragment other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasStrings()) {
          initStrings();
          strings.copyFrom(other.strings);
        } else {
          clearStrings();
        }
        if (other.hasQualifiedNames()) {
          initQualifiedNames();
          qualifiedNames.copyFrom(other.qualifiedNames);
        } else {
          clearQualifiedNames();
        }
        if (other.hasPackage()) {
          initPackage();
          package_.copyFrom(other.package_);
        } else {
          clearPackage();
        }
        if (other.hasClass4()) {
          initClass4();
          class4.copyFrom(other.class4);
        } else {
          clearClass4();
        }
      }
      return this;
    }

    @Override
    public PackageFragment mergeFrom(final PackageFragment other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasStrings()) {
        getMutableStrings().mergeFrom(other.strings);
      }
      if (other.hasQualifiedNames()) {
        getMutableQualifiedNames().mergeFrom(other.qualifiedNames);
      }
      if (other.hasPackage()) {
        getMutablePackage().mergeFrom(other.package_);
      }
      if (other.hasClass4()) {
        getMutableClass4().addAll(other.class4);
      }
      return this;
    }

    @Override
    public PackageFragment clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (strings != null) {
        strings.clear();
      }
      if (qualifiedNames != null) {
        qualifiedNames.clear();
      }
      if (package_ != null) {
        package_.clear();
      }
      if (class4 != null) {
        class4.clear();
      }
      return this;
    }

    @Override
    public PackageFragment clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (strings != null) {
        strings.clearQuick();
      }
      if (qualifiedNames != null) {
        qualifiedNames.clearQuick();
      }
      if (package_ != null) {
        package_.clearQuick();
      }
      if (class4 != null) {
        class4.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof PackageFragment)) {
        return false;
      }
      PackageFragment other = (PackageFragment) o;
      return bitField0_ == other.bitField0_
        && (!hasStrings() || strings.equals(other.strings))
        && (!hasQualifiedNames() || qualifiedNames.equals(other.qualifiedNames))
        && (!hasPackage() || package_.equals(other.package_))
        && (!hasClass4() || class4.equals(other.class4));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      try {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(strings);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(qualifiedNames);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(package_);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          for (int i = 0; i < class4.length(); i++) {
            output.writeRawByte((byte) 34);
            output.writeMessageNoTag(class4.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      try {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(strings);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(qualifiedNames);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(package_);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += (1 * class4.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(class4);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public PackageFragment mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // strings
            initStrings();
            input.readMessage(strings);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // qualifiedNames
            initQualifiedNames();
            input.readMessage(qualifiedNames);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // package_
            initPackage();
            input.readMessage(package_);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // class4
            initClass4();
            tag = input.readRepeatedMessage(class4, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if (hasQualifiedNames() && !qualifiedNames.isInitialized()) {
        return false;
      }
      if (hasPackage() && !package_.isInitialized()) {
        return false;
      }
      if (hasClass4() && !class4.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (hasQualifiedNames() && !qualifiedNames.isInitialized()) {
        getMissingFields(prefix, "qualified_names", qualifiedNames, results);
      }
      if (hasPackage() && !package_.isInitialized()) {
        getMissingFields(prefix, "package", package_, results);
      }
      if (hasClass4() && !class4.isInitialized()) {
        getMissingFields(prefix, "class", class4, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeMessage(FieldNames.strings, strings);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeMessage(FieldNames.qualifiedNames, qualifiedNames);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeMessage(FieldNames.package_, package_);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRepeatedMessage(FieldNames.class4, class4);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public PackageFragment mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1881759102: {
            if (input.isAtField(FieldNames.strings)) {
              if (!input.trySkipNullValue()) {
                initStrings();
                input.readMessage(strings);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -565905396:
          case 135153125: {
            if (input.isAtField(FieldNames.qualifiedNames)) {
              if (!input.trySkipNullValue()) {
                initQualifiedNames();
                input.readMessage(qualifiedNames);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -807062458: {
            if (input.isAtField(FieldNames.package_)) {
              if (!input.trySkipNullValue()) {
                initPackage();
                input.readMessage(package_);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 94742904: {
            if (input.isAtField(FieldNames.class4)) {
              if (!input.trySkipNullValue()) {
                initClass4();
                input.readRepeatedMessage(class4);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public PackageFragment clone() {
      return new PackageFragment().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static PackageFragment parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new PackageFragment(), data).checkInitialized();
    }

    public static PackageFragment parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PackageFragment(), input).checkInitialized();
    }

    public static PackageFragment parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PackageFragment(), input).checkInitialized();
    }

    /**
     * @return factory for creating PackageFragment messages
     */
    public static MessageFactory<PackageFragment> getFactory() {
      return PackageFragmentFactory.INSTANCE;
    }

    private enum PackageFragmentFactory implements MessageFactory<PackageFragment> {
      INSTANCE;

      @Override
      public PackageFragment create() {
        return PackageFragment.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName strings = FieldName.forField("strings");

      static final FieldName qualifiedNames = FieldName.forField("qualifiedNames", "qualified_names");

      static final FieldName package_ = FieldName.forField("package");

      static final FieldName class4 = FieldName.forField("class");
    }
  }

  /**
   * Protobuf type {@code Contract}
   */
  public static final class Contract extends ProtoMessage<Contract> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Effect effect = 1;</code>
     */
    private RepeatedMessage<Effect> effect = null;

    private Contract() {
    }

    /**
     * @return a new empty instance of {@code Contract}
     */
    public static Contract newInstance() {
      return new Contract();
    }

    private void initEffect() {
      if (effect == null) {
        effect = RepeatedMessage.newEmptyInstance(Effect.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Effect effect = 1;</code>
     * @return whether the effect field is set
     */
    public boolean hasEffect() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Effect effect = 1;</code>
     * @return this
     */
    public Contract clearEffect() {
      bitField0_ &= ~0x00000001;
      if (effect != null) {
        effect.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Effect effect = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEffect()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Effect> getEffect() {
      initEffect();
      return effect;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Effect effect = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Effect> getMutableEffect() {
      initEffect();
      bitField0_ |= 0x00000001;
      return effect;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Effect effect = 1;</code>
     * @param value the effect to add
     * @return this
     */
    public Contract addEffect(final Effect value) {
      initEffect();
      bitField0_ |= 0x00000001;
      effect.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Effect effect = 1;</code>
     * @param values the effect to add
     * @return this
     */
    public Contract addAllEffect(final Effect... values) {
      initEffect();
      bitField0_ |= 0x00000001;
      effect.addAll(values);
      return this;
    }

    @Override
    public Contract copyFrom(final Contract other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasEffect()) {
          initEffect();
          effect.copyFrom(other.effect);
        } else {
          clearEffect();
        }
      }
      return this;
    }

    @Override
    public Contract mergeFrom(final Contract other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasEffect()) {
        getMutableEffect().addAll(other.effect);
      }
      return this;
    }

    @Override
    public Contract clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (effect != null) {
        effect.clear();
      }
      return this;
    }

    @Override
    public Contract clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (effect != null) {
        effect.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Contract)) {
        return false;
      }
      Contract other = (Contract) o;
      return bitField0_ == other.bitField0_
        && (!hasEffect() || effect.equals(other.effect));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        for (int i = 0; i < effect.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(effect.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += (1 * effect.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(effect);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Contract mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // effect
            initEffect();
            tag = input.readRepeatedMessage(effect, tag);
            bitField0_ |= 0x00000001;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRepeatedMessage(FieldNames.effect, effect);
      }
      output.endObject();
    }

    @Override
    public Contract mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1306084975: {
            if (input.isAtField(FieldNames.effect)) {
              if (!input.trySkipNullValue()) {
                initEffect();
                input.readRepeatedMessage(effect);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Contract clone() {
      return new Contract().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Contract parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Contract(), data).checkInitialized();
    }

    public static Contract parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Contract(), input).checkInitialized();
    }

    public static Contract parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Contract(), input).checkInitialized();
    }

    /**
     * @return factory for creating Contract messages
     */
    public static MessageFactory<Contract> getFactory() {
      return ContractFactory.INSTANCE;
    }

    private enum ContractFactory implements MessageFactory<Contract> {
      INSTANCE;

      @Override
      public Contract create() {
        return Contract.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName effect = FieldName.forField("effect");
    }
  }

  /**
   * Protobuf type {@code Effect}
   */
  public static final class Effect extends ProtoMessage<Effect> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectType effect_type = 1;</code>
     */
    private int effectType;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.InvocationKind kind = 4;</code>
     */
    private int kind;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectConditionKind condition_kind = 5;</code>
     */
    private int conditionKind;

    /**
     * <pre>
     *  If present and condition_kind is 0 or absent, then whole message is clause of form 'Effect -> Expression', where 'Effect'
     *  is given by other fields in this message, and 'Expression' is stored in this field.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Expression conclusion_of_conditional_effect = 3;</code>
     */
    private Expression conclusionOfConditionalEffect = null;

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression effect_constructor_argument = 2;</code>
     */
    private RepeatedMessage<Expression> effectConstructorArgument = null;

    private Effect() {
    }

    /**
     * @return a new empty instance of {@code Effect}
     */
    public static Effect newInstance() {
      return new Effect();
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectType effect_type = 1;</code>
     * @return whether the effectType field is set
     */
    public boolean hasEffectType() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectType effect_type = 1;</code>
     * @return this
     */
    public Effect clearEffectType() {
      bitField0_ &= ~0x00000001;
      effectType = 0;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectType effect_type = 1;</code>
     * @return the effectType
     */
    public EffectType getEffectType() {
      return EffectType.forNumber(effectType);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link Effect#getEffectType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getEffectTypeValue() {
      return effectType;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link EffectType}. Setting an invalid value
     * can cause {@link Effect#getEffectType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public Effect setEffectTypeValue(final int value) {
      bitField0_ |= 0x00000001;
      effectType = value;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectType effect_type = 1;</code>
     * @param value the effectType to set
     * @return this
     */
    public Effect setEffectType(final EffectType value) {
      bitField0_ |= 0x00000001;
      effectType = value.getNumber();
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.InvocationKind kind = 4;</code>
     * @return whether the kind field is set
     */
    public boolean hasKind() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.InvocationKind kind = 4;</code>
     * @return this
     */
    public Effect clearKind() {
      bitField0_ &= ~0x00000002;
      kind = 0;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.InvocationKind kind = 4;</code>
     * @return the kind
     */
    public InvocationKind getKind() {
      return InvocationKind.forNumber(kind);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link Effect#getKind()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getKindValue() {
      return kind;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link InvocationKind}. Setting an invalid value
     * can cause {@link Effect#getKind()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public Effect setKindValue(final int value) {
      bitField0_ |= 0x00000002;
      kind = value;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.InvocationKind kind = 4;</code>
     * @param value the kind to set
     * @return this
     */
    public Effect setKind(final InvocationKind value) {
      bitField0_ |= 0x00000002;
      kind = value.getNumber();
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectConditionKind condition_kind = 5;</code>
     * @return whether the conditionKind field is set
     */
    public boolean hasConditionKind() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectConditionKind condition_kind = 5;</code>
     * @return this
     */
    public Effect clearConditionKind() {
      bitField0_ &= ~0x00000004;
      conditionKind = 0;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectConditionKind condition_kind = 5;</code>
     * @return the conditionKind
     */
    public EffectConditionKind getConditionKind() {
      return EffectConditionKind.forNumber(conditionKind);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link Effect#getConditionKind()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getConditionKindValue() {
      return conditionKind;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link EffectConditionKind}. Setting an invalid value
     * can cause {@link Effect#getConditionKind()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public Effect setConditionKindValue(final int value) {
      bitField0_ |= 0x00000004;
      conditionKind = value;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Effect.EffectConditionKind condition_kind = 5;</code>
     * @param value the conditionKind to set
     * @return this
     */
    public Effect setConditionKind(final EffectConditionKind value) {
      bitField0_ |= 0x00000004;
      conditionKind = value.getNumber();
      return this;
    }

    private void initConclusionOfConditionalEffect() {
      if (conclusionOfConditionalEffect == null) {
        conclusionOfConditionalEffect = Expression.newInstance();
      }
    }

    /**
     * <pre>
     *  If present and condition_kind is 0 or absent, then whole message is clause of form 'Effect -> Expression', where 'Effect'
     *  is given by other fields in this message, and 'Expression' is stored in this field.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Expression conclusion_of_conditional_effect = 3;</code>
     * @return whether the conclusionOfConditionalEffect field is set
     */
    public boolean hasConclusionOfConditionalEffect() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <pre>
     *  If present and condition_kind is 0 or absent, then whole message is clause of form 'Effect -> Expression', where 'Effect'
     *  is given by other fields in this message, and 'Expression' is stored in this field.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Expression conclusion_of_conditional_effect = 3;</code>
     * @return this
     */
    public Effect clearConclusionOfConditionalEffect() {
      bitField0_ &= ~0x00000008;
      if (conclusionOfConditionalEffect != null) {
        conclusionOfConditionalEffect.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  If present and condition_kind is 0 or absent, then whole message is clause of form 'Effect -> Expression', where 'Effect'
     *  is given by other fields in this message, and 'Expression' is stored in this field.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Expression conclusion_of_conditional_effect = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableConclusionOfConditionalEffect()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Expression getConclusionOfConditionalEffect() {
      initConclusionOfConditionalEffect();
      return conclusionOfConditionalEffect;
    }

    /**
     * <pre>
     *  If present and condition_kind is 0 or absent, then whole message is clause of form 'Effect -> Expression', where 'Effect'
     *  is given by other fields in this message, and 'Expression' is stored in this field.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Expression conclusion_of_conditional_effect = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Expression getMutableConclusionOfConditionalEffect() {
      initConclusionOfConditionalEffect();
      bitField0_ |= 0x00000008;
      return conclusionOfConditionalEffect;
    }

    /**
     * <pre>
     *  If present and condition_kind is 0 or absent, then whole message is clause of form 'Effect -> Expression', where 'Effect'
     *  is given by other fields in this message, and 'Expression' is stored in this field.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Expression conclusion_of_conditional_effect = 3;</code>
     * @param value the conclusionOfConditionalEffect to set
     * @return this
     */
    public Effect setConclusionOfConditionalEffect(final Expression value) {
      initConclusionOfConditionalEffect();
      bitField0_ |= 0x00000008;
      conclusionOfConditionalEffect.copyFrom(value);
      return this;
    }

    private void initEffectConstructorArgument() {
      if (effectConstructorArgument == null) {
        effectConstructorArgument = RepeatedMessage.newEmptyInstance(Expression.getFactory());
      }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression effect_constructor_argument = 2;</code>
     * @return whether the effectConstructorArgument field is set
     */
    public boolean hasEffectConstructorArgument() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression effect_constructor_argument = 2;</code>
     * @return this
     */
    public Effect clearEffectConstructorArgument() {
      bitField0_ &= ~0x00000010;
      if (effectConstructorArgument != null) {
        effectConstructorArgument.clear();
      }
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression effect_constructor_argument = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEffectConstructorArgument()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Expression> getEffectConstructorArgument() {
      initEffectConstructorArgument();
      return effectConstructorArgument;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression effect_constructor_argument = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Expression> getMutableEffectConstructorArgument() {
      initEffectConstructorArgument();
      bitField0_ |= 0x00000010;
      return effectConstructorArgument;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression effect_constructor_argument = 2;</code>
     * @param value the effectConstructorArgument to add
     * @return this
     */
    public Effect addEffectConstructorArgument(final Expression value) {
      initEffectConstructorArgument();
      bitField0_ |= 0x00000010;
      effectConstructorArgument.add(value);
      return this;
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression effect_constructor_argument = 2;</code>
     * @param values the effectConstructorArgument to add
     * @return this
     */
    public Effect addAllEffectConstructorArgument(final Expression... values) {
      initEffectConstructorArgument();
      bitField0_ |= 0x00000010;
      effectConstructorArgument.addAll(values);
      return this;
    }

    @Override
    public Effect copyFrom(final Effect other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        effectType = other.effectType;
        kind = other.kind;
        conditionKind = other.conditionKind;
        if (other.hasConclusionOfConditionalEffect()) {
          initConclusionOfConditionalEffect();
          conclusionOfConditionalEffect.copyFrom(other.conclusionOfConditionalEffect);
        } else {
          clearConclusionOfConditionalEffect();
        }
        if (other.hasEffectConstructorArgument()) {
          initEffectConstructorArgument();
          effectConstructorArgument.copyFrom(other.effectConstructorArgument);
        } else {
          clearEffectConstructorArgument();
        }
      }
      return this;
    }

    @Override
    public Effect mergeFrom(final Effect other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasEffectType()) {
        setEffectTypeValue(other.effectType);
      }
      if (other.hasKind()) {
        setKindValue(other.kind);
      }
      if (other.hasConditionKind()) {
        setConditionKindValue(other.conditionKind);
      }
      if (other.hasConclusionOfConditionalEffect()) {
        getMutableConclusionOfConditionalEffect().mergeFrom(other.conclusionOfConditionalEffect);
      }
      if (other.hasEffectConstructorArgument()) {
        getMutableEffectConstructorArgument().addAll(other.effectConstructorArgument);
      }
      return this;
    }

    @Override
    public Effect clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      effectType = 0;
      kind = 0;
      conditionKind = 0;
      if (conclusionOfConditionalEffect != null) {
        conclusionOfConditionalEffect.clear();
      }
      if (effectConstructorArgument != null) {
        effectConstructorArgument.clear();
      }
      return this;
    }

    @Override
    public Effect clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (conclusionOfConditionalEffect != null) {
        conclusionOfConditionalEffect.clearQuick();
      }
      if (effectConstructorArgument != null) {
        effectConstructorArgument.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Effect)) {
        return false;
      }
      Effect other = (Effect) o;
      return bitField0_ == other.bitField0_
        && (!hasEffectType() || effectType == other.effectType)
        && (!hasKind() || kind == other.kind)
        && (!hasConditionKind() || conditionKind == other.conditionKind)
        && (!hasConclusionOfConditionalEffect() || conclusionOfConditionalEffect.equals(other.conclusionOfConditionalEffect))
        && (!hasEffectConstructorArgument() || effectConstructorArgument.equals(other.effectConstructorArgument));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeEnumNoTag(effectType);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeEnumNoTag(kind);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 40);
        output.writeEnumNoTag(conditionKind);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 26);
        output.writeMessageNoTag(conclusionOfConditionalEffect);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < effectConstructorArgument.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(effectConstructorArgument.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(effectType);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(kind);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(conditionKind);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(conclusionOfConditionalEffect);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * effectConstructorArgument.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(effectConstructorArgument);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Effect mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // effectType
            final int value = input.readInt32();
            if (EffectType.forNumber(value) != null) {
              effectType = value;
              bitField0_ |= 0x00000001;
            }
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // kind
            final int value = input.readInt32();
            if (InvocationKind.forNumber(value) != null) {
              kind = value;
              bitField0_ |= 0x00000002;
            }
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // conditionKind
            final int value = input.readInt32();
            if (EffectConditionKind.forNumber(value) != null) {
              conditionKind = value;
              bitField0_ |= 0x00000004;
            }
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // conclusionOfConditionalEffect
            initConclusionOfConditionalEffect();
            input.readMessage(conclusionOfConditionalEffect);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // effectConstructorArgument
            initEffectConstructorArgument();
            tag = input.readRepeatedMessage(effectConstructorArgument, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeEnum(FieldNames.effectType, effectType, EffectType.converter());
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeEnum(FieldNames.kind, kind, InvocationKind.converter());
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeEnum(FieldNames.conditionKind, conditionKind, EffectConditionKind.converter());
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeMessage(FieldNames.conclusionOfConditionalEffect, conclusionOfConditionalEffect);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.effectConstructorArgument, effectConstructorArgument);
      }
      output.endObject();
    }

    @Override
    public Effect mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1715833963:
          case 1661264168: {
            if (input.isAtField(FieldNames.effectType)) {
              if (!input.trySkipNullValue()) {
                final EffectType value = input.readEnum(EffectType.converter());
                if (value != null) {
                  effectType = value.getNumber();
                  bitField0_ |= 0x00000001;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3292052: {
            if (input.isAtField(FieldNames.kind)) {
              if (!input.trySkipNullValue()) {
                final InvocationKind value = input.readEnum(InvocationKind.converter());
                if (value != null) {
                  kind = value.getNumber();
                  bitField0_ |= 0x00000002;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1372264271:
          case -390954952: {
            if (input.isAtField(FieldNames.conditionKind)) {
              if (!input.trySkipNullValue()) {
                final EffectConditionKind value = input.readEnum(EffectConditionKind.converter());
                if (value != null) {
                  conditionKind = value.getNumber();
                  bitField0_ |= 0x00000004;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -468193791:
          case -1176282446: {
            if (input.isAtField(FieldNames.conclusionOfConditionalEffect)) {
              if (!input.trySkipNullValue()) {
                initConclusionOfConditionalEffect();
                input.readMessage(conclusionOfConditionalEffect);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1776081798:
          case 1665451856: {
            if (input.isAtField(FieldNames.effectConstructorArgument)) {
              if (!input.trySkipNullValue()) {
                initEffectConstructorArgument();
                input.readRepeatedMessage(effectConstructorArgument);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Effect clone() {
      return new Effect().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Effect parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Effect(), data).checkInitialized();
    }

    public static Effect parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Effect(), input).checkInitialized();
    }

    public static Effect parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Effect(), input).checkInitialized();
    }

    /**
     * @return factory for creating Effect messages
     */
    public static MessageFactory<Effect> getFactory() {
      return EffectFactory.INSTANCE;
    }

    /**
     * <pre>
     *  This enum controls which effect this message contains and how 'effectConstructorArguments'
     *  should be parsed.
     *  Each enum value documented in the following syntax: "EffectName(arg1: T1, arg2: T2, ...)"
     *  Those arguments are expected to be found in 'effectConstructorArguments' in exactly the same
     *  order and amount as defined by signature, otherwise message should be dropped.
     * </pre>
     *
     * Protobuf enum {@code EffectType}
     */
    public enum EffectType implements ProtoEnum<EffectType> {
      /**
       * <pre>
       *  Returns(value: ConstantValue?)
       * </pre>
       *
       * <code>RETURNS_CONSTANT = 0;</code>
       */
      RETURNS_CONSTANT("RETURNS_CONSTANT", 0),

      /**
       * <pre>
       *  CallsInPlace(callable: ParameterReference)
       *  Additionally, InvocationKind in the field 'kind' may be provided to define exact amount of invocations.
       * </pre>
       *
       * <code>CALLS = 1;</code>
       */
      CALLS("CALLS", 1),

      /**
       * <pre>
       *  ReturnsNotNull()
       * </pre>
       *
       * <code>RETURNS_NOT_NULL = 2;</code>
       */
      RETURNS_NOT_NULL("RETURNS_NOT_NULL", 2);

      /**
       * <pre>
       *  Returns(value: ConstantValue?)
       * </pre>
       *
       * <code>RETURNS_CONSTANT = 0;</code>
       */
      public static final int RETURNS_CONSTANT_VALUE = 0;

      /**
       * <pre>
       *  CallsInPlace(callable: ParameterReference)
       *  Additionally, InvocationKind in the field 'kind' may be provided to define exact amount of invocations.
       * </pre>
       *
       * <code>CALLS = 1;</code>
       */
      public static final int CALLS_VALUE = 1;

      /**
       * <pre>
       *  ReturnsNotNull()
       * </pre>
       *
       * <code>RETURNS_NOT_NULL = 2;</code>
       */
      public static final int RETURNS_NOT_NULL_VALUE = 2;

      private final String name;

      private final int number;

      private EffectType(String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<EffectType> converter() {
        return EffectTypeConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static EffectType forNumber(int value) {
        return EffectTypeConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static EffectType forNumberOr(int number, EffectType other) {
        EffectType value = forNumber(number);
        return value == null ? other : value;
      }

      enum EffectTypeConverter implements ProtoEnum.EnumConverter<EffectType> {
        INSTANCE;

        private static final EffectType[] lookup = new EffectType[3];

        static {
          lookup[0] = RETURNS_CONSTANT;
          lookup[1] = CALLS;
          lookup[2] = RETURNS_NOT_NULL;
        }

        @Override
        public final EffectType forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final EffectType forName(final CharSequence value) {
          if (value.length() == 5) {
            if (ProtoUtil.isEqual("CALLS", value)) {
              return CALLS;
            }
          }
          if (value.length() == 16) {
            if (ProtoUtil.isEqual("RETURNS_CONSTANT", value)) {
              return RETURNS_CONSTANT;
            }
            if (ProtoUtil.isEqual("RETURNS_NOT_NULL", value)) {
              return RETURNS_NOT_NULL;
            }
          }
          return null;
        }
      }
    }

    /**
     * Protobuf enum {@code InvocationKind}
     */
    public enum InvocationKind implements ProtoEnum<InvocationKind> {
      /**
       * <code>AT_MOST_ONCE = 0;</code>
       */
      AT_MOST_ONCE("AT_MOST_ONCE", 0),

      /**
       * <code>EXACTLY_ONCE = 1;</code>
       */
      EXACTLY_ONCE("EXACTLY_ONCE", 1),

      /**
       * <code>AT_LEAST_ONCE = 2;</code>
       */
      AT_LEAST_ONCE("AT_LEAST_ONCE", 2);

      /**
       * <code>AT_MOST_ONCE = 0;</code>
       */
      public static final int AT_MOST_ONCE_VALUE = 0;

      /**
       * <code>EXACTLY_ONCE = 1;</code>
       */
      public static final int EXACTLY_ONCE_VALUE = 1;

      /**
       * <code>AT_LEAST_ONCE = 2;</code>
       */
      public static final int AT_LEAST_ONCE_VALUE = 2;

      private final String name;

      private final int number;

      private InvocationKind(String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<InvocationKind> converter() {
        return InvocationKindConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static InvocationKind forNumber(int value) {
        return InvocationKindConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static InvocationKind forNumberOr(int number, InvocationKind other) {
        InvocationKind value = forNumber(number);
        return value == null ? other : value;
      }

      enum InvocationKindConverter implements ProtoEnum.EnumConverter<InvocationKind> {
        INSTANCE;

        private static final InvocationKind[] lookup = new InvocationKind[3];

        static {
          lookup[0] = AT_MOST_ONCE;
          lookup[1] = EXACTLY_ONCE;
          lookup[2] = AT_LEAST_ONCE;
        }

        @Override
        public final InvocationKind forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final InvocationKind forName(final CharSequence value) {
          if (value.length() == 12) {
            if (ProtoUtil.isEqual("AT_MOST_ONCE", value)) {
              return AT_MOST_ONCE;
            }
            if (ProtoUtil.isEqual("EXACTLY_ONCE", value)) {
              return EXACTLY_ONCE;
            }
          }
          if (value.length() == 13) {
            if (ProtoUtil.isEqual("AT_LEAST_ONCE", value)) {
              return AT_LEAST_ONCE;
            }
          }
          return null;
        }
      }
    }

    /**
     * Protobuf enum {@code EffectConditionKind}
     */
    public enum EffectConditionKind implements ProtoEnum<EffectConditionKind> {
      /**
       * <pre>
       *  also default
       * </pre>
       *
       * <code>CONCLUSION_CONDITION = 0;</code>
       */
      CONCLUSION_CONDITION("CONCLUSION_CONDITION", 0),

      /**
       * <pre>
       *  "implies returns" condition. If condition_kind set to it, then then whole message is clause of form
       * </pre>
       *
       * <code>RETURNS_CONDITION = 1;</code>
       */
      RETURNS_CONDITION("RETURNS_CONDITION", 1),

      /**
       * <pre>
       *  'Expression -> ReturnsEffect', where 'ReturnsEffect' is given by other fields
       *  and 'Expression' is stored in the conclusion_of_conditional_effect
       * </pre>
       *
       * <code>HOLDSIN_CONDITION = 2;</code>
       */
      HOLDSIN_CONDITION("HOLDSIN_CONDITION", 2);

      /**
       * <pre>
       *  also default
       * </pre>
       *
       * <code>CONCLUSION_CONDITION = 0;</code>
       */
      public static final int CONCLUSION_CONDITION_VALUE = 0;

      /**
       * <pre>
       *  "implies returns" condition. If condition_kind set to it, then then whole message is clause of form
       * </pre>
       *
       * <code>RETURNS_CONDITION = 1;</code>
       */
      public static final int RETURNS_CONDITION_VALUE = 1;

      /**
       * <pre>
       *  'Expression -> ReturnsEffect', where 'ReturnsEffect' is given by other fields
       *  and 'Expression' is stored in the conclusion_of_conditional_effect
       * </pre>
       *
       * <code>HOLDSIN_CONDITION = 2;</code>
       */
      public static final int HOLDSIN_CONDITION_VALUE = 2;

      private final String name;

      private final int number;

      private EffectConditionKind(String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<EffectConditionKind> converter() {
        return EffectConditionKindConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static EffectConditionKind forNumber(int value) {
        return EffectConditionKindConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static EffectConditionKind forNumberOr(int number, EffectConditionKind other) {
        EffectConditionKind value = forNumber(number);
        return value == null ? other : value;
      }

      enum EffectConditionKindConverter implements ProtoEnum.EnumConverter<EffectConditionKind> {
        INSTANCE;

        private static final EffectConditionKind[] lookup = new EffectConditionKind[3];

        static {
          lookup[0] = CONCLUSION_CONDITION;
          lookup[1] = RETURNS_CONDITION;
          lookup[2] = HOLDSIN_CONDITION;
        }

        @Override
        public final EffectConditionKind forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final EffectConditionKind forName(final CharSequence value) {
          if (value.length() == 17) {
            if (ProtoUtil.isEqual("RETURNS_CONDITION", value)) {
              return RETURNS_CONDITION;
            }
            if (ProtoUtil.isEqual("HOLDSIN_CONDITION", value)) {
              return HOLDSIN_CONDITION;
            }
          }
          if (value.length() == 20) {
            if (ProtoUtil.isEqual("CONCLUSION_CONDITION", value)) {
              return CONCLUSION_CONDITION;
            }
          }
          return null;
        }
      }
    }

    private enum EffectFactory implements MessageFactory<Effect> {
      INSTANCE;

      @Override
      public Effect create() {
        return Effect.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName effectType = FieldName.forField("effectType", "effect_type");

      static final FieldName kind = FieldName.forField("kind");

      static final FieldName conditionKind = FieldName.forField("conditionKind", "condition_kind");

      static final FieldName conclusionOfConditionalEffect = FieldName.forField("conclusionOfConditionalEffect", "conclusion_of_conditional_effect");

      static final FieldName effectConstructorArgument = FieldName.forField("effectConstructorArgument", "effect_constructor_argument");
    }
  }

  /**
   * <pre>
   *  We use some trickery to optimize memory footprint of contract-expressions:
   *  exact type of Expression is determined based on its contents.
   * </pre>
   *
   * Protobuf type {@code Expression}
   */
  public static final class Expression extends ProtoMessage<Expression> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     */
    private int flags = 0;

    /**
     * <pre>
     *  stored as index in valueParameters list of owner-function in 1-indexation
     *  Index '0' is reserved for extension receiver
     * </pre>
     *
     * <code>optional int32 value_parameter_reference = 2;</code>
     */
    private int valueParameterReference;

    /**
     * <code>optional int32 is_instance_type_id = 5;</code>
     */
    private int isInstanceTypeId;

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Expression.ConstantValue constant_value = 3;</code>
     */
    private int constantValue;

    /**
     * <pre>
     *  present => this expression is IsInstancePredicate,  with 'variableName' as LHS
     *  and with type encoded in either one of next two fields as RHS.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type is_instance_type = 4;</code>
     */
    private Type isInstanceType = null;

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'andArguments[0] && andArguments[1] && ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression and_argument = 6;</code>
     */
    private RepeatedMessage<Expression> andArgument = null;

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'orArguments[0] || andArguments[1] || ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message.
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression or_argument = 7;</code>
     */
    private RepeatedMessage<Expression> orArgument = null;

    private Expression() {
    }

    /**
     * <pre>
     *  We use some trickery to optimize memory footprint of contract-expressions:
     *  exact type of Expression is determined based on its contents.
     * </pre>
     *
     * @return a new empty instance of {@code Expression}
     */
    public static Expression newInstance() {
      return new Expression();
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     * @return whether the flags field is set
     */
    public boolean hasFlags() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     * @return this
     */
    public Expression clearFlags() {
      bitField0_ &= ~0x00000001;
      flags = 0;
      return this;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     * @return the flags
     */
    public int getFlags() {
      return flags;
    }

    /**
     * <pre>
     *
     * hasAnnotations
     * declaresDefault
     * isCrossinline
     * isNoinline
     * </pre>
     *
     * <code>optional int32 flags = 1 [default = 0];</code>
     * @param value the flags to set
     * @return this
     */
    public Expression setFlags(final int value) {
      bitField0_ |= 0x00000001;
      flags = value;
      return this;
    }

    /**
     * <pre>
     *  stored as index in valueParameters list of owner-function in 1-indexation
     *  Index '0' is reserved for extension receiver
     * </pre>
     *
     * <code>optional int32 value_parameter_reference = 2;</code>
     * @return whether the valueParameterReference field is set
     */
    public boolean hasValueParameterReference() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <pre>
     *  stored as index in valueParameters list of owner-function in 1-indexation
     *  Index '0' is reserved for extension receiver
     * </pre>
     *
     * <code>optional int32 value_parameter_reference = 2;</code>
     * @return this
     */
    public Expression clearValueParameterReference() {
      bitField0_ &= ~0x00000002;
      valueParameterReference = 0;
      return this;
    }

    /**
     * <pre>
     *  stored as index in valueParameters list of owner-function in 1-indexation
     *  Index '0' is reserved for extension receiver
     * </pre>
     *
     * <code>optional int32 value_parameter_reference = 2;</code>
     * @return the valueParameterReference
     */
    public int getValueParameterReference() {
      return valueParameterReference;
    }

    /**
     * <pre>
     *  stored as index in valueParameters list of owner-function in 1-indexation
     *  Index '0' is reserved for extension receiver
     * </pre>
     *
     * <code>optional int32 value_parameter_reference = 2;</code>
     * @param value the valueParameterReference to set
     * @return this
     */
    public Expression setValueParameterReference(final int value) {
      bitField0_ |= 0x00000002;
      valueParameterReference = value;
      return this;
    }

    /**
     * <code>optional int32 is_instance_type_id = 5;</code>
     * @return whether the isInstanceTypeId field is set
     */
    public boolean hasIsInstanceTypeId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional int32 is_instance_type_id = 5;</code>
     * @return this
     */
    public Expression clearIsInstanceTypeId() {
      bitField0_ &= ~0x00000004;
      isInstanceTypeId = 0;
      return this;
    }

    /**
     * <code>optional int32 is_instance_type_id = 5;</code>
     * @return the isInstanceTypeId
     */
    public int getIsInstanceTypeId() {
      return isInstanceTypeId;
    }

    /**
     * <code>optional int32 is_instance_type_id = 5;</code>
     * @param value the isInstanceTypeId to set
     * @return this
     */
    public Expression setIsInstanceTypeId(final int value) {
      bitField0_ |= 0x00000004;
      isInstanceTypeId = value;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Expression.ConstantValue constant_value = 3;</code>
     * @return whether the constantValue field is set
     */
    public boolean hasConstantValue() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Expression.ConstantValue constant_value = 3;</code>
     * @return this
     */
    public Expression clearConstantValue() {
      bitField0_ &= ~0x00000008;
      constantValue = 0;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Expression.ConstantValue constant_value = 3;</code>
     * @return the constantValue
     */
    public ConstantValue getConstantValue() {
      return ConstantValue.forNumber(constantValue);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link Expression#getConstantValue()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getConstantValueValue() {
      return constantValue;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link ConstantValue}. Setting an invalid value
     * can cause {@link Expression#getConstantValue()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public Expression setConstantValueValue(final int value) {
      bitField0_ |= 0x00000008;
      constantValue = value;
      return this;
    }

    /**
     * <code>optional .org.jetbrains.kotlin.metadata.Expression.ConstantValue constant_value = 3;</code>
     * @param value the constantValue to set
     * @return this
     */
    public Expression setConstantValue(final ConstantValue value) {
      bitField0_ |= 0x00000008;
      constantValue = value.getNumber();
      return this;
    }

    private void initIsInstanceType() {
      if (isInstanceType == null) {
        isInstanceType = Type.newInstance();
      }
    }

    /**
     * <pre>
     *  present => this expression is IsInstancePredicate,  with 'variableName' as LHS
     *  and with type encoded in either one of next two fields as RHS.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type is_instance_type = 4;</code>
     * @return whether the isInstanceType field is set
     */
    public boolean hasIsInstanceType() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <pre>
     *  present => this expression is IsInstancePredicate,  with 'variableName' as LHS
     *  and with type encoded in either one of next two fields as RHS.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type is_instance_type = 4;</code>
     * @return this
     */
    public Expression clearIsInstanceType() {
      bitField0_ &= ~0x00000010;
      if (isInstanceType != null) {
        isInstanceType.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  present => this expression is IsInstancePredicate,  with 'variableName' as LHS
     *  and with type encoded in either one of next two fields as RHS.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type is_instance_type = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableIsInstanceType()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Type getIsInstanceType() {
      initIsInstanceType();
      return isInstanceType;
    }

    /**
     * <pre>
     *  present => this expression is IsInstancePredicate,  with 'variableName' as LHS
     *  and with type encoded in either one of next two fields as RHS.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type is_instance_type = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Type getMutableIsInstanceType() {
      initIsInstanceType();
      bitField0_ |= 0x00000010;
      return isInstanceType;
    }

    /**
     * <pre>
     *  present => this expression is IsInstancePredicate,  with 'variableName' as LHS
     *  and with type encoded in either one of next two fields as RHS.
     * </pre>
     *
     * <code>optional .org.jetbrains.kotlin.metadata.Type is_instance_type = 4;</code>
     * @param value the isInstanceType to set
     * @return this
     */
    public Expression setIsInstanceType(final Type value) {
      initIsInstanceType();
      bitField0_ |= 0x00000010;
      isInstanceType.copyFrom(value);
      return this;
    }

    private void initAndArgument() {
      if (andArgument == null) {
        andArgument = RepeatedMessage.newEmptyInstance(Expression.getFactory());
      }
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'andArguments[0] && andArguments[1] && ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression and_argument = 6;</code>
     * @return whether the andArgument field is set
     */
    public boolean hasAndArgument() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'andArguments[0] && andArguments[1] && ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression and_argument = 6;</code>
     * @return this
     */
    public Expression clearAndArgument() {
      bitField0_ &= ~0x00000020;
      if (andArgument != null) {
        andArgument.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'andArguments[0] && andArguments[1] && ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression and_argument = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAndArgument()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Expression> getAndArgument() {
      initAndArgument();
      return andArgument;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'andArguments[0] && andArguments[1] && ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression and_argument = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Expression> getMutableAndArgument() {
      initAndArgument();
      bitField0_ |= 0x00000020;
      return andArgument;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'andArguments[0] && andArguments[1] && ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression and_argument = 6;</code>
     * @param value the andArgument to add
     * @return this
     */
    public Expression addAndArgument(final Expression value) {
      initAndArgument();
      bitField0_ |= 0x00000020;
      andArgument.add(value);
      return this;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'andArguments[0] && andArguments[1] && ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression and_argument = 6;</code>
     * @param values the andArgument to add
     * @return this
     */
    public Expression addAllAndArgument(final Expression... values) {
      initAndArgument();
      bitField0_ |= 0x00000020;
      andArgument.addAll(values);
      return this;
    }

    private void initOrArgument() {
      if (orArgument == null) {
        orArgument = RepeatedMessage.newEmptyInstance(Expression.getFactory());
      }
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'orArguments[0] || andArguments[1] || ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message.
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression or_argument = 7;</code>
     * @return whether the orArgument field is set
     */
    public boolean hasOrArgument() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'orArguments[0] || andArguments[1] || ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message.
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression or_argument = 7;</code>
     * @return this
     */
    public Expression clearOrArgument() {
      bitField0_ &= ~0x00000040;
      if (orArgument != null) {
        orArgument.clear();
      }
      return this;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'orArguments[0] || andArguments[1] || ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message.
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression or_argument = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOrArgument()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Expression> getOrArgument() {
      initOrArgument();
      return orArgument;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'orArguments[0] || andArguments[1] || ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message.
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression or_argument = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Expression> getMutableOrArgument() {
      initOrArgument();
      bitField0_ |= 0x00000040;
      return orArgument;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'orArguments[0] || andArguments[1] || ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message.
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression or_argument = 7;</code>
     * @param value the orArgument to add
     * @return this
     */
    public Expression addOrArgument(final Expression value) {
      initOrArgument();
      bitField0_ |= 0x00000040;
      orArgument.add(value);
      return this;
    }

    /**
     * <pre>
     *  non-empty => this expression is boolean formula of form 'orArguments[0] || andArguments[1] || ...'
     *  Additionally, if first argument of formula is primitive expression (i.e. predicate or value),
     *  it is optimized and embedded straight into this message.
     * </pre>
     *
     * <code>repeated .org.jetbrains.kotlin.metadata.Expression or_argument = 7;</code>
     * @param values the orArgument to add
     * @return this
     */
    public Expression addAllOrArgument(final Expression... values) {
      initOrArgument();
      bitField0_ |= 0x00000040;
      orArgument.addAll(values);
      return this;
    }

    @Override
    public Expression copyFrom(final Expression other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        flags = other.flags;
        valueParameterReference = other.valueParameterReference;
        isInstanceTypeId = other.isInstanceTypeId;
        constantValue = other.constantValue;
        if (other.hasIsInstanceType()) {
          initIsInstanceType();
          isInstanceType.copyFrom(other.isInstanceType);
        } else {
          clearIsInstanceType();
        }
        if (other.hasAndArgument()) {
          initAndArgument();
          andArgument.copyFrom(other.andArgument);
        } else {
          clearAndArgument();
        }
        if (other.hasOrArgument()) {
          initOrArgument();
          orArgument.copyFrom(other.orArgument);
        } else {
          clearOrArgument();
        }
      }
      return this;
    }

    @Override
    public Expression mergeFrom(final Expression other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFlags()) {
        setFlags(other.flags);
      }
      if (other.hasValueParameterReference()) {
        setValueParameterReference(other.valueParameterReference);
      }
      if (other.hasIsInstanceTypeId()) {
        setIsInstanceTypeId(other.isInstanceTypeId);
      }
      if (other.hasConstantValue()) {
        setConstantValueValue(other.constantValue);
      }
      if (other.hasIsInstanceType()) {
        getMutableIsInstanceType().mergeFrom(other.isInstanceType);
      }
      if (other.hasAndArgument()) {
        getMutableAndArgument().addAll(other.andArgument);
      }
      if (other.hasOrArgument()) {
        getMutableOrArgument().addAll(other.orArgument);
      }
      return this;
    }

    @Override
    public Expression clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flags = 0;
      valueParameterReference = 0;
      isInstanceTypeId = 0;
      constantValue = 0;
      if (isInstanceType != null) {
        isInstanceType.clear();
      }
      if (andArgument != null) {
        andArgument.clear();
      }
      if (orArgument != null) {
        orArgument.clear();
      }
      return this;
    }

    @Override
    public Expression clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (isInstanceType != null) {
        isInstanceType.clearQuick();
      }
      if (andArgument != null) {
        andArgument.clearQuick();
      }
      if (orArgument != null) {
        orArgument.clearQuick();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Expression)) {
        return false;
      }
      Expression other = (Expression) o;
      return bitField0_ == other.bitField0_
        && (!hasFlags() || flags == other.flags)
        && (!hasValueParameterReference() || valueParameterReference == other.valueParameterReference)
        && (!hasIsInstanceTypeId() || isInstanceTypeId == other.isInstanceTypeId)
        && (!hasConstantValue() || constantValue == other.constantValue)
        && (!hasIsInstanceType() || isInstanceType.equals(other.isInstanceType))
        && (!hasAndArgument() || andArgument.equals(other.andArgument))
        && (!hasOrArgument() || orArgument.equals(other.orArgument));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(flags);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(valueParameterReference);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 40);
        output.writeInt32NoTag(isInstanceTypeId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 24);
        output.writeEnumNoTag(constantValue);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 34);
        output.writeMessageNoTag(isInstanceType);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < andArgument.length(); i++) {
          output.writeRawByte((byte) 50);
          output.writeMessageNoTag(andArgument.get(i));
        }
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < orArgument.length(); i++) {
          output.writeRawByte((byte) 58);
          output.writeMessageNoTag(orArgument.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(flags);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(valueParameterReference);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(isInstanceTypeId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(constantValue);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(isInstanceType);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * andArgument.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(andArgument);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * orArgument.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(orArgument);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Expression mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // flags
            flags = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // valueParameterReference
            valueParameterReference = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // isInstanceTypeId
            isInstanceTypeId = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // constantValue
            final int value = input.readInt32();
            if (ConstantValue.forNumber(value) != null) {
              constantValue = value;
              bitField0_ |= 0x00000008;
            }
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // isInstanceType
            initIsInstanceType();
            input.readMessage(isInstanceType);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // andArgument
            initAndArgument();
            tag = input.readRepeatedMessage(andArgument, tag);
            bitField0_ |= 0x00000020;
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // orArgument
            initOrArgument();
            tag = input.readRepeatedMessage(orArgument, tag);
            bitField0_ |= 0x00000040;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.flags, flags);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt32(FieldNames.valueParameterReference, valueParameterReference);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeInt32(FieldNames.isInstanceTypeId, isInstanceTypeId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeEnum(FieldNames.constantValue, constantValue, ConstantValue.converter());
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeMessage(FieldNames.isInstanceType, isInstanceType);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedMessage(FieldNames.andArgument, andArgument);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedMessage(FieldNames.orArgument, orArgument);
      }
      output.endObject();
    }

    @Override
    public Expression mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 97513095: {
            if (input.isAtField(FieldNames.flags)) {
              if (!input.trySkipNullValue()) {
                flags = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2094600973:
          case 861809255: {
            if (input.isAtField(FieldNames.valueParameterReference)) {
              if (!input.trySkipNullValue()) {
                valueParameterReference = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1715980620:
          case 2017576203: {
            if (input.isAtField(FieldNames.isInstanceTypeId)) {
              if (!input.trySkipNullValue()) {
                isInstanceTypeId = input.readInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1527931949:
          case 397970710: {
            if (input.isAtField(FieldNames.constantValue)) {
              if (!input.trySkipNullValue()) {
                final ConstantValue value = input.readEnum(ConstantValue.converter());
                if (value != null) {
                  constantValue = value.getNumber();
                  bitField0_ |= 0x00000008;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1498990663:
          case 1632360015: {
            if (input.isAtField(FieldNames.isInstanceType)) {
              if (!input.trySkipNullValue()) {
                initIsInstanceType();
                input.readMessage(isInstanceType);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -234129996:
          case -135710683: {
            if (input.isAtField(FieldNames.andArgument)) {
              if (!input.trySkipNullValue()) {
                initAndArgument();
                input.readRepeatedMessage(andArgument);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1754579520:
          case -25005671: {
            if (input.isAtField(FieldNames.orArgument)) {
              if (!input.trySkipNullValue()) {
                initOrArgument();
                input.readRepeatedMessage(orArgument);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Expression clone() {
      return new Expression().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Expression parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Expression(), data).checkInitialized();
    }

    public static Expression parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Expression(), input).checkInitialized();
    }

    public static Expression parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Expression(), input).checkInitialized();
    }

    /**
     * @return factory for creating Expression messages
     */
    public static MessageFactory<Expression> getFactory() {
      return ExpressionFactory.INSTANCE;
    }

    /**
     * Protobuf enum {@code ConstantValue}
     */
    public enum ConstantValue implements ProtoEnum<ConstantValue> {
      /**
       * <code>TRUE = 0;</code>
       */
      TRUE("TRUE", 0),

      /**
       * <code>FALSE = 1;</code>
       */
      FALSE("FALSE", 1),

      /**
       * <code>NULL = 2;</code>
       */
      NULL("NULL", 2);

      /**
       * <code>TRUE = 0;</code>
       */
      public static final int TRUE_VALUE = 0;

      /**
       * <code>FALSE = 1;</code>
       */
      public static final int FALSE_VALUE = 1;

      /**
       * <code>NULL = 2;</code>
       */
      public static final int NULL_VALUE = 2;

      private final String name;

      private final int number;

      private ConstantValue(String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<ConstantValue> converter() {
        return ConstantValueConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static ConstantValue forNumber(int value) {
        return ConstantValueConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static ConstantValue forNumberOr(int number, ConstantValue other) {
        ConstantValue value = forNumber(number);
        return value == null ? other : value;
      }

      enum ConstantValueConverter implements ProtoEnum.EnumConverter<ConstantValue> {
        INSTANCE;

        private static final ConstantValue[] lookup = new ConstantValue[3];

        static {
          lookup[0] = TRUE;
          lookup[1] = FALSE;
          lookup[2] = NULL;
        }

        @Override
        public final ConstantValue forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final ConstantValue forName(final CharSequence value) {
          if (value.length() == 4) {
            if (ProtoUtil.isEqual("TRUE", value)) {
              return TRUE;
            }
            if (ProtoUtil.isEqual("NULL", value)) {
              return NULL;
            }
          }
          if (value.length() == 5) {
            if (ProtoUtil.isEqual("FALSE", value)) {
              return FALSE;
            }
          }
          return null;
        }
      }
    }

    private enum ExpressionFactory implements MessageFactory<Expression> {
      INSTANCE;

      @Override
      public Expression create() {
        return Expression.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName flags = FieldName.forField("flags");

      static final FieldName valueParameterReference = FieldName.forField("valueParameterReference", "value_parameter_reference");

      static final FieldName isInstanceTypeId = FieldName.forField("isInstanceTypeId", "is_instance_type_id");

      static final FieldName constantValue = FieldName.forField("constantValue", "constant_value");

      static final FieldName isInstanceType = FieldName.forField("isInstanceType", "is_instance_type");

      static final FieldName andArgument = FieldName.forField("andArgument", "and_argument");

      static final FieldName orArgument = FieldName.forField("orArgument", "or_argument");
    }
  }

  /**
   * Protobuf type {@code CompilerPluginData}
   */
  public static final class CompilerPluginData extends ProtoMessage<CompilerPluginData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>required int32 plugin_id = 1;</code>
     */
    private int pluginId;

    /**
     * <code>required bytes data = 2;</code>
     */
    private final RepeatedByte data = RepeatedByte.newEmptyInstance();

    private CompilerPluginData() {
    }

    /**
     * @return a new empty instance of {@code CompilerPluginData}
     */
    public static CompilerPluginData newInstance() {
      return new CompilerPluginData();
    }

    /**
     * <code>required int32 plugin_id = 1;</code>
     * @return whether the pluginId field is set
     */
    public boolean hasPluginId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>required int32 plugin_id = 1;</code>
     * @return this
     */
    public CompilerPluginData clearPluginId() {
      bitField0_ &= ~0x00000001;
      pluginId = 0;
      return this;
    }

    /**
     * <code>required int32 plugin_id = 1;</code>
     * @return the pluginId
     */
    public int getPluginId() {
      return pluginId;
    }

    /**
     * <code>required int32 plugin_id = 1;</code>
     * @param value the pluginId to set
     * @return this
     */
    public CompilerPluginData setPluginId(final int value) {
      bitField0_ |= 0x00000001;
      pluginId = value;
      return this;
    }

    /**
     * <code>required bytes data = 2;</code>
     * @return whether the data field is set
     */
    public boolean hasData() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>required bytes data = 2;</code>
     * @return this
     */
    public CompilerPluginData clearData() {
      bitField0_ &= ~0x00000002;
      data.clear();
      return this;
    }

    /**
     * <code>required bytes data = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getData() {
      return data;
    }

    /**
     * <code>required bytes data = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableData() {
      bitField0_ |= 0x00000002;
      return data;
    }

    /**
     * <code>required bytes data = 2;</code>
     * @param value the data to add
     * @return this
     */
    public CompilerPluginData addData(final byte value) {
      bitField0_ |= 0x00000002;
      data.add(value);
      return this;
    }

    /**
     * <code>required bytes data = 2;</code>
     * @param values the data to add
     * @return this
     */
    public CompilerPluginData addAllData(final byte... values) {
      bitField0_ |= 0x00000002;
      data.addAll(values);
      return this;
    }

    /**
     * <code>required bytes data = 2;</code>
     * @param values the data to set
     * @return this
     */
    public CompilerPluginData setData(final byte... values) {
      bitField0_ |= 0x00000002;
      data.copyFrom(values);
      return this;
    }

    @Override
    public CompilerPluginData copyFrom(final CompilerPluginData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        pluginId = other.pluginId;
        data.copyFrom(other.data);
      }
      return this;
    }

    @Override
    public CompilerPluginData mergeFrom(final CompilerPluginData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasPluginId()) {
        setPluginId(other.pluginId);
      }
      if (other.hasData()) {
        getMutableData().copyFrom(other.data);
      }
      return this;
    }

    @Override
    public CompilerPluginData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      pluginId = 0;
      data.clear();
      return this;
    }

    @Override
    public CompilerPluginData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      data.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CompilerPluginData)) {
        return false;
      }
      CompilerPluginData other = (CompilerPluginData) o;
      return bitField0_ == other.bitField0_
        && (!hasPluginId() || pluginId == other.pluginId)
        && (!hasData() || data.equals(other.data));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000003) != 0x00000003))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(pluginId);
        output.writeRawByte((byte) 18);
        output.writeBytesNoTag(data);
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000003) != 0x00000003))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        size += 1 + ProtoSink.computeInt32SizeNoTag(pluginId);
        size += 1 + ProtoSink.computeBytesSizeNoTag(data);
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CompilerPluginData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // pluginId
            pluginId = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // data
            input.readBytes(data);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000003) != 0x00000003))) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasPluginId()) {
        results.add(prefix + "plugin_id");
      }
      if (!hasData()) {
        results.add(prefix + "data");
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000003) != 0x00000003))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        output.writeInt32(FieldNames.pluginId, pluginId);
        output.writeBytes(FieldNames.data, data);
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public CompilerPluginData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1859618898:
          case -1813589593: {
            if (input.isAtField(FieldNames.pluginId)) {
              if (!input.trySkipNullValue()) {
                pluginId = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3076010: {
            if (input.isAtField(FieldNames.data)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(data);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CompilerPluginData clone() {
      return new CompilerPluginData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CompilerPluginData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CompilerPluginData(), data).checkInitialized();
    }

    public static CompilerPluginData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CompilerPluginData(), input).checkInitialized();
    }

    public static CompilerPluginData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CompilerPluginData(), input).checkInitialized();
    }

    /**
     * @return factory for creating CompilerPluginData messages
     */
    public static MessageFactory<CompilerPluginData> getFactory() {
      return CompilerPluginDataFactory.INSTANCE;
    }

    private enum CompilerPluginDataFactory implements MessageFactory<CompilerPluginData> {
      INSTANCE;

      @Override
      public CompilerPluginData create() {
        return CompilerPluginData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName pluginId = FieldName.forField("pluginId", "plugin_id");

      static final FieldName data = FieldName.forField("data");
    }
  }
}
